# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class CallChainInfo(TeaModel):
    def __init__(
        self,
        additional_info: str = None,
        app_name: str = None,
        app_type: str = None,
        children: List['CallChainInfo'] = None,
        have_span: bool = None,
        log_map: Dict[str, dict] = None,
        log_time: int = None,
        parent_span_id: str = None,
        pid: str = None,
        region_id: str = None,
        result_code: str = None,
        rpc: str = None,
        rpc_id: str = None,
        rpc_type: int = None,
        server_ip: str = None,
        span: int = None,
        span_id: str = None,
        tag_map: Dict[str, str] = None,
        trace_id: str = None,
    ):
        self.additional_info = additional_info
        self.app_name = app_name
        self.app_type = app_type
        self.children = children
        self.have_span = have_span
        self.log_map = log_map
        self.log_time = log_time
        self.parent_span_id = parent_span_id
        self.pid = pid
        self.region_id = region_id
        self.result_code = result_code
        self.rpc = rpc
        self.rpc_id = rpc_id
        self.rpc_type = rpc_type
        self.server_ip = server_ip
        self.span = span
        self.span_id = span_id
        self.tag_map = tag_map
        self.trace_id = trace_id

    def validate(self):
        if self.children:
            for k in self.children:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_info is not None:
            result['AdditionalInfo'] = self.additional_info
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        result['Children'] = []
        if self.children is not None:
            for k in self.children:
                result['Children'].append(k.to_map() if k else None)
        if self.have_span is not None:
            result['HaveSpan'] = self.have_span
        if self.log_map is not None:
            result['LogMap'] = self.log_map
        if self.log_time is not None:
            result['LogTime'] = self.log_time
        if self.parent_span_id is not None:
            result['ParentSpanId'] = self.parent_span_id
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.rpc is not None:
            result['Rpc'] = self.rpc
        if self.rpc_id is not None:
            result['RpcId'] = self.rpc_id
        if self.rpc_type is not None:
            result['RpcType'] = self.rpc_type
        if self.server_ip is not None:
            result['ServerIp'] = self.server_ip
        if self.span is not None:
            result['Span'] = self.span
        if self.span_id is not None:
            result['SpanId'] = self.span_id
        if self.tag_map is not None:
            result['TagMap'] = self.tag_map
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalInfo') is not None:
            self.additional_info = m.get('AdditionalInfo')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        self.children = []
        if m.get('Children') is not None:
            for k in m.get('Children'):
                temp_model = CallChainInfo()
                self.children.append(temp_model.from_map(k))
        if m.get('HaveSpan') is not None:
            self.have_span = m.get('HaveSpan')
        if m.get('LogMap') is not None:
            self.log_map = m.get('LogMap')
        if m.get('LogTime') is not None:
            self.log_time = m.get('LogTime')
        if m.get('ParentSpanId') is not None:
            self.parent_span_id = m.get('ParentSpanId')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('Rpc') is not None:
            self.rpc = m.get('Rpc')
        if m.get('RpcId') is not None:
            self.rpc_id = m.get('RpcId')
        if m.get('RpcType') is not None:
            self.rpc_type = m.get('RpcType')
        if m.get('ServerIp') is not None:
            self.server_ip = m.get('ServerIp')
        if m.get('Span') is not None:
            self.span = m.get('Span')
        if m.get('SpanId') is not None:
            self.span_id = m.get('SpanId')
        if m.get('TagMap') is not None:
            self.tag_map = m.get('TagMap')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GrafanaWorkspaceTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GrafanaWorkspace(TeaModel):
    def __init__(
        self,
        commercial: bool = None,
        deploy_type: str = None,
        description: str = None,
        end_time: float = None,
        gmt_create: float = None,
        grafana_version: str = None,
        grafana_workspace_domain: str = None,
        grafana_workspace_domain_status: str = None,
        grafana_workspace_edition: str = None,
        grafana_workspace_id: str = None,
        grafana_workspace_ip: str = None,
        grafana_workspace_name: str = None,
        max_account: str = None,
        ntm_id: str = None,
        personal_domain: str = None,
        personal_domain_prefix: str = None,
        private_domain: str = None,
        private_ip: str = None,
        protocol: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        share_synced: bool = None,
        snat_ip: str = None,
        status: str = None,
        tags: List[GrafanaWorkspaceTags] = None,
        upgrade_version: List[str] = None,
        user_id: str = None,
    ):
        self.commercial = commercial
        self.deploy_type = deploy_type
        self.description = description
        self.end_time = end_time
        self.gmt_create = gmt_create
        self.grafana_version = grafana_version
        self.grafana_workspace_domain = grafana_workspace_domain
        self.grafana_workspace_domain_status = grafana_workspace_domain_status
        self.grafana_workspace_edition = grafana_workspace_edition
        self.grafana_workspace_id = grafana_workspace_id
        self.grafana_workspace_ip = grafana_workspace_ip
        self.grafana_workspace_name = grafana_workspace_name
        self.max_account = max_account
        self.ntm_id = ntm_id
        self.personal_domain = personal_domain
        self.personal_domain_prefix = personal_domain_prefix
        self.private_domain = private_domain
        self.private_ip = private_ip
        self.protocol = protocol
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        self.share_synced = share_synced
        self.snat_ip = snat_ip
        self.status = status
        self.tags = tags
        self.upgrade_version = upgrade_version
        self.user_id = user_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commercial is not None:
            result['commercial'] = self.commercial
        if self.deploy_type is not None:
            result['deployType'] = self.deploy_type
        if self.description is not None:
            result['description'] = self.description
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.grafana_version is not None:
            result['grafanaVersion'] = self.grafana_version
        if self.grafana_workspace_domain is not None:
            result['grafanaWorkspaceDomain'] = self.grafana_workspace_domain
        if self.grafana_workspace_domain_status is not None:
            result['grafanaWorkspaceDomainStatus'] = self.grafana_workspace_domain_status
        if self.grafana_workspace_edition is not None:
            result['grafanaWorkspaceEdition'] = self.grafana_workspace_edition
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.grafana_workspace_ip is not None:
            result['grafanaWorkspaceIp'] = self.grafana_workspace_ip
        if self.grafana_workspace_name is not None:
            result['grafanaWorkspaceName'] = self.grafana_workspace_name
        if self.max_account is not None:
            result['maxAccount'] = self.max_account
        if self.ntm_id is not None:
            result['ntmId'] = self.ntm_id
        if self.personal_domain is not None:
            result['personalDomain'] = self.personal_domain
        if self.personal_domain_prefix is not None:
            result['personalDomainPrefix'] = self.personal_domain_prefix
        if self.private_domain is not None:
            result['privateDomain'] = self.private_domain
        if self.private_ip is not None:
            result['privateIp'] = self.private_ip
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.resource_group_id is not None:
            result['resourceGroupId'] = self.resource_group_id
        if self.share_synced is not None:
            result['shareSynced'] = self.share_synced
        if self.snat_ip is not None:
            result['snatIp'] = self.snat_ip
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.upgrade_version is not None:
            result['upgradeVersion'] = self.upgrade_version
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commercial') is not None:
            self.commercial = m.get('commercial')
        if m.get('deployType') is not None:
            self.deploy_type = m.get('deployType')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('grafanaVersion') is not None:
            self.grafana_version = m.get('grafanaVersion')
        if m.get('grafanaWorkspaceDomain') is not None:
            self.grafana_workspace_domain = m.get('grafanaWorkspaceDomain')
        if m.get('grafanaWorkspaceDomainStatus') is not None:
            self.grafana_workspace_domain_status = m.get('grafanaWorkspaceDomainStatus')
        if m.get('grafanaWorkspaceEdition') is not None:
            self.grafana_workspace_edition = m.get('grafanaWorkspaceEdition')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('grafanaWorkspaceIp') is not None:
            self.grafana_workspace_ip = m.get('grafanaWorkspaceIp')
        if m.get('grafanaWorkspaceName') is not None:
            self.grafana_workspace_name = m.get('grafanaWorkspaceName')
        if m.get('maxAccount') is not None:
            self.max_account = m.get('maxAccount')
        if m.get('ntmId') is not None:
            self.ntm_id = m.get('ntmId')
        if m.get('personalDomain') is not None:
            self.personal_domain = m.get('personalDomain')
        if m.get('personalDomainPrefix') is not None:
            self.personal_domain_prefix = m.get('personalDomainPrefix')
        if m.get('privateDomain') is not None:
            self.private_domain = m.get('privateDomain')
        if m.get('privateIp') is not None:
            self.private_ip = m.get('privateIp')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('resourceGroupId') is not None:
            self.resource_group_id = m.get('resourceGroupId')
        if m.get('shareSynced') is not None:
            self.share_synced = m.get('shareSynced')
        if m.get('snatIp') is not None:
            self.snat_ip = m.get('snatIp')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GrafanaWorkspaceTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('upgradeVersion') is not None:
            self.upgrade_version = m.get('upgradeVersion')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GrafanaWorkspaceUserOrg(TeaModel):
    def __init__(
        self,
        org_id: int = None,
        org_name: str = None,
        role: str = None,
    ):
        self.org_id = org_id
        self.org_name = org_name
        self.role = role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.org_name is not None:
            result['orgName'] = self.org_name
        if self.role is not None:
            result['role'] = self.role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('orgName') is not None:
            self.org_name = m.get('orgName')
        if m.get('role') is not None:
            self.role = m.get('role')
        return self


class GrafanaWorkspaceAccount(TeaModel):
    def __init__(
        self,
        account_id: int = None,
        account_notes: str = None,
        aliyun_uid: str = None,
        aliyun_user_name: str = None,
        gmt_create: float = None,
        orgs: List[GrafanaWorkspaceUserOrg] = None,
        type: str = None,
    ):
        self.account_id = account_id
        self.account_notes = account_notes
        self.aliyun_uid = aliyun_uid
        self.aliyun_user_name = aliyun_user_name
        self.gmt_create = gmt_create
        self.orgs = orgs
        self.type = type

    def validate(self):
        if self.orgs:
            for k in self.orgs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.account_notes is not None:
            result['accountNotes'] = self.account_notes
        if self.aliyun_uid is not None:
            result['aliyunUid'] = self.aliyun_uid
        if self.aliyun_user_name is not None:
            result['aliyunUserName'] = self.aliyun_user_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        result['orgs'] = []
        if self.orgs is not None:
            for k in self.orgs:
                result['orgs'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('accountNotes') is not None:
            self.account_notes = m.get('accountNotes')
        if m.get('aliyunUid') is not None:
            self.aliyun_uid = m.get('aliyunUid')
        if m.get('aliyunUserName') is not None:
            self.aliyun_user_name = m.get('aliyunUserName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        self.orgs = []
        if m.get('orgs') is not None:
            for k in m.get('orgs'):
                temp_model = GrafanaWorkspaceUserOrg()
                self.orgs.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GrafanaWorkspaceAlertNotification(TeaModel):
    def __init__(
        self,
        id: int = None,
        is_arms: bool = None,
        is_default: bool = None,
        name: str = None,
        send_reminder: bool = None,
        settings: str = None,
        type: str = None,
        uid: str = None,
    ):
        self.id = id
        self.is_arms = is_arms
        self.is_default = is_default
        self.name = name
        self.send_reminder = send_reminder
        self.settings = settings
        self.type = type
        self.uid = uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_arms is not None:
            result['isArms'] = self.is_arms
        if self.is_default is not None:
            result['isDefault'] = self.is_default
        if self.name is not None:
            result['name'] = self.name
        if self.send_reminder is not None:
            result['sendReminder'] = self.send_reminder
        if self.settings is not None:
            result['settings'] = self.settings
        if self.type is not None:
            result['type'] = self.type
        if self.uid is not None:
            result['uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isArms') is not None:
            self.is_arms = m.get('isArms')
        if m.get('isDefault') is not None:
            self.is_default = m.get('isDefault')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sendReminder') is not None:
            self.send_reminder = m.get('sendReminder')
        if m.get('settings') is not None:
            self.settings = m.get('settings')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        return self


class GrafanaWorkspaceArmsAlertConfig(TeaModel):
    def __init__(
        self,
        arms_alerts_enable: str = None,
        arms_alerts_webhook_url: str = None,
    ):
        self.arms_alerts_enable = arms_alerts_enable
        self.arms_alerts_webhook_url = arms_alerts_webhook_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arms_alerts_enable is not None:
            result['armsAlertsEnable'] = self.arms_alerts_enable
        if self.arms_alerts_webhook_url is not None:
            result['armsAlertsWebhookUrl'] = self.arms_alerts_webhook_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('armsAlertsEnable') is not None:
            self.arms_alerts_enable = m.get('armsAlertsEnable')
        if m.get('armsAlertsWebhookUrl') is not None:
            self.arms_alerts_webhook_url = m.get('armsAlertsWebhookUrl')
        return self


class GrafanaWorkspaceCustomDomain(TeaModel):
    def __init__(
        self,
        cert: str = None,
        date: int = None,
        domain: str = None,
        grafana_workspace_id: str = None,
        id: int = None,
        key: str = None,
        private_zone: str = None,
        protocol: str = None,
        status: str = None,
        uri: str = None,
    ):
        self.cert = cert
        self.date = date
        self.domain = domain
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.key = key
        self.private_zone = private_zone
        self.protocol = protocol
        self.status = status
        self.uri = uri

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert is not None:
            result['cert'] = self.cert
        if self.date is not None:
            result['date'] = self.date
        if self.domain is not None:
            result['domain'] = self.domain
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.key is not None:
            result['key'] = self.key
        if self.private_zone is not None:
            result['privateZone'] = self.private_zone
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.status is not None:
            result['status'] = self.status
        if self.uri is not None:
            result['uri'] = self.uri
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cert') is not None:
            self.cert = m.get('cert')
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('privateZone') is not None:
            self.private_zone = m.get('privateZone')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('uri') is not None:
            self.uri = m.get('uri')
        return self


class GrafanaWorkspaceDashboardReport(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        grafana_workspace_id: str = None,
        id: int = None,
        last_send_time: int = None,
        msg: str = None,
        name: str = None,
        report_channel_target: str = None,
        report_channel_type: str = None,
        report_style: str = None,
        report_type: str = None,
        status: str = None,
        trigger_day: str = None,
        trigger_time: str = None,
        trigger_type: str = None,
        url: str = None,
        user_id: str = None,
    ):
        self.gmt_create = gmt_create
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.last_send_time = last_send_time
        self.msg = msg
        self.name = name
        self.report_channel_target = report_channel_target
        self.report_channel_type = report_channel_type
        self.report_style = report_style
        self.report_type = report_type
        self.status = status
        self.trigger_day = trigger_day
        self.trigger_time = trigger_time
        self.trigger_type = trigger_type
        self.url = url
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.last_send_time is not None:
            result['lastSendTime'] = self.last_send_time
        if self.msg is not None:
            result['msg'] = self.msg
        if self.name is not None:
            result['name'] = self.name
        if self.report_channel_target is not None:
            result['reportChannelTarget'] = self.report_channel_target
        if self.report_channel_type is not None:
            result['reportChannelType'] = self.report_channel_type
        if self.report_style is not None:
            result['reportStyle'] = self.report_style
        if self.report_type is not None:
            result['reportType'] = self.report_type
        if self.status is not None:
            result['status'] = self.status
        if self.trigger_day is not None:
            result['triggerDay'] = self.trigger_day
        if self.trigger_time is not None:
            result['triggerTime'] = self.trigger_time
        if self.trigger_type is not None:
            result['triggerType'] = self.trigger_type
        if self.url is not None:
            result['url'] = self.url
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastSendTime') is not None:
            self.last_send_time = m.get('lastSendTime')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('reportChannelTarget') is not None:
            self.report_channel_target = m.get('reportChannelTarget')
        if m.get('reportChannelType') is not None:
            self.report_channel_type = m.get('reportChannelType')
        if m.get('reportStyle') is not None:
            self.report_style = m.get('reportStyle')
        if m.get('reportType') is not None:
            self.report_type = m.get('reportType')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('triggerDay') is not None:
            self.trigger_day = m.get('triggerDay')
        if m.get('triggerTime') is not None:
            self.trigger_time = m.get('triggerTime')
        if m.get('triggerType') is not None:
            self.trigger_type = m.get('triggerType')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GrafanaWorkspaceDashboardSync(TeaModel):
    def __init__(
        self,
        dashboard_title: str = None,
        dashboard_url: str = None,
        dashboard_uid: str = None,
        folder_id: str = None,
        folder_title: str = None,
        folder_url: str = None,
        folder_uid: str = None,
        org_id: str = None,
        org_name: str = None,
        type: str = None,
    ):
        self.dashboard_title = dashboard_title
        self.dashboard_url = dashboard_url
        self.dashboard_uid = dashboard_uid
        self.folder_id = folder_id
        self.folder_title = folder_title
        self.folder_url = folder_url
        self.folder_uid = folder_uid
        self.org_id = org_id
        self.org_name = org_name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dashboard_title is not None:
            result['dashboardTitle'] = self.dashboard_title
        if self.dashboard_url is not None:
            result['dashboardURL'] = self.dashboard_url
        if self.dashboard_uid is not None:
            result['dashboardUid'] = self.dashboard_uid
        if self.folder_id is not None:
            result['folderId'] = self.folder_id
        if self.folder_title is not None:
            result['folderTitle'] = self.folder_title
        if self.folder_url is not None:
            result['folderURL'] = self.folder_url
        if self.folder_uid is not None:
            result['folderUid'] = self.folder_uid
        if self.org_id is not None:
            result['orgId'] = self.org_id
        if self.org_name is not None:
            result['orgName'] = self.org_name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dashboardTitle') is not None:
            self.dashboard_title = m.get('dashboardTitle')
        if m.get('dashboardURL') is not None:
            self.dashboard_url = m.get('dashboardURL')
        if m.get('dashboardUid') is not None:
            self.dashboard_uid = m.get('dashboardUid')
        if m.get('folderId') is not None:
            self.folder_id = m.get('folderId')
        if m.get('folderTitle') is not None:
            self.folder_title = m.get('folderTitle')
        if m.get('folderURL') is not None:
            self.folder_url = m.get('folderURL')
        if m.get('folderUid') is not None:
            self.folder_uid = m.get('folderUid')
        if m.get('orgId') is not None:
            self.org_id = m.get('orgId')
        if m.get('orgName') is not None:
            self.org_name = m.get('orgName')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GrafanaWorkspaceDataBackup(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        grafana_workspace_id: str = None,
        id: int = None,
        msg: str = None,
        process_name: str = None,
        process_status: str = None,
        sub_type: str = None,
        user_id: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.msg = msg
        self.process_name = process_name
        self.process_status = process_status
        self.sub_type = sub_type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.msg is not None:
            result['msg'] = self.msg
        if self.process_name is not None:
            result['processName'] = self.process_name
        if self.process_status is not None:
            result['processStatus'] = self.process_status
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('processName') is not None:
            self.process_name = m.get('processName')
        if m.get('processStatus') is not None:
            self.process_status = m.get('processStatus')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GrafanaWorkspaceIniBackup(TeaModel):
    def __init__(
        self,
        ext: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        grafana_workspace_id: str = None,
        id: int = None,
        msg: str = None,
        process_name: str = None,
        process_status: str = None,
        sub_type: str = None,
        user_id: str = None,
    ):
        self.ext = ext
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.msg = msg
        self.process_name = process_name
        self.process_status = process_status
        self.sub_type = sub_type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['ext'] = self.ext
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.msg is not None:
            result['msg'] = self.msg
        if self.process_name is not None:
            result['processName'] = self.process_name
        if self.process_status is not None:
            result['processStatus'] = self.process_status
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ext') is not None:
            self.ext = m.get('ext')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('processName') is not None:
            self.process_name = m.get('processName')
        if m.get('processStatus') is not None:
            self.process_status = m.get('processStatus')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GrafanaWorkspaceIniProperty(TeaModel):
    def __init__(
        self,
        default_value: str = None,
        description: str = None,
        example: str = None,
        key: str = None,
        secret: bool = None,
        value: str = None,
    ):
        self.default_value = default_value
        self.description = description
        self.example = example
        self.key = key
        self.secret = secret
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['defaultValue'] = self.default_value
        if self.description is not None:
            result['description'] = self.description
        if self.example is not None:
            result['example'] = self.example
        if self.key is not None:
            result['key'] = self.key
        if self.secret is not None:
            result['secret'] = self.secret
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('defaultValue') is not None:
            self.default_value = m.get('defaultValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('example') is not None:
            self.example = m.get('example')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('secret') is not None:
            self.secret = m.get('secret')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GrafanaWorkspaceIniSection(TeaModel):
    def __init__(
        self,
        propertys: List[GrafanaWorkspaceIniProperty] = None,
        section: str = None,
    ):
        self.propertys = propertys
        self.section = section

    def validate(self):
        if self.propertys:
            for k in self.propertys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['propertys'] = []
        if self.propertys is not None:
            for k in self.propertys:
                result['propertys'].append(k.to_map() if k else None)
        if self.section is not None:
            result['section'] = self.section
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.propertys = []
        if m.get('propertys') is not None:
            for k in m.get('propertys'):
                temp_model = GrafanaWorkspaceIniProperty()
                self.propertys.append(temp_model.from_map(k))
        if m.get('section') is not None:
            self.section = m.get('section')
        return self


class GrafanaWorkspaceIntegrationPreview(TeaModel):
    def __init__(
        self,
        id: str = None,
        image: str = None,
        name: str = None,
        thumbnail: str = None,
    ):
        self.id = id
        self.image = image
        self.name = name
        self.thumbnail = thumbnail

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.image is not None:
            result['image'] = self.image
        if self.name is not None:
            result['name'] = self.name
        if self.thumbnail is not None:
            result['thumbnail'] = self.thumbnail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('thumbnail') is not None:
            self.thumbnail = m.get('thumbnail')
        return self


class GrafanaWorkspaceIntegration(TeaModel):
    def __init__(
        self,
        datasource_amount: int = None,
        integration_id: str = None,
        integration_name: str = None,
        previews: List[GrafanaWorkspaceIntegrationPreview] = None,
        status: str = None,
        support_regions: List[str] = None,
    ):
        self.datasource_amount = datasource_amount
        self.integration_id = integration_id
        self.integration_name = integration_name
        self.previews = previews
        self.status = status
        self.support_regions = support_regions

    def validate(self):
        if self.previews:
            for k in self.previews:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.datasource_amount is not None:
            result['datasourceAmount'] = self.datasource_amount
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.integration_name is not None:
            result['integrationName'] = self.integration_name
        result['previews'] = []
        if self.previews is not None:
            for k in self.previews:
                result['previews'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.support_regions is not None:
            result['supportRegions'] = self.support_regions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('datasourceAmount') is not None:
            self.datasource_amount = m.get('datasourceAmount')
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('integrationName') is not None:
            self.integration_name = m.get('integrationName')
        self.previews = []
        if m.get('previews') is not None:
            for k in m.get('previews'):
                temp_model = GrafanaWorkspaceIntegrationPreview()
                self.previews.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('supportRegions') is not None:
            self.support_regions = m.get('supportRegions')
        return self


class GrafanaWorkspaceIntegrationDataSource(TeaModel):
    def __init__(
        self,
        cluster_type: str = None,
        datasource_id: str = None,
        datasource_name: str = None,
        datasource_url: str = None,
        description: str = None,
        explore_url: str = None,
        extra: Dict[str, str] = None,
        folder_url: str = None,
        region_id: str = None,
        status: str = None,
        type: str = None,
    ):
        self.cluster_type = cluster_type
        self.datasource_id = datasource_id
        self.datasource_name = datasource_name
        self.datasource_url = datasource_url
        self.description = description
        self.explore_url = explore_url
        self.extra = extra
        self.folder_url = folder_url
        self.region_id = region_id
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_type is not None:
            result['clusterType'] = self.cluster_type
        if self.datasource_id is not None:
            result['datasourceId'] = self.datasource_id
        if self.datasource_name is not None:
            result['datasourceName'] = self.datasource_name
        if self.datasource_url is not None:
            result['datasourceUrl'] = self.datasource_url
        if self.description is not None:
            result['description'] = self.description
        if self.explore_url is not None:
            result['exploreUrl'] = self.explore_url
        if self.extra is not None:
            result['extra'] = self.extra
        if self.folder_url is not None:
            result['folderUrl'] = self.folder_url
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clusterType') is not None:
            self.cluster_type = m.get('clusterType')
        if m.get('datasourceId') is not None:
            self.datasource_id = m.get('datasourceId')
        if m.get('datasourceName') is not None:
            self.datasource_name = m.get('datasourceName')
        if m.get('datasourceUrl') is not None:
            self.datasource_url = m.get('datasourceUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('exploreUrl') is not None:
            self.explore_url = m.get('exploreUrl')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        if m.get('folderUrl') is not None:
            self.folder_url = m.get('folderUrl')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GrafanaWorkspaceIntegrationDetail(TeaModel):
    def __init__(
        self,
        data_sources: List[GrafanaWorkspaceIntegrationDataSource] = None,
        integration_id: str = None,
        status: str = None,
    ):
        self.data_sources = data_sources
        self.integration_id = integration_id
        self.status = status

    def validate(self):
        if self.data_sources:
            for k in self.data_sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dataSources'] = []
        if self.data_sources is not None:
            for k in self.data_sources:
                result['dataSources'].append(k.to_map() if k else None)
        if self.integration_id is not None:
            result['integrationId'] = self.integration_id
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_sources = []
        if m.get('dataSources') is not None:
            for k in m.get('dataSources'):
                temp_model = GrafanaWorkspaceIntegrationDataSource()
                self.data_sources.append(temp_model.from_map(k))
        if m.get('integrationId') is not None:
            self.integration_id = m.get('integrationId')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GrafanaWorkspaceMoveProcess(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        grafana_workspace_id: str = None,
        id: int = None,
        msg: str = None,
        process_name: str = None,
        process_status: str = None,
        sub_type: str = None,
        user_id: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.msg = msg
        self.process_name = process_name
        self.process_status = process_status
        self.sub_type = sub_type
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.msg is not None:
            result['msg'] = self.msg
        if self.process_name is not None:
            result['processName'] = self.process_name
        if self.process_status is not None:
            result['processStatus'] = self.process_status
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('processName') is not None:
            self.process_name = m.get('processName')
        if m.get('processStatus') is not None:
            self.process_status = m.get('processStatus')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GrafanaWorkspaceNews(TeaModel):
    def __init__(
        self,
        date: int = None,
        description: str = None,
        image: str = None,
        link: str = None,
        title: str = None,
    ):
        self.date = date
        self.description = description
        self.image = image
        self.link = link
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['date'] = self.date
        if self.description is not None:
            result['description'] = self.description
        if self.image is not None:
            result['image'] = self.image
        if self.link is not None:
            result['link'] = self.link
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('link') is not None:
            self.link = m.get('link')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GrafanaWorkspaceOperateLog(TeaModel):
    def __init__(
        self,
        date: float = None,
        detail: str = None,
        grafana_workspace_id: str = None,
        id: int = None,
        operator_id: str = None,
    ):
        self.date = date
        self.detail = detail
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.operator_id = operator_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['date'] = self.date
        if self.detail is not None:
            result['detail'] = self.detail
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.operator_id is not None:
            result['operatorId'] = self.operator_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('date') is not None:
            self.date = m.get('date')
        if m.get('detail') is not None:
            self.detail = m.get('detail')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('operatorId') is not None:
            self.operator_id = m.get('operatorId')
        return self


class GrafanaWorkspaceOrg(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GrafanaWorkspaceTransDetail(TeaModel):
    def __init__(
        self,
        dashboard_amount: int = None,
        data_source_amount: int = None,
        original: int = None,
        original_name: str = None,
        target: int = None,
        target_name: str = None,
    ):
        self.dashboard_amount = dashboard_amount
        self.data_source_amount = data_source_amount
        self.original = original
        self.original_name = original_name
        self.target = target
        self.target_name = target_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dashboard_amount is not None:
            result['dashboardAmount'] = self.dashboard_amount
        if self.data_source_amount is not None:
            result['dataSourceAmount'] = self.data_source_amount
        if self.original is not None:
            result['original'] = self.original
        if self.original_name is not None:
            result['originalName'] = self.original_name
        if self.target is not None:
            result['target'] = self.target
        if self.target_name is not None:
            result['targetName'] = self.target_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dashboardAmount') is not None:
            self.dashboard_amount = m.get('dashboardAmount')
        if m.get('dataSourceAmount') is not None:
            self.data_source_amount = m.get('dataSourceAmount')
        if m.get('original') is not None:
            self.original = m.get('original')
        if m.get('originalName') is not None:
            self.original_name = m.get('originalName')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('targetName') is not None:
            self.target_name = m.get('targetName')
        return self


class GrafanaWorkspaceTrans(TeaModel):
    def __init__(
        self,
        api_url: str = None,
        auth_type: str = None,
        gmt_create: float = None,
        gmt_modified: float = None,
        grafana_workspace_id: str = None,
        id: int = None,
        msg: str = None,
        process_status: str = None,
        trans_details: List[GrafanaWorkspaceTransDetail] = None,
        user_id: str = None,
    ):
        self.api_url = api_url
        self.auth_type = auth_type
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.grafana_workspace_id = grafana_workspace_id
        self.id = id
        self.msg = msg
        self.process_status = process_status
        self.trans_details = trans_details
        self.user_id = user_id

    def validate(self):
        if self.trans_details:
            for k in self.trans_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_url is not None:
            result['apiUrl'] = self.api_url
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.grafana_workspace_id is not None:
            result['grafanaWorkspaceId'] = self.grafana_workspace_id
        if self.id is not None:
            result['id'] = self.id
        if self.msg is not None:
            result['msg'] = self.msg
        if self.process_status is not None:
            result['processStatus'] = self.process_status
        result['transDetails'] = []
        if self.trans_details is not None:
            for k in self.trans_details:
                result['transDetails'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('apiUrl') is not None:
            self.api_url = m.get('apiUrl')
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('grafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('grafanaWorkspaceId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('processStatus') is not None:
            self.process_status = m.get('processStatus')
        self.trans_details = []
        if m.get('transDetails') is not None:
            for k in m.get('transDetails'):
                temp_model = GrafanaWorkspaceTransDetail()
                self.trans_details.append(temp_model.from_map(k))
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class GrafanaWorkspaceUserCert(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GrafanaWorkspaceVpcConfig(TeaModel):
    def __init__(
        self,
        fc_config: str = None,
        id: int = None,
        install_msg: str = None,
        install_status: str = None,
        name: str = None,
        region_id: str = None,
        security_group_id: str = None,
        user_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        self.fc_config = fc_config
        self.id = id
        self.install_msg = install_msg
        self.install_status = install_status
        self.name = name
        self.region_id = region_id
        self.security_group_id = security_group_id
        self.user_id = user_id
        self.v_switch_id = v_switch_id
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fc_config is not None:
            result['fcConfig'] = self.fc_config
        if self.id is not None:
            result['id'] = self.id
        if self.install_msg is not None:
            result['installMsg'] = self.install_msg
        if self.install_status is not None:
            result['installStatus'] = self.install_status
        if self.name is not None:
            result['name'] = self.name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.security_group_id is not None:
            result['securityGroupId'] = self.security_group_id
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.v_switch_id is not None:
            result['vSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fcConfig') is not None:
            self.fc_config = m.get('fcConfig')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('installMsg') is not None:
            self.install_msg = m.get('installMsg')
        if m.get('installStatus') is not None:
            self.install_status = m.get('installStatus')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('securityGroupId') is not None:
            self.security_group_id = m.get('securityGroupId')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('vSwitchId') is not None:
            self.v_switch_id = m.get('vSwitchId')
        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')
        return self


class GrafanaWorkspaceVpcRegion(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        region_name: str = None,
    ):
        self.region_id = region_id
        self.region_name = region_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.region_name is not None:
            result['regionName'] = self.region_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('regionName') is not None:
            self.region_name = m.get('regionName')
        return self


class GrafanaWorkspaceVpcRegionDetail(TeaModel):
    def __init__(
        self,
        fc_config: str = None,
        id: int = None,
        install_status: str = None,
        name: str = None,
        region_id: str = None,
        security_group_id: str = None,
        security_group_ids: List[str] = None,
        user_id: str = None,
        v_switch_id: str = None,
        v_switch_ids: List[str] = None,
        vpc_id: str = None,
    ):
        self.fc_config = fc_config
        self.id = id
        self.install_status = install_status
        self.name = name
        self.region_id = region_id
        self.security_group_id = security_group_id
        self.security_group_ids = security_group_ids
        self.user_id = user_id
        self.v_switch_id = v_switch_id
        self.v_switch_ids = v_switch_ids
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fc_config is not None:
            result['fcConfig'] = self.fc_config
        if self.id is not None:
            result['id'] = self.id
        if self.install_status is not None:
            result['installStatus'] = self.install_status
        if self.name is not None:
            result['name'] = self.name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.security_group_id is not None:
            result['securityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['securityGroupIds'] = self.security_group_ids
        if self.user_id is not None:
            result['userId'] = self.user_id
        if self.v_switch_id is not None:
            result['vSwitchId'] = self.v_switch_id
        if self.v_switch_ids is not None:
            result['vSwitchIds'] = self.v_switch_ids
        if self.vpc_id is not None:
            result['vpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fcConfig') is not None:
            self.fc_config = m.get('fcConfig')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('installStatus') is not None:
            self.install_status = m.get('installStatus')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('securityGroupId') is not None:
            self.security_group_id = m.get('securityGroupId')
        if m.get('securityGroupIds') is not None:
            self.security_group_ids = m.get('securityGroupIds')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        if m.get('vSwitchId') is not None:
            self.v_switch_id = m.get('vSwitchId')
        if m.get('vSwitchIds') is not None:
            self.v_switch_ids = m.get('vSwitchIds')
        if m.get('vpcId') is not None:
            self.vpc_id = m.get('vpcId')
        return self


class QueryDataResponse(TeaModel):
    def __init__(
        self,
        results: str = None,
    ):
        self.results = results

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.results is not None:
            result['results'] = self.results
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('results') is not None:
            self.results = m.get('results')
        return self


class DataBonreeSDKConfigModuleConfigDefaultConfigValue(TeaModel):
    def __init__(
        self,
        enable: bool = None,
    ):
        # Indicates whether the configuration is enabled.
        self.enable = enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        return self


class DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue(TeaModel):
    def __init__(
        self,
        enable: bool = None,
    ):
        # Indicates whether the configuration is enabled.
        self.enable = enable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable is not None:
            result['enable'] = self.enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        return self


class DataBonreeSDKConfigModuleConfigVersionConfigsValue(TeaModel):
    def __init__(
        self,
        use_custom: bool = None,
        custom_config: Dict[str, DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue] = None,
        description: str = None,
        update_time: int = None,
    ):
        # Indicates whether the custom configuration is used.
        self.use_custom = use_custom
        # The custom configuration.
        self.custom_config = custom_config
        # The description of the version configuration.
        self.description = description
        # The time when the version configuration was updated.
        self.update_time = update_time

    def validate(self):
        if self.custom_config:
            for v in self.custom_config.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.use_custom is not None:
            result['useCustom'] = self.use_custom
        result['customConfig'] = {}
        if self.custom_config is not None:
            for k, v in self.custom_config.items():
                result['customConfig'][k] = v.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('useCustom') is not None:
            self.use_custom = m.get('useCustom')
        self.custom_config = {}
        if m.get('customConfig') is not None:
            for k, v in m.get('customConfig').items():
                temp_model = DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue()
                self.custom_config[k] = temp_model.from_map(v)
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class AddAliClusterIdsToPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: str = None,
        global_view_cluster_id: str = None,
        group_name: str = None,
        region_id: str = None,
    ):
        # The IDs of clusters. Separate multiple IDs with commas (,).
        # 
        # This parameter is required.
        self.cluster_ids = cluster_ids
        # The ID of the global aggregation instance.
        # 
        # This parameter is required.
        self.global_view_cluster_id = global_view_cluster_id
        # The name of the global aggregation instance.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddAliClusterIdsToPrometheusGlobalViewResponseBodyData(TeaModel):
    def __init__(
        self,
        info: str = None,
        msg: str = None,
        success: bool = None,
    ):
        # The Info-level information.
        self.info = info
        # The additional information.
        self.msg = msg
        # Indicates whether the request was successful.
        # 
        # *   `true`: The request was successful.
        # *   `false`: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddAliClusterIdsToPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AddAliClusterIdsToPrometheusGlobalViewResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The information about the array object.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddAliClusterIdsToPrometheusGlobalViewResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddAliClusterIdsToPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddAliClusterIdsToPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddAliClusterIdsToPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddGrafanaRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        integration: str = None,
        region_id: str = None,
    ):
        # The ID of the Container Service for Kubernetes (ACK) cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
        # 
        # This parameter is required.
        self.integration = integration
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.integration is not None:
            result['Integration'] = self.integration
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Integration') is not None:
            self.integration = m.get('Integration')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddGrafanaResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddGrafanaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddGrafanaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddGrafanaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        integration: str = None,
        region_id: str = None,
    ):
        # The ID of the Container Service for Kubernetes (ACK) cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
        # 
        # This parameter is required.
        self.integration = integration
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.integration is not None:
            result['Integration'] = self.integration
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Integration') is not None:
            self.integration = m.get('Integration')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # Indicates whether the call was successful.
        self.data = data
        # The prompt information of the returned result.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPrometheusGlobalViewRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        clusters: str = None,
        group_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tag: List[AddPrometheusGlobalViewRequestTag] = None,
    ):
        # The queried global aggregation instances. The value is a JSON string.
        # 
        # This parameter is required.
        self.clusters = clusters
        # The name of the aggregation instance.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The list of tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clusters is not None:
            result['Clusters'] = self.clusters
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Clusters') is not None:
            self.clusters = m.get('Clusters')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = AddPrometheusGlobalViewRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class AddPrometheusGlobalViewResponseBodyDataInfo(TeaModel):
    def __init__(
        self,
        failed_instances: str = None,
        global_view_cluster_id: str = None,
        region_id: str = None,
    ):
        # The list of instances that failed to be added.
        self.failed_instances = failed_instances
        # The ID of the global aggregation instance.
        self.global_view_cluster_id = global_view_cluster_id
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.failed_instances is not None:
            result['FailedInstances'] = self.failed_instances
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailedInstances') is not None:
            self.failed_instances = m.get('FailedInstances')
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddPrometheusGlobalViewResponseBodyData(TeaModel):
    def __init__(
        self,
        info: AddPrometheusGlobalViewResponseBodyDataInfo = None,
        msg: str = None,
        success: bool = None,
    ):
        # The Info-level information.
        self.info = info
        # The additional information.
        self.msg = msg
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.info:
            self.info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            temp_model = AddPrometheusGlobalViewResponseBodyDataInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AddPrometheusGlobalViewResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        #  200
        self.code = code
        # The information about the array object.
        self.data = data
        # 
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddPrometheusGlobalViewResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPrometheusGlobalViewByAliClusterIdsRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: str = None,
        group_name: str = None,
        product_code: str = None,
        region_id: str = None,
    ):
        # The IDs of clusters. Separate multiple IDs with commas (,).
        # 
        # This parameter is required.
        self.cluster_ids = cluster_ids
        # The name of the global aggregation instance.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The identifier to identify the service if custom dashboards are created for the specified clusters.
        self.product_code = product_code
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddPrometheusGlobalViewByAliClusterIdsResponseBodyData(TeaModel):
    def __init__(
        self,
        info: str = None,
        msg: str = None,
        success: bool = None,
    ):
        # The Info-level information.
        self.info = info
        # The additional information.
        self.msg = msg
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddPrometheusGlobalViewByAliClusterIdsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AddPrometheusGlobalViewByAliClusterIdsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The struct returned.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddPrometheusGlobalViewByAliClusterIdsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPrometheusGlobalViewByAliClusterIdsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPrometheusGlobalViewByAliClusterIdsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPrometheusGlobalViewByAliClusterIdsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The name of the Prometheus instance for Remote Write.
        # 
        # This parameter is required.
        self.name = name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the Prometheus instance. Only Prometheus instances for Remote Write is supported. Set the value to RW.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddPrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The struct returned. { "RequestId": the request ID, "Data": "{ "clusterType": the cluster type, "remoteWriteUrl": the public URL for remote write, "internetGrafanaUrl": the internal URL for Grafana, "authToken": indicates whether authentication is enabled, "internetPushGatewayUrl": the internal URL for Pushgateway, "clusterId": the cluster ID, "internetRemoteReadUrl": the internal URL for remote read, "remoteReadUrl": the public URL for remote read, "grafanaUrl": the public URL for Grafana, "pushGatewayUrl": the public URL for Pushgateway, "internetRemoteWriteUrl": the internal URL for remote write}" }
        self.data = data
        # The message returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddPrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPrometheusIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        integration_type: str = None,
        param: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The type of the integration.
        # 
        # This parameter is required.
        self.integration_type = integration_type
        # The configurations of the exporter. The value is a JSON string.
        # 
        # This parameter is required.
        self.param = param
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.param is not None:
            result['Param'] = self.param
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddPrometheusIntegrationResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: int = None,
        instance_name: str = None,
    ):
        # The ID of the exporter.
        self.instance_id = instance_id
        # The name of the exporter.
        self.instance_name = instance_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        return self


class AddPrometheusIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AddPrometheusIntegrationResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code or error code.
        self.code = code
        # The struct returned.
        self.data = data
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddPrometheusIntegrationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddPrometheusIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPrometheusIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPrometheusIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddRecordingRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        rule_yaml: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The custom recording rule. The value is in the YAML format.
        # 
        # This parameter is required.
        self.rule_yaml = rule_yaml

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_yaml is not None:
            result['RuleYaml'] = self.rule_yaml
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleYaml') is not None:
            self.rule_yaml = m.get('RuleYaml')
        return self


class AddRecordingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The status of the response.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddRecordingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddRecordingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddRecordingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTagToFlinkClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        flink_work_space_id: str = None,
        flink_work_space_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        target_user_id: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the Flink workspace.
        # 
        # This parameter is required.
        self.flink_work_space_id = flink_work_space_id
        # The name of the Flink workspace.
        # 
        # This parameter is required.
        self.flink_work_space_name = flink_work_space_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The ID of the Alibaba Cloud account to which the Flink workspace belongs.
        # 
        # This parameter is required.
        self.target_user_id = target_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.flink_work_space_id is not None:
            result['FlinkWorkSpaceId'] = self.flink_work_space_id
        if self.flink_work_space_name is not None:
            result['FlinkWorkSpaceName'] = self.flink_work_space_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('FlinkWorkSpaceId') is not None:
            self.flink_work_space_id = m.get('FlinkWorkSpaceId')
        if m.get('FlinkWorkSpaceName') is not None:
            self.flink_work_space_name = m.get('FlinkWorkSpaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        return self


class AddTagToFlinkClusterResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # Indicates whether the business logic was executed. Valid values:
        # 
        # *   true
        # *   false
        self.data = data
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddTagToFlinkClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddTagToFlinkClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTagToFlinkClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AppendInstancesToPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        clusters: str = None,
        global_view_cluster_id: str = None,
        group_name: str = None,
        region_id: str = None,
    ):
        # The list of global aggregation instances. The value is a JSON string.
        # 
        # This parameter is required.
        self.clusters = clusters
        # The ID of the global aggregation instance.
        # 
        # This parameter is required.
        self.global_view_cluster_id = global_view_cluster_id
        # The name of the global aggregation instance.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clusters is not None:
            result['Clusters'] = self.clusters
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Clusters') is not None:
            self.clusters = m.get('Clusters')
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AppendInstancesToPrometheusGlobalViewResponseBodyData(TeaModel):
    def __init__(
        self,
        info: str = None,
        msg: str = None,
        success: bool = None,
    ):
        # The Info-level information.
        self.info = info
        # The additional information.
        self.msg = msg
        # Indicates whether the call was successful. Valid values:
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AppendInstancesToPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: AppendInstancesToPrometheusGlobalViewResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # The information about the array object.
        self.data = data
        # Additional message.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AppendInstancesToPrometheusGlobalViewResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AppendInstancesToPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AppendInstancesToPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AppendInstancesToPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApplyScenarioRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        config: Dict[str, Any] = None,
        name: str = None,
        region_id: str = None,
        scenario: str = None,
        sign: str = None,
        sn_dump: bool = None,
        sn_force: bool = None,
        sn_stat: bool = None,
        sn_transfer: bool = None,
        update_option: bool = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.
        # 
        # This parameter is required.
        self.config = config
        # The name of the business monitoring job.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the region.
        self.region_id = region_id
        # The scenario where you want to use the business monitoring job. Valid values:
        # 
        # *   `USER-DEFINED`: user-defined. This is the default value.
        # *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
        # *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
        # *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
        self.scenario = scenario
        # The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.
        self.sign = sign
        # Specifies whether to record business parameters to the trace marked with the coloring sign.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_dump = sn_dump
        # Specifies whether traffic in the trace marked with the coloring sign is all collected.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_force = sn_force
        # Specifies whether to count traffic based on the coloring sign.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_stat = sn_stat
        # Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_transfer = sn_transfer
        # Specifies whether the operation is an update operation.
        # 
        # *   `true`: update
        # *   `false`: insert
        # 
        # This parameter is required.
        self.update_option = update_option

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.config is not None:
            result['Config'] = self.config
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.sign is not None:
            result['Sign'] = self.sign
        if self.sn_dump is not None:
            result['SnDump'] = self.sn_dump
        if self.sn_force is not None:
            result['SnForce'] = self.sn_force
        if self.sn_stat is not None:
            result['SnStat'] = self.sn_stat
        if self.sn_transfer is not None:
            result['SnTransfer'] = self.sn_transfer
        if self.update_option is not None:
            result['UpdateOption'] = self.update_option
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('Sign') is not None:
            self.sign = m.get('Sign')
        if m.get('SnDump') is not None:
            self.sn_dump = m.get('SnDump')
        if m.get('SnForce') is not None:
            self.sn_force = m.get('SnForce')
        if m.get('SnStat') is not None:
            self.sn_stat = m.get('SnStat')
        if m.get('SnTransfer') is not None:
            self.sn_transfer = m.get('SnTransfer')
        if m.get('UpdateOption') is not None:
            self.update_option = m.get('UpdateOption')
        return self


class ApplyScenarioShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        config_shrink: str = None,
        name: str = None,
        region_id: str = None,
        scenario: str = None,
        sign: str = None,
        sn_dump: bool = None,
        sn_force: bool = None,
        sn_stat: bool = None,
        sn_transfer: bool = None,
        update_option: bool = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.
        # 
        # This parameter is required.
        self.config_shrink = config_shrink
        # The name of the business monitoring job.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the region.
        self.region_id = region_id
        # The scenario where you want to use the business monitoring job. Valid values:
        # 
        # *   `USER-DEFINED`: user-defined. This is the default value.
        # *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
        # *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
        # *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
        self.scenario = scenario
        # The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.
        self.sign = sign
        # Specifies whether to record business parameters to the trace marked with the coloring sign.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_dump = sn_dump
        # Specifies whether traffic in the trace marked with the coloring sign is all collected.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_force = sn_force
        # Specifies whether to count traffic based on the coloring sign.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_stat = sn_stat
        # Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.
        # 
        # *   `true`
        # *   `false`: This is the default value.
        self.sn_transfer = sn_transfer
        # Specifies whether the operation is an update operation.
        # 
        # *   `true`: update
        # *   `false`: insert
        # 
        # This parameter is required.
        self.update_option = update_option

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.config_shrink is not None:
            result['Config'] = self.config_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.sign is not None:
            result['Sign'] = self.sign
        if self.sn_dump is not None:
            result['SnDump'] = self.sn_dump
        if self.sn_force is not None:
            result['SnForce'] = self.sn_force
        if self.sn_stat is not None:
            result['SnStat'] = self.sn_stat
        if self.sn_transfer is not None:
            result['SnTransfer'] = self.sn_transfer
        if self.update_option is not None:
            result['UpdateOption'] = self.update_option
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Config') is not None:
            self.config_shrink = m.get('Config')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('Sign') is not None:
            self.sign = m.get('Sign')
        if m.get('SnDump') is not None:
            self.sn_dump = m.get('SnDump')
        if m.get('SnForce') is not None:
            self.sn_force = m.get('SnForce')
        if m.get('SnStat') is not None:
            self.sn_stat = m.get('SnStat')
        if m.get('SnTransfer') is not None:
            self.sn_transfer = m.get('SnTransfer')
        if m.get('UpdateOption') is not None:
            self.update_option = m.get('UpdateOption')
        return self


class ApplyScenarioResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The code of the business monitoring job, which is the coloring sign.
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class ApplyScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ApplyScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApplyScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindPrometheusGrafanaInstanceRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        grafana_instance_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the Grafana workspace.
        # 
        # This parameter is required.
        self.grafana_instance_id = grafana_instance_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group to which the Prometheus instance belongs.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.grafana_instance_id is not None:
            result['GrafanaInstanceId'] = self.grafana_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('GrafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('GrafanaInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class BindPrometheusGrafanaInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # Indicates whether the request was successful.
        # 
        # *   true
        # *   false
        self.data = data
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BindPrometheusGrafanaInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindPrometheusGrafanaInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindPrometheusGrafanaInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BlockAlarmNotificationRequest(TeaModel):
    def __init__(
        self,
        alarm_id: int = None,
        handler_id: int = None,
        region_id: str = None,
        timeout: int = None,
    ):
        # The ID of the alert.
        # 
        # For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
        # 
        # This parameter is required.
        self.alarm_id = alarm_id
        # The ID of the alert handler.
        self.handler_id = handler_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The number of seconds that elapse before alert notifications are blocked. Unit: seconds.
        # 
        # This parameter is required.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_id is not None:
            result['AlarmId'] = self.alarm_id
        if self.handler_id is not None:
            result['HandlerId'] = self.handler_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmId') is not None:
            self.alarm_id = m.get('AlarmId')
        if m.get('HandlerId') is not None:
            self.handler_id = m.get('HandlerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class BlockAlarmNotificationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BlockAlarmNotificationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BlockAlarmNotificationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BlockAlarmNotificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeAlarmSeverityRequest(TeaModel):
    def __init__(
        self,
        alarm_id: int = None,
        handler_id: int = None,
        region_id: str = None,
        severity: str = None,
    ):
        # The ID of the alert.
        # 
        # For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
        # 
        # This parameter is required.
        self.alarm_id = alarm_id
        # The ID of the handler.
        self.handler_id = handler_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The severity level of the alert. Valid values: P1, P2, P3, and P4. P4 indicates the lowest severity, whereas P1 indicates the highest severity.
        # 
        # This parameter is required.
        self.severity = severity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_id is not None:
            result['AlarmId'] = self.alarm_id
        if self.handler_id is not None:
            result['HandlerId'] = self.handler_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmId') is not None:
            self.alarm_id = m.get('AlarmId')
        if m.get('HandlerId') is not None:
            self.handler_id = m.get('HandlerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class ChangeAlarmSeverityResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the severity level was modified.
        # 
        # - `true`: The severity level was modified.
        # - `false`: The severity level failed to be modified.
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # - true
        # - false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ChangeAlarmSeverityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeAlarmSeverityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeAlarmSeverityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ChangeResourceGroupRequest(TeaModel):
    def __init__(
        self,
        new_resource_group_id: str = None,
        region_id: str = None,
        resource_id: str = None,
        resource_type: str = None,
    ):
        # The ID of the new resource group. You can view the available resource groups in the Resource Management console.
        # 
        # This parameter is required.
        self.new_resource_group_id = new_resource_group_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource ID.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The resource type.
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.new_resource_group_id is not None:
            result['NewResourceGroupId'] = self.new_resource_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NewResourceGroupId') is not None:
            self.new_resource_group_id = m.get('NewResourceGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class ChangeResourceGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        resource_group_id: str = None,
        resource_id: str = None,
    ):
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The resource ID.
        self.resource_id = resource_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        return self


class ChangeResourceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ChangeResourceGroupResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code or error code.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ChangeResourceGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ChangeResourceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ChangeResourceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ChangeResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckCommercialStatusRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        service: str = None,
    ):
        # The region ID. Default value: cn-hangzhou.
        self.region_id = region_id
        # The ARMS sub-service. Valid values:
        # 
        # *   apm: Application Monitoring
        # *   rum: RUM
        # *   prometheus: Managed Service for Prometheus
        # *   xtrace: Managed Service for OpenTelemetry
        # 
        # This parameter is required.
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service is not None:
            result['Service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Service') is not None:
            self.service = m.get('Service')
        return self


class CheckCommercialStatusResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CheckCommercialStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckCommercialStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckCommercialStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckServiceStatusRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        svc_code: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The service code of an Alibaba Cloud service. The service code of Managed Service for Prometheus is prometheus.
        # 
        # This parameter is required.
        self.svc_code = svc_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.svc_code is not None:
            result['SvcCode'] = self.svc_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SvcCode') is not None:
            self.svc_code = m.get('SvcCode')
        return self


class CheckServiceStatusResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true.
        # *   false.
        self.data = data
        # The request ID. You can use the ID to find logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CheckServiceStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckServiceStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckServiceStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClaimAlarmRequest(TeaModel):
    def __init__(
        self,
        alarm_id: int = None,
        handler_id: int = None,
        region_id: str = None,
    ):
        # The ID of the alert.
        # 
        # For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
        # 
        # This parameter is required.
        self.alarm_id = alarm_id
        # The ID of the handler.
        self.handler_id = handler_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_id is not None:
            result['AlarmId'] = self.alarm_id
        if self.handler_id is not None:
            result['HandlerId'] = self.handler_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmId') is not None:
            self.alarm_id = m.get('AlarmId')
        if m.get('HandlerId') is not None:
            self.handler_id = m.get('HandlerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ClaimAlarmResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # `true`
        # 
        # `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ClaimAlarmResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClaimAlarmResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClaimAlarmResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseAlarmRequest(TeaModel):
    def __init__(
        self,
        alarm_id: int = None,
        handler_id: int = None,
        region_id: str = None,
        solution: str = None,
    ):
        # The ID of the alert.
        # 
        # For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
        # 
        # This parameter is required.
        self.alarm_id = alarm_id
        # The ID of the alert handler.
        self.handler_id = handler_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The alert solution.
        self.solution = solution

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_id is not None:
            result['AlarmId'] = self.alarm_id
        if self.handler_id is not None:
            result['HandlerId'] = self.handler_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.solution is not None:
            result['Solution'] = self.solution
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmId') is not None:
            self.alarm_id = m.get('AlarmId')
        if m.get('HandlerId') is not None:
            self.handler_id = m.get('HandlerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        return self


class CloseAlarmResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.result = result
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CloseAlarmResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseAlarmResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseAlarmResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfigAppRequest(TeaModel):
    def __init__(
        self,
        app_ids: str = None,
        enable: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The process identifier (PID) of the application. Separate multiple PIDs with commas (,).
        # 
        # This parameter is required.
        self.app_ids = app_ids
        # Specifies whether to turn on or off the main switch of the ARMS agent. The monitoring stops after the switch is turned off. If you do not specify this parameter, the main switch status of the ARMS agent is queried.
        # 
        # *   `true`: turns on the switch
        # *   `false`: turns off the switch
        self.enable = enable
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the application. Set the value to **TRACE**.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_ids is not None:
            result['AppIds'] = self.app_ids
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppIds') is not None:
            self.app_ids = m.get('AppIds')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ConfigAppResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The result of turning on or off the main switch of the agent or the main switch status of the agent. Indicates whether the request was successful. Valid values:
        # 
        # *   success
        # *   failed
        # 
        # The main switch status of the agent. Valid values:
        # 
        # *   true
        # *   false
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ConfigAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConfigAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfigAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertContactRequest(TeaModel):
    def __init__(
        self,
        contact_name: str = None,
        ding_robot_webhook_url: str = None,
        email: str = None,
        phone_num: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        system_noc: bool = None,
    ):
        # The name of the alert contact.
        self.contact_name = contact_name
        # The webhook URL of the DingTalk chatbot. For more information about how to obtain the URL, see [Configure a DingTalk chatbot to send alert notifications](https://www.alibabacloud.com/help/zh/doc-detail/106247.htm). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
        # 
        # >  Enter `alert` in the custom keyword field of DingTalk chatbot security settings.
        self.ding_robot_webhook_url = ding_robot_webhook_url
        # The email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
        self.email = email
        # The mobile number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
        self.phone_num = phone_num
        # The ID of the region. Set the value to `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
        self.resource_group_id = resource_group_id
        # Specifies whether the alert contact receives system notifications. Valid values:
        # 
        # *   `true`: The alert contact receives system notifications.
        # *   `false`: The alert contact does not receive system notifications.
        self.system_noc = system_noc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.ding_robot_webhook_url is not None:
            result['DingRobotWebhookUrl'] = self.ding_robot_webhook_url
        if self.email is not None:
            result['Email'] = self.email
        if self.phone_num is not None:
            result['PhoneNum'] = self.phone_num
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.system_noc is not None:
            result['SystemNoc'] = self.system_noc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('DingRobotWebhookUrl') is not None:
            self.ding_robot_webhook_url = m.get('DingRobotWebhookUrl')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('PhoneNum') is not None:
            self.phone_num = m.get('PhoneNum')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SystemNoc') is not None:
            self.system_noc = m.get('SystemNoc')
        return self


class CreateAlertContactResponseBody(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        request_id: str = None,
    ):
        # The ID of the alert contact.
        self.contact_id = contact_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAlertContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAlertContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_name: str = None,
        contact_ids: str = None,
        region_id: str = None,
    ):
        # The name of the alert contact group.
        # 
        # This parameter is required.
        self.contact_group_name = contact_group_name
        # The IDs of contacts in the contact group. Separate multiple contact IDs with spaces. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](https://help.aliyun.com/document_detail/130703.html).
        self.contact_ids = contact_ids
        # The region ID. Default value: `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateAlertContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        contact_group_id: str = None,
        request_id: str = None,
    ):
        # The ID of the alert contact group.
        self.contact_group_id = contact_group_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAlertContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAlertContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAlertContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDispatchRuleRequest(TeaModel):
    def __init__(
        self,
        dispatch_rule: str = None,
        region_id: str = None,
    ):
        # The dispatch rule configuration. The value is a JSON string. For more information about this parameter, see the following **additional information about the DispatchRule parameter**.
        # 
        # This parameter is required.
        self.dispatch_rule = dispatch_rule
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dispatch_rule is not None:
            result['DispatchRule'] = self.dispatch_rule
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DispatchRule') is not None:
            self.dispatch_rule = m.get('DispatchRule')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateDispatchRuleResponseBody(TeaModel):
    def __init__(
        self,
        dispatch_rule_id: int = None,
        request_id: str = None,
    ):
        # The ID of the dispatch policy.
        self.dispatch_rule_id = dispatch_rule_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDispatchRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDispatchRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDispatchRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnvCustomJobRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config_yaml: str = None,
        custom_job_name: str = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The YAML configuration string of the custom job.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # The name of the custom job.
        # 
        # This parameter is required.
        self.custom_job_name = custom_job_name
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.custom_job_name is not None:
            result['CustomJobName'] = self.custom_job_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('CustomJobName') is not None:
            self.custom_job_name = m.get('CustomJobName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateEnvCustomJobResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The name of the custom job that was created, or the exception information.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnvCustomJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnvCustomJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnvCustomJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnvPodMonitorRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config_yaml: str = None,
        dry_run: bool = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The YAML configuration string of the PodMonitor.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # Specifies whether to perform only a dry run, without performing the actual request.
        self.dry_run = dry_run
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateEnvPodMonitorResponseBodyData(TeaModel):
    def __init__(
        self,
        matched_msg: str = None,
        matched_target_count: str = None,
        namespace: str = None,
        pod_monitor_name: str = None,
    ):
        # Indicates whether targets are matched.
        self.matched_msg = matched_msg
        # The number of matched targets.
        self.matched_target_count = matched_target_count
        # The namespace.
        self.namespace = namespace
        # The name of the created PodMonitor.
        self.pod_monitor_name = pod_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.matched_msg is not None:
            result['MatchedMsg'] = self.matched_msg
        if self.matched_target_count is not None:
            result['MatchedTargetCount'] = self.matched_target_count
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod_monitor_name is not None:
            result['PodMonitorName'] = self.pod_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MatchedMsg') is not None:
            self.matched_msg = m.get('MatchedMsg')
        if m.get('MatchedTargetCount') is not None:
            self.matched_target_count = m.get('MatchedTargetCount')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PodMonitorName') is not None:
            self.pod_monitor_name = m.get('PodMonitorName')
        return self


class CreateEnvPodMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: CreateEnvPodMonitorResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned result, which indicates whether the operation was successful.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateEnvPodMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnvPodMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnvPodMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnvPodMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnvServiceMonitorRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config_yaml: str = None,
        dry_run: bool = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The language. Valid values:
        # 
        # *   zh (default): Chinese
        # *   en: English
        self.aliyun_lang = aliyun_lang
        # The YAML configuration file of the ServiceMonitor.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # Specifies whether to perform only a dry run, without performing the actual request. The system checks whether the format is valid and whether targets are matched.
        self.dry_run = dry_run
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateEnvServiceMonitorResponseBodyData(TeaModel):
    def __init__(
        self,
        matched_msg: str = None,
        matched_target_count: int = None,
        namespace: str = None,
        service_monitor_name: str = None,
    ):
        # Indicates whether targets are matched.
        self.matched_msg = matched_msg
        # The number of matched targets.
        self.matched_target_count = matched_target_count
        # The namespace.
        self.namespace = namespace
        # The name of the created ServiceMonitor.
        self.service_monitor_name = service_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.matched_msg is not None:
            result['MatchedMsg'] = self.matched_msg
        if self.matched_target_count is not None:
            result['MatchedTargetCount'] = self.matched_target_count
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.service_monitor_name is not None:
            result['ServiceMonitorName'] = self.service_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MatchedMsg') is not None:
            self.matched_msg = m.get('MatchedMsg')
        if m.get('MatchedTargetCount') is not None:
            self.matched_target_count = m.get('MatchedTargetCount')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ServiceMonitorName') is not None:
            self.service_monitor_name = m.get('ServiceMonitorName')
        return self


class CreateEnvServiceMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: CreateEnvServiceMonitorResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateEnvServiceMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnvServiceMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnvServiceMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnvServiceMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEnvironmentRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateEnvironmentRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        bind_resource_id: str = None,
        environment_name: str = None,
        environment_sub_type: str = None,
        environment_type: str = None,
        fee_package: str = None,
        grafana_workspace_id: str = None,
        init_environment: bool = None,
        managed_type: str = None,
        prometheus_instance_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[CreateEnvironmentRequestTags] = None,
    ):
        # The language. Default value: zh.
        # 
        # Valid values:
        # *   en: English
        # *   zh: Chinese
        self.aliyun_lang = aliyun_lang
        # The ID of the resource bound to the environment, such as the container ID or VPC ID. For a Cloud environment, specify the region ID.
        # 
        # This parameter is required.
        self.bind_resource_id = bind_resource_id
        # The name of the environment.
        # 
        # This parameter is required.
        self.environment_name = environment_name
        # The subtype of the environment. Valid values:
        # 
        # *   CS: Container Service for Kubernetes (ACK) or Distributed Cloud Container Platform for Kubernetes (ACK One)
        # *   ECS: ECS
        # *   Cloud: cloud service
        # 
        # This parameter is required.
        self.environment_sub_type = environment_sub_type
        # The type of the environment. Valid values:
        # 
        # *   CS: Container Service
        # *   ECS: Elastic Compute Service
        # *   Cloud: cloud service
        # 
        # This parameter is required.
        self.environment_type = environment_type
        # The payable resource plan.
        # 
        # *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
        # *   Otherwise, leave the parameter empty.
        self.fee_package = fee_package
        # The ID of the Grafana workspace associated with the environment. If this parameter is left empty, the default shared Grafana workspace is used.
        self.grafana_workspace_id = grafana_workspace_id
        # Specifies whether to initialize the environment.
        self.init_environment = init_environment
        # Specifies whether agents or exporters are managed. Valid values:
        # 
        # *   none: No. By default, no managed agents or exporters are provided for ACK clusters.
        # *   agent: Agents are managed. By default, managed agents are provided for ASK clusters, ACS clusters, and ACK One clusters.
        # *   agent-exporter: Agents and exporters are managed. By default, managed agents and exporters are provided for cloud services.
        self.managed_type = managed_type
        # The ID of the Prometheus instance. If no Prometheus instance is created, call the InitEnvironment operation.
        self.prometheus_instance_id = prometheus_instance_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags of the instance. You can specify this parameter to manage tags for the instance.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.environment_sub_type is not None:
            result['EnvironmentSubType'] = self.environment_sub_type
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.init_environment is not None:
            result['InitEnvironment'] = self.init_environment
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.prometheus_instance_id is not None:
            result['PrometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('EnvironmentSubType') is not None:
            self.environment_sub_type = m.get('EnvironmentSubType')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('InitEnvironment') is not None:
            self.init_environment = m.get('InitEnvironment')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('PrometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('PrometheusInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateEnvironmentRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The ID of the created environment.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGrafanaWorkspaceRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateGrafanaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        account_number: str = None,
        aliyun_lang: str = None,
        auto_renew: str = None,
        custom_account_number: str = None,
        description: str = None,
        duration: str = None,
        grafana_version: str = None,
        grafana_workspace_edition: str = None,
        grafana_workspace_name: str = None,
        password: str = None,
        pricing_cycle: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[CreateGrafanaWorkspaceRequestTags] = None,
    ):
        self.account_number = account_number
        # The language. Default value: zh. Valid values:
        # 
        # *   zh
        # *   en
        self.aliyun_lang = aliyun_lang
        self.auto_renew = auto_renew
        self.custom_account_number = custom_account_number
        # The description of the workspace
        self.description = description
        self.duration = duration
        # This parameter is required.
        self.grafana_version = grafana_version
        # The edition.
        # 
        # **Valid values:**\
        # 
        # *   standard: `Beta Edition or Standard Edition`
        # *   personal_edition: Developer Edition
        # *   experts_edition: Pro Edition
        # *   advanced_edition: Advanced Edition
        # 
        # This parameter is required.
        self.grafana_workspace_edition = grafana_workspace_edition
        # The name of the Grafana workspace.
        # 
        # This parameter is required.
        self.grafana_workspace_name = grafana_workspace_name
        # The password of the workspace. The password must be 8 to 30 characters in length. It must include at least three of the following characters types: uppercase letter, lowercase letter, digit, and special character. Special characters include () \\" ~ ! @ # $ % ^ & \\* - _ + =.
        self.password = password
        self.pricing_cycle = pricing_cycle
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The list of tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_number is not None:
            result['AccountNumber'] = self.account_number
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.custom_account_number is not None:
            result['CustomAccountNumber'] = self.custom_account_number
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.grafana_version is not None:
            result['GrafanaVersion'] = self.grafana_version
        if self.grafana_workspace_edition is not None:
            result['GrafanaWorkspaceEdition'] = self.grafana_workspace_edition
        if self.grafana_workspace_name is not None:
            result['GrafanaWorkspaceName'] = self.grafana_workspace_name
        if self.password is not None:
            result['Password'] = self.password
        if self.pricing_cycle is not None:
            result['PricingCycle'] = self.pricing_cycle
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountNumber') is not None:
            self.account_number = m.get('AccountNumber')
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('CustomAccountNumber') is not None:
            self.custom_account_number = m.get('CustomAccountNumber')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('GrafanaVersion') is not None:
            self.grafana_version = m.get('GrafanaVersion')
        if m.get('GrafanaWorkspaceEdition') is not None:
            self.grafana_workspace_edition = m.get('GrafanaWorkspaceEdition')
        if m.get('GrafanaWorkspaceName') is not None:
            self.grafana_workspace_name = m.get('GrafanaWorkspaceName')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PricingCycle') is not None:
            self.pricing_cycle = m.get('PricingCycle')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateGrafanaWorkspaceRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateGrafanaWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        account_number: str = None,
        aliyun_lang: str = None,
        auto_renew: str = None,
        custom_account_number: str = None,
        description: str = None,
        duration: str = None,
        grafana_version: str = None,
        grafana_workspace_edition: str = None,
        grafana_workspace_name: str = None,
        password: str = None,
        pricing_cycle: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags_shrink: str = None,
    ):
        self.account_number = account_number
        # The language. Default value: zh. Valid values:
        # 
        # *   zh
        # *   en
        self.aliyun_lang = aliyun_lang
        self.auto_renew = auto_renew
        self.custom_account_number = custom_account_number
        # The description of the workspace
        self.description = description
        self.duration = duration
        # This parameter is required.
        self.grafana_version = grafana_version
        # The edition.
        # 
        # **Valid values:**\
        # 
        # *   standard: `Beta Edition or Standard Edition`
        # *   personal_edition: Developer Edition
        # *   experts_edition: Pro Edition
        # *   advanced_edition: Advanced Edition
        # 
        # This parameter is required.
        self.grafana_workspace_edition = grafana_workspace_edition
        # The name of the Grafana workspace.
        # 
        # This parameter is required.
        self.grafana_workspace_name = grafana_workspace_name
        # The password of the workspace. The password must be 8 to 30 characters in length. It must include at least three of the following characters types: uppercase letter, lowercase letter, digit, and special character. Special characters include () \\" ~ ! @ # $ % ^ & \\* - _ + =.
        self.password = password
        self.pricing_cycle = pricing_cycle
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The list of tags.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_number is not None:
            result['AccountNumber'] = self.account_number
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.custom_account_number is not None:
            result['CustomAccountNumber'] = self.custom_account_number
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.grafana_version is not None:
            result['GrafanaVersion'] = self.grafana_version
        if self.grafana_workspace_edition is not None:
            result['GrafanaWorkspaceEdition'] = self.grafana_workspace_edition
        if self.grafana_workspace_name is not None:
            result['GrafanaWorkspaceName'] = self.grafana_workspace_name
        if self.password is not None:
            result['Password'] = self.password
        if self.pricing_cycle is not None:
            result['PricingCycle'] = self.pricing_cycle
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccountNumber') is not None:
            self.account_number = m.get('AccountNumber')
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('CustomAccountNumber') is not None:
            self.custom_account_number = m.get('CustomAccountNumber')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('GrafanaVersion') is not None:
            self.grafana_version = m.get('GrafanaVersion')
        if m.get('GrafanaWorkspaceEdition') is not None:
            self.grafana_workspace_edition = m.get('GrafanaWorkspaceEdition')
        if m.get('GrafanaWorkspaceName') is not None:
            self.grafana_workspace_name = m.get('GrafanaWorkspaceName')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PricingCycle') is not None:
            self.pricing_cycle = m.get('PricingCycle')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class CreateGrafanaWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GrafanaWorkspace = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The information about the Grafana workspace.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success
        # The ID of the trace.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GrafanaWorkspace()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class CreateGrafanaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateGrafanaWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateGrafanaWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateIntegrationRequest(TeaModel):
    def __init__(
        self,
        auto_recover: bool = None,
        description: str = None,
        integration_name: str = None,
        integration_product_type: str = None,
        recover_time: int = None,
        region_id: str = None,
    ):
        # Specifies whether to automatically clear alert events. Default value: true. Valid values:
        # 
        # *   true
        # *   false
        self.auto_recover = auto_recover
        # The description of the alert integration.
        self.description = description
        # The name of the alert integration.
        # 
        # This parameter is required.
        self.integration_name = integration_name
        # The service of the alert integration. Valid values:
        # 
        # *   CLOUD_MONITOR: CloudMonitor
        # *   LOG_SERVICE: Log Service
        # 
        # This parameter is required.
        self.integration_product_type = integration_product_type
        # The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
        self.recover_time = recover_time
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover is not None:
            result['AutoRecover'] = self.auto_recover
        if self.description is not None:
            result['Description'] = self.description
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_product_type is not None:
            result['IntegrationProductType'] = self.integration_product_type
        if self.recover_time is not None:
            result['RecoverTime'] = self.recover_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRecover') is not None:
            self.auto_recover = m.get('AutoRecover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationProductType') is not None:
            self.integration_product_type = m.get('IntegrationProductType')
        if m.get('RecoverTime') is not None:
            self.recover_time = m.get('RecoverTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateIntegrationResponseBodyIntegration(TeaModel):
    def __init__(
        self,
        auto_recover: bool = None,
        description: str = None,
        integration_id: int = None,
        integration_name: str = None,
        integration_product_type: str = None,
        recover_time: int = None,
    ):
        # Indicates whether alert events are automatically cleared. Default value: true. Valid values:
        # 
        # *   true
        # *   false
        self.auto_recover = auto_recover
        # The description of the alert integration.
        self.description = description
        # The ID of the alert integration.
        self.integration_id = integration_id
        # The name of the alert integration.
        self.integration_name = integration_name
        # The service of the alert integration. Valid values:
        # 
        # *   CLOUD_MONITOR: CloudMonitor
        # *   LOG_SERVICE: Log Service
        self.integration_product_type = integration_product_type
        # The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
        self.recover_time = recover_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover is not None:
            result['AutoRecover'] = self.auto_recover
        if self.description is not None:
            result['Description'] = self.description
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_product_type is not None:
            result['IntegrationProductType'] = self.integration_product_type
        if self.recover_time is not None:
            result['RecoverTime'] = self.recover_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRecover') is not None:
            self.auto_recover = m.get('AutoRecover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationProductType') is not None:
            self.integration_product_type = m.get('IntegrationProductType')
        if m.get('RecoverTime') is not None:
            self.recover_time = m.get('RecoverTime')
        return self


class CreateIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration: CreateIntegrationResponseBodyIntegration = None,
        request_id: str = None,
    ):
        # The returned information about the alert integration.
        self.integration = integration
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.integration:
            self.integration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration is not None:
            result['Integration'] = self.integration.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Integration') is not None:
            temp_model = CreateIntegrationResponseBodyIntegration()
            self.integration = temp_model.from_map(m['Integration'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateAlertRuleRequestMarkTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The Tag Key.
        self.key = key
        # The Tag Value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_check_type: str = None,
        alert_group: int = None,
        alert_id: int = None,
        alert_name: str = None,
        alert_piplines: str = None,
        alert_rule_content: str = None,
        alert_status: str = None,
        alert_type: str = None,
        annotations: str = None,
        auto_add_new_application: bool = None,
        auto_add_target_config: str = None,
        cluster_id: str = None,
        data_config: str = None,
        duration: int = None,
        filters: str = None,
        labels: str = None,
        level: str = None,
        mark_tags: List[CreateOrUpdateAlertRuleRequestMarkTags] = None,
        message: str = None,
        metrics_key: str = None,
        metrics_type: str = None,
        notice: str = None,
        notify_mode: str = None,
        notify_strategy: str = None,
        pids: str = None,
        product: str = None,
        prom_ql: str = None,
        region_id: str = None,
        tags: List[CreateOrUpdateAlertRuleRequestTags] = None,
    ):
        # The alert check type of the Prometheus alert rule. Valid values:
        # 
        # *   STATIC: a static threshold value. If you set the parameter to STATIC, you must specify the **MetricsKey** parameter. For more information, see the **Correspondence between AlertGroup and MetricsKey for Prometheus Service** table.
        # *   CUSTOM: a custom PromQL statement. If you set the parameter to CUSTOM, you must specify the **PromQL**, **Duration**, and **Message** parameters to create a Prometheus alert rule.
        self.alert_check_type = alert_check_type
        # The alert contact group ID of the Prometheus alert rule. Valid values:
        # 
        # *   \\-1: custom PromQL
        # *   1: Kubernetes load
        # *   15: Kubernetes node
        self.alert_group = alert_group
        # The ID of the alert rule.
        # 
        # *   If you do not specify this parameter, a new alert rule is created.
        # *   If you specify this parameter, the specified alert rule is modified.
        self.alert_id = alert_id
        # The name of the alert rule.
        # 
        # This parameter is required.
        self.alert_name = alert_name
        # The configuration of the alert sending channel. This parameter is used to be compatible with the old version of the rule.
        self.alert_piplines = alert_piplines
        # The content of the Application Monitoring or Browser Monitoring alert rule. The following code provides an example of the **AlertRuleContent** parameter. For more information about the meaning of each field, see the supplementary description.
        # 
        # ```json
        # { 
        #     "Condition": "OR",
        #      "AlertRuleItems": [
        #              { "Operator": "CURRENT_LTE",
        #                  "MetricKey": "appstat.jvm.threadcount",
        #                  "Value": 1000,
        #                  "Aggregate": "AVG",
        #                   "N": 10,
        #                   "Tolerability": 169
        #             } 
        #        ]  
        #   }
        # ```
        # 
        # >  The filter conditions specified by the **AlertRuleItems.MetricKey** field depends on the value of the **MetricsType** parameter. For more information about the types of metrics supported by Application Monitoring and Browser Monitoring and the alert rule fields corresponding to each metric, see the supplementary description.
        self.alert_rule_content = alert_rule_content
        # The status of the alert rule. Valid values:
        # 
        # *   RUNNING (default)
        # *   STOPPED
        self.alert_status = alert_status
        # The type of the alert rule. Valid values:
        # 
        # *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
        # *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
        # *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Managed Service for Prometheus
        # *   XTRACE_MONITORING_ALERT_RULE: alert rule for Managed Service for OpenTelemetry
        # *   EBPF_MONITORING_ALERT_RULE: alert rule for Application Monitoring eBPF Edition
        # *   RUM_MONITORING_ALERT_RULE: alert rule for Real User Monitoring
        # 
        # This parameter is required.
        self.alert_type = alert_type
        # The annotations of the Prometheus alert rule.
        self.annotations = annotations
        # Specifies whether to apply the alert rule to new applications that are created in Application Monitoring or Browser Monitoring. Valid values:
        # 
        # *   `true`: enables the health check feature.
        # *   `false`: disables the automatic backup feature.
        self.auto_add_new_application = auto_add_new_application
        # The configurations that are automatically appended to monitor the application based on the specified alert rule.
        # 
        # *   autoAddMatchType:
        # 
        #     the matching mode. Valid values: REGULAR and NOT_REGULAR.
        # 
        # *   autoAddMatchExp: the regular expression
        self.auto_add_target_config = auto_add_target_config
        # The ID of the monitored cluster.
        self.cluster_id = cluster_id
        # Data Configuration. The dataRevision field specifies the data repair method when there is no data for the metric.
        # 
        # - Fill with zero: 0
        # - Fill with one: 1
        # - Fill with null: 2 (default, does not trigger an alarm)
        self.data_config = data_config
        # The duration of the Prometheus alert rule, in minutes, in the range of [0,1440].
        self.duration = duration
        # The filter conditions of the Application Monitoring or Browser Monitoring alert rule. Format:
        # 
        #     "DimFilters": [ 
        #     { 
        #      "FilterOpt": "ALL",
        #     "FilterValues": [],         //The value of the filter condition.
        #     "FilterKey": "rootIp"     //The key of the filter condition.
        #     }
        #     ]
        # 
        # Valid values of **FilterOpt**:
        # 
        # *   STATIC: matches the value of the specified dimension.
        # *   ALL: traverses all dimension values. Dynamic thresholds do not support traversal.
        # *   DISABLE: aggregates the values of all dimensions.
        self.filters = filters
        # The tags of the Prometheus alert rule.
        self.labels = labels
        # The severity level of the Prometheus alert rule.
        # 
        # *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
        # *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
        # *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
        # *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
        # *   Default: Alert notifications are sent regardless of alert levels.
        self.level = level
        # Application Tags. Used for application monitoring alert rules, to filter applications associated with alert rules.
        self.mark_tags = mark_tags
        # The alert message of the Prometheus alert rule.
        self.message = message
        # The alert metrics. If you set the **AlertCheckType** parameter to **STATIC** when you create a Prometheus alert rule, you must specify the **MetricsKey** parameter.
        # 
        # > Alert metrics vary depending on the value of the **AlertGroup** parameter. For more information about the correspondence between **AlertGroup** and **MetricsKey**, see the supplementary description.
        self.metrics_key = metrics_key
        # The metric type of the Application Monitoring or Browser Monitoring alert rule. For more information, see the following table.
        self.metrics_type = metrics_type
        # The effective time and notification time. This parameter is used to be compatible with the old version of the rule.
        self.notice = notice
        # The notification mode. You can specify the normal mode or simple mode.
        # 
        # *   DIRECTED_MODE
        # *   NORMAL_MODE
        self.notify_mode = notify_mode
        # The notification policy.
        # 
        # *   If you set this parameter to null, no notification policy is specified. After you create an alert rule, you can create a notification policy and specify match rules and match conditions. For example, you can specify the name of the alert rule as the match condition. When the alert rule is triggered, an alert event is generated and an alert notification is sent to the contacts or contact groups that are specified in the notification policy.
        # *   To specify a notification policy, set this parameter to the ID of the notification policy. Application Real-Time Monitoring Service (ARMS) automatically adds a match rule to the notification policy and specifies the ID of the alert rule as the match condition. The name of the alert rule is also displayed. This way, the alert events that are generated based on the alert rule can be matched by the specified notification policy.
        self.notify_strategy = notify_strategy
        # The process ID (PID) that is associated with the Application Monitoring or Browser Monitoring alert rule.
        self.pids = pids
        # The product code. If you specify this parameter when you create a Prometheus alert rule, the backend checks whether the product exists.
        self.product = product
        # The PromQL statement of the Prometheus alert rule.
        self.prom_ql = prom_ql
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The list of tags.
        self.tags = tags

    def validate(self):
        if self.mark_tags:
            for k in self.mark_tags:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_check_type is not None:
            result['AlertCheckType'] = self.alert_check_type
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.alert_piplines is not None:
            result['AlertPiplines'] = self.alert_piplines
        if self.alert_rule_content is not None:
            result['AlertRuleContent'] = self.alert_rule_content
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.auto_add_new_application is not None:
            result['AutoAddNewApplication'] = self.auto_add_new_application
        if self.auto_add_target_config is not None:
            result['AutoAddTargetConfig'] = self.auto_add_target_config
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.data_config is not None:
            result['DataConfig'] = self.data_config
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.filters is not None:
            result['Filters'] = self.filters
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.level is not None:
            result['Level'] = self.level
        result['MarkTags'] = []
        if self.mark_tags is not None:
            for k in self.mark_tags:
                result['MarkTags'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.metrics_key is not None:
            result['MetricsKey'] = self.metrics_key
        if self.metrics_type is not None:
            result['MetricsType'] = self.metrics_type
        if self.notice is not None:
            result['Notice'] = self.notice
        if self.notify_mode is not None:
            result['NotifyMode'] = self.notify_mode
        if self.notify_strategy is not None:
            result['NotifyStrategy'] = self.notify_strategy
        if self.pids is not None:
            result['Pids'] = self.pids
        if self.product is not None:
            result['Product'] = self.product
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertCheckType') is not None:
            self.alert_check_type = m.get('AlertCheckType')
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('AlertPiplines') is not None:
            self.alert_piplines = m.get('AlertPiplines')
        if m.get('AlertRuleContent') is not None:
            self.alert_rule_content = m.get('AlertRuleContent')
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('AutoAddNewApplication') is not None:
            self.auto_add_new_application = m.get('AutoAddNewApplication')
        if m.get('AutoAddTargetConfig') is not None:
            self.auto_add_target_config = m.get('AutoAddTargetConfig')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DataConfig') is not None:
            self.data_config = m.get('DataConfig')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Filters') is not None:
            self.filters = m.get('Filters')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        self.mark_tags = []
        if m.get('MarkTags') is not None:
            for k in m.get('MarkTags'):
                temp_model = CreateOrUpdateAlertRuleRequestMarkTags()
                self.mark_tags.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MetricsKey') is not None:
            self.metrics_key = m.get('MetricsKey')
        if m.get('MetricsType') is not None:
            self.metrics_type = m.get('MetricsType')
        if m.get('Notice') is not None:
            self.notice = m.get('Notice')
        if m.get('NotifyMode') is not None:
            self.notify_mode = m.get('NotifyMode')
        if m.get('NotifyStrategy') is not None:
            self.notify_strategy = m.get('NotifyStrategy')
        if m.get('Pids') is not None:
            self.pids = m.get('Pids')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateOrUpdateAlertRuleRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems(TeaModel):
    def __init__(
        self,
        aggregate: str = None,
        metric_key: str = None,
        n: float = None,
        operator: str = None,
        value: str = None,
    ):
        # The aggregation method of the alert condition. Valid values:
        # 
        # *   AVG: calculates the average value
        # *   SUM: calculates the total value
        # *   MAX: selects the maximum value
        # *   MIN: selects the minimum value
        self.aggregate = aggregate
        # The metric of the alert condition.
        self.metric_key = metric_key
        # Indicates the last N minutes.
        self.n = n
        # The comparison operator that was used to compare the metric value with the threshold. Valid values:
        # 
        # *   CURRENT_GTE: greater than or equal to
        # *   CURRENT_LTE: less than or equal to
        # *   PREVIOUS_UP: the increase percentage compared with the last period
        # *   PREVIOUS_DOWN: the decrease percentage compared with the last period
        # *   HOH_UP: the increase percentage compared with the last hour
        # *   HOH_DOWN: the decrease percentage compared with the last hour
        # *   DOD_UP: the increase percentage compared with the last day
        # *   DOD_DOWN: the decrease percentage compared with the last day
        self.operator = operator
        # The threshold of the alert condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['Aggregate'] = self.aggregate
        if self.metric_key is not None:
            result['MetricKey'] = self.metric_key
        if self.n is not None:
            result['N'] = self.n
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Aggregate') is not None:
            self.aggregate = m.get('Aggregate')
        if m.get('MetricKey') is not None:
            self.metric_key = m.get('MetricKey')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent(TeaModel):
    def __init__(
        self,
        alert_rule_items: List[CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems] = None,
        condition: str = None,
    ):
        # The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.
        self.alert_rule_items = alert_rule_items
        # The relationship between multiple alert conditions that were specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:
        # 
        # *   OR: meets any of the specified conditions.
        # *   AND: meets all the specified conditions.
        self.condition = condition

    def validate(self):
        if self.alert_rule_items:
            for k in self.alert_rule_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertRuleItems'] = []
        if self.alert_rule_items is not None:
            for k in self.alert_rule_items:
                result['AlertRuleItems'].append(k.to_map() if k else None)
        if self.condition is not None:
            result['Condition'] = self.condition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_rule_items = []
        if m.get('AlertRuleItems') is not None:
            for k in m.get('AlertRuleItems'):
                temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems()
                self.alert_rule_items.append(temp_model.from_map(k))
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The key of the annotation.
        self.name = name
        # The value of the annotation.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        opt: str = None,
        show: bool = None,
        t: str = None,
        value: str = None,
    ):
        # The key of the filter condition.
        self.key = key
        # The logical operator of the filter condition. Valid values:
        # 
        # *   \\=: equal to
        # *   not: not equal to
        self.opt = opt
        # Indicates whether this filter condition was displayed on the frontend.
        self.show = show
        # The log type of Browser Monitoring. This field was not included in other filter conditions.
        self.t = t
        # The value of the filter condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.opt is not None:
            result['Opt'] = self.opt
        if self.show is not None:
            result['Show'] = self.show
        if self.t is not None:
            result['T'] = self.t
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Opt') is not None:
            self.opt = m.get('Opt')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        if m.get('T') is not None:
            self.t = m.get('T')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters(TeaModel):
    def __init__(
        self,
        filter_key: str = None,
        filter_opt: str = None,
        filter_values: List[str] = None,
    ):
        # The key of the filter condition.
        self.filter_key = filter_key
        # The logical operator of the filter condition.
        self.filter_opt = filter_opt
        # The details of the filter condition.
        self.filter_values = filter_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_key is not None:
            result['FilterKey'] = self.filter_key
        if self.filter_opt is not None:
            result['FilterOpt'] = self.filter_opt
        if self.filter_values is not None:
            result['FilterValues'] = self.filter_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilterKey') is not None:
            self.filter_key = m.get('FilterKey')
        if m.get('FilterOpt') is not None:
            self.filter_opt = m.get('FilterOpt')
        if m.get('FilterValues') is not None:
            self.filter_values = m.get('FilterValues')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters(TeaModel):
    def __init__(
        self,
        custom_slsfilters: List[CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters] = None,
        custom_slsgroup_by_dimensions: List[str] = None,
        custom_slswheres: List[str] = None,
        dim_filters: List[CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters] = None,
    ):
        # The custom filter condition of the Browser Monitoring alert rule.
        self.custom_slsfilters = custom_slsfilters
        # The information of the aggregation dimension.
        self.custom_slsgroup_by_dimensions = custom_slsgroup_by_dimensions
        # The details of the custom filter condition.
        self.custom_slswheres = custom_slswheres
        # The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.
        self.dim_filters = dim_filters

    def validate(self):
        if self.custom_slsfilters:
            for k in self.custom_slsfilters:
                if k:
                    k.validate()
        if self.dim_filters:
            for k in self.dim_filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomSLSFilters'] = []
        if self.custom_slsfilters is not None:
            for k in self.custom_slsfilters:
                result['CustomSLSFilters'].append(k.to_map() if k else None)
        if self.custom_slsgroup_by_dimensions is not None:
            result['CustomSLSGroupByDimensions'] = self.custom_slsgroup_by_dimensions
        if self.custom_slswheres is not None:
            result['CustomSLSWheres'] = self.custom_slswheres
        result['DimFilters'] = []
        if self.dim_filters is not None:
            for k in self.dim_filters:
                result['DimFilters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_slsfilters = []
        if m.get('CustomSLSFilters') is not None:
            for k in m.get('CustomSLSFilters'):
                temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters()
                self.custom_slsfilters.append(temp_model.from_map(k))
        if m.get('CustomSLSGroupByDimensions') is not None:
            self.custom_slsgroup_by_dimensions = m.get('CustomSLSGroupByDimensions')
        if m.get('CustomSLSWheres') is not None:
            self.custom_slswheres = m.get('CustomSLSWheres')
        self.dim_filters = []
        if m.get('DimFilters') is not None:
            for k in m.get('DimFilters'):
                temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters()
                self.dim_filters.append(temp_model.from_map(k))
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The tag key.
        self.name = name
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRuleTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateAlertRuleResponseBodyAlertRule(TeaModel):
    def __init__(
        self,
        alert_check_type: str = None,
        alert_group: int = None,
        alert_id: int = None,
        alert_name: str = None,
        alert_rule_content: CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent = None,
        alert_status: str = None,
        alert_type: str = None,
        annotations: List[CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations] = None,
        auto_add_new_application: bool = None,
        cluster_id: str = None,
        created_time: int = None,
        duration: str = None,
        extend: str = None,
        filters: CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters = None,
        labels: List[CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels] = None,
        level: str = None,
        message: str = None,
        metrics_type: str = None,
        notify_mode: str = None,
        notify_strategy: str = None,
        pids: List[str] = None,
        prom_ql: str = None,
        region_id: str = None,
        tags: List[CreateOrUpdateAlertRuleResponseBodyAlertRuleTags] = None,
        updated_time: int = None,
        user_id: str = None,
    ):
        # The alert check type of the Prometheus alert rule. Valid values:
        # 
        # *   STATIC: a static threshold value.
        # *   CUSTOM: a custom PromQL statement.
        self.alert_check_type = alert_check_type
        # The alert contact group ID of the Prometheus alert rule. Valid values:
        # 
        # *   \\-1: custom PromQL
        # *   1: Kubernetes load
        # *   15: Kubernetes node
        self.alert_group = alert_group
        # The alert rule ID.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The content of the Application Monitoring or Browser Monitoring alert rule.
        self.alert_rule_content = alert_rule_content
        # The status of the alert rule. Valid values:
        # 
        # *   RUNNING
        # *   STOPPED
        # *   PAUSED
        # 
        # > The PAUSED status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.
        self.alert_status = alert_status
        # The type of the alert rule. Valid values:
        # 
        # *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
        # *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
        # *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service
        self.alert_type = alert_type
        # The annotations of the Prometheus alert rule.
        self.annotations = annotations
        # Indicates whether the alert rule was applied to new applications that were created in Application Monitoring or Browser Monitoring. Valid values:
        # 
        # *   `true`: enables the health check feature.
        # *   `false`: disables the automatic backup feature.
        self.auto_add_new_application = auto_add_new_application
        # The ID of the monitored cluster.
        self.cluster_id = cluster_id
        # The timestamp generated when the alert rule was created. Unit: seconds.
        self.created_time = created_time
        # The duration of the Prometheus alert rule. Unit: minutes.
        self.duration = duration
        # The extended fields.
        self.extend = extend
        # The filter conditions of the Application Monitoring or Browser Monitoring alert rule.
        self.filters = filters
        # The tags of the Prometheus alert rule.
        self.labels = labels
        # The severity level of the Prometheus alert rule.
        # 
        # *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
        # *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
        # *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
        # *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
        # *   Default: Alert notifications are sent regardless of alert levels.
        self.level = level
        # The alert message of the Prometheus alert rule.
        self.message = message
        # The metric type of the Application Monitoring or Browser Monitoring alert rule.
        self.metrics_type = metrics_type
        # Notification Mode.
        self.notify_mode = notify_mode
        # The name of the notification policy.
        self.notify_strategy = notify_strategy
        # The process ID (PID) that was associated with the Application Monitoring or Browser Monitoring alert rule.
        self.pids = pids
        # The PromQL statement of the Prometheus alert rule.
        self.prom_ql = prom_ql
        # The region ID.
        self.region_id = region_id
        # The list of tags.
        self.tags = tags
        # The timestamp generated when the alert rule was updated. Unit: seconds.
        self.updated_time = updated_time
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id

    def validate(self):
        if self.alert_rule_content:
            self.alert_rule_content.validate()
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.filters:
            self.filters.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_check_type is not None:
            result['AlertCheckType'] = self.alert_check_type
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.alert_rule_content is not None:
            result['AlertRuleContent'] = self.alert_rule_content.to_map()
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.auto_add_new_application is not None:
            result['AutoAddNewApplication'] = self.auto_add_new_application
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.filters is not None:
            result['Filters'] = self.filters.to_map()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.metrics_type is not None:
            result['MetricsType'] = self.metrics_type
        if self.notify_mode is not None:
            result['NotifyMode'] = self.notify_mode
        if self.notify_strategy is not None:
            result['NotifyStrategy'] = self.notify_strategy
        if self.pids is not None:
            result['Pids'] = self.pids
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertCheckType') is not None:
            self.alert_check_type = m.get('AlertCheckType')
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('AlertRuleContent') is not None:
            temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent()
            self.alert_rule_content = temp_model.from_map(m['AlertRuleContent'])
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('AutoAddNewApplication') is not None:
            self.auto_add_new_application = m.get('AutoAddNewApplication')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('Filters') is not None:
            temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters()
            self.filters = temp_model.from_map(m['Filters'])
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MetricsType') is not None:
            self.metrics_type = m.get('MetricsType')
        if m.get('NotifyMode') is not None:
            self.notify_mode = m.get('NotifyMode')
        if m.get('NotifyStrategy') is not None:
            self.notify_strategy = m.get('NotifyStrategy')
        if m.get('Pids') is not None:
            self.pids = m.get('Pids')
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRuleTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class CreateOrUpdateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        alert_rule: CreateOrUpdateAlertRuleResponseBodyAlertRule = None,
        request_id: str = None,
    ):
        # The details of the alert rule.
        self.alert_rule = alert_rule
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_rule:
            self.alert_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule is not None:
            result['AlertRule'] = self.alert_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertRule') is not None:
            temp_model = CreateOrUpdateAlertRuleResponseBodyAlertRule()
            self.alert_rule = temp_model.from_map(m['AlertRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateContactRequest(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
        contact_name: str = None,
        corp_user_id: str = None,
        ding_robot_url: str = None,
        email: str = None,
        is_email_verify: bool = None,
        phone: str = None,
        reissue_send_notice: int = None,
        resource_group_id: str = None,
    ):
        # The ID of the alert contact.
        # 
        # *   If you do not specify this parameter, a new alert contact is created.
        # *   If you specify this parameter, the specified alert contact is modified.
        self.contact_id = contact_id
        # The name of the alert contact.
        # 
        # This parameter is required.
        self.contact_name = contact_name
        # The ID of the alert contact that is shown to the enterprise when the contact is mentioned with the at sign (@) by a third-party instant messaging (IM) tool.
        self.corp_user_id = corp_user_id
        # The webhook URL of the DingTalk chatbot.
        self.ding_robot_url = ding_robot_url
        # The email address of the alert contact.
        # 
        # > You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.
        self.email = email
        # Specifies whether the email address is verified.
        self.is_email_verify = is_email_verify
        # The mobile number of the alert contact.
        # 
        # > You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.
        self.phone = phone
        # The operation that you want to perform if phone calls fail to be answered. Valid values:
        # 
        # *   0: No operation is performed.
        # *   1: A phone call is made again.
        # *   2: A text message is sent.
        # *   3 (default value): The global default value is used.
        self.reissue_send_notice = reissue_send_notice
        # The resource group ID.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.corp_user_id is not None:
            result['CorpUserId'] = self.corp_user_id
        if self.ding_robot_url is not None:
            result['DingRobotUrl'] = self.ding_robot_url
        if self.email is not None:
            result['Email'] = self.email
        if self.is_email_verify is not None:
            result['IsEmailVerify'] = self.is_email_verify
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.reissue_send_notice is not None:
            result['ReissueSendNotice'] = self.reissue_send_notice
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('CorpUserId') is not None:
            self.corp_user_id = m.get('CorpUserId')
        if m.get('DingRobotUrl') is not None:
            self.ding_robot_url = m.get('DingRobotUrl')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('IsEmailVerify') is not None:
            self.is_email_verify = m.get('IsEmailVerify')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('ReissueSendNotice') is not None:
            self.reissue_send_notice = m.get('ReissueSendNotice')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class CreateOrUpdateContactResponseBodyAlertContact(TeaModel):
    def __init__(
        self,
        contact_id: float = None,
        contact_name: str = None,
        ding_robot_url: str = None,
        email: str = None,
        is_verify: bool = None,
        phone: str = None,
        reissue_send_notice: int = None,
        is_email_verify: bool = None,
    ):
        # The ID of the alert contact.
        self.contact_id = contact_id
        # The name of the alert contact.
        self.contact_name = contact_name
        # The webhook URL of the DingTalk chatbot.
        self.ding_robot_url = ding_robot_url
        # The email address of the alert contact.
        self.email = email
        # Indicates whether the mobile number was verified. Valid values:
        # 
        # *   `false` (default value): No
        # *   `true`: Yes
        # 
        # You can call the **SendTTSVerifyLink** operation to verify the mobile number of an alert contact. Only verified mobile numbers can be specified in a notification policy to receive phone calls.
        self.is_verify = is_verify
        # The mobile number of the alert contact.
        self.phone = phone
        # The operation that you want to perform if phone calls fail to be answered. Valid values: 0: No operation is performed. 1: A phone call is made again. 2: A text message is sent. 3 (default value): The global default value is used.
        self.reissue_send_notice = reissue_send_notice
        # Indicates whether the email address was verified.
        self.is_email_verify = is_email_verify

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.ding_robot_url is not None:
            result['DingRobotUrl'] = self.ding_robot_url
        if self.email is not None:
            result['Email'] = self.email
        if self.is_verify is not None:
            result['IsVerify'] = self.is_verify
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.reissue_send_notice is not None:
            result['ReissueSendNotice'] = self.reissue_send_notice
        if self.is_email_verify is not None:
            result['isEmailVerify'] = self.is_email_verify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('DingRobotUrl') is not None:
            self.ding_robot_url = m.get('DingRobotUrl')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('IsVerify') is not None:
            self.is_verify = m.get('IsVerify')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('ReissueSendNotice') is not None:
            self.reissue_send_notice = m.get('ReissueSendNotice')
        if m.get('isEmailVerify') is not None:
            self.is_email_verify = m.get('isEmailVerify')
        return self


class CreateOrUpdateContactResponseBody(TeaModel):
    def __init__(
        self,
        alert_contact: CreateOrUpdateContactResponseBodyAlertContact = None,
        request_id: str = None,
    ):
        # The object of the alert contact.
        self.alert_contact = alert_contact
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_contact:
            self.alert_contact.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_contact is not None:
            result['AlertContact'] = self.alert_contact.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertContact') is not None:
            temp_model = CreateOrUpdateContactResponseBodyAlertContact()
            self.alert_contact = temp_model.from_map(m['AlertContact'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_id: int = None,
        contact_group_name: str = None,
        contact_ids: str = None,
    ):
        # The ID of the alert contact group.
        # 
        # *   If you do not specify this parameter, an alert contact group is created.
        # *   If you specify this parameter, the specified alert contact group is modified.
        self.contact_group_id = contact_group_id
        # The name of the alert contact group.
        # 
        # This parameter is required.
        self.contact_group_name = contact_group_name
        # The ID of the contact that you want to add to the contact group. Separate multiple IDs with commas (,).
        self.contact_ids = contact_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        return self


class CreateOrUpdateContactGroupResponseBodyAlertContactGroup(TeaModel):
    def __init__(
        self,
        contact_group_id: float = None,
        contact_group_name: str = None,
        contact_ids: str = None,
    ):
        # The ID of the alert contact group.
        self.contact_group_id = contact_group_id
        # The name of the alert contact group.
        self.contact_group_name = contact_group_name
        # The IDs of the contacts that are included in the alert contact group.
        self.contact_ids = contact_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        return self


class CreateOrUpdateContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        alert_contact_group: CreateOrUpdateContactGroupResponseBodyAlertContactGroup = None,
        request_id: str = None,
    ):
        # The information about the alert contact group.
        self.alert_contact_group = alert_contact_group
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_contact_group:
            self.alert_contact_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_contact_group is not None:
            result['AlertContactGroup'] = self.alert_contact_group.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertContactGroup') is not None:
            temp_model = CreateOrUpdateContactGroupResponseBodyAlertContactGroup()
            self.alert_contact_group = temp_model.from_map(m['AlertContactGroup'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateEventBridgeIntegrationRequest(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        access_secret: str = None,
        description: str = None,
        endpoint: str = None,
        event_bus_name: str = None,
        event_bus_region_id: str = None,
        id: int = None,
        name: str = None,
        source: str = None,
    ):
        # The AccessKey ID that is used to connect to EventBridge.
        self.access_key = access_key
        # The AccessKey secret that is used to connect to EventBridge.
        self.access_secret = access_secret
        # The description of the EventBridge integration.
        self.description = description
        # The public endpoint of EventBridge.
        self.endpoint = endpoint
        # The name of the event bus.
        self.event_bus_name = event_bus_name
        # The region ID of the event bus.
        self.event_bus_region_id = event_bus_region_id
        # The ID of the EventBridge integration.
        # 
        # *   If you do not specify this parameter, an EventBridge integration is created.
        # *   If you specify this parameter, the specified EventBridge integration is modified.
        self.id = id
        # The name of the EventBridge integration.
        # 
        # This parameter is required.
        self.name = name
        # The event source.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.access_secret is not None:
            result['AccessSecret'] = self.access_secret
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.event_bus_name is not None:
            result['EventBusName'] = self.event_bus_name
        if self.event_bus_region_id is not None:
            result['EventBusRegionId'] = self.event_bus_region_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('AccessSecret') is not None:
            self.access_secret = m.get('AccessSecret')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('EventBusName') is not None:
            self.event_bus_name = m.get('EventBusName')
        if m.get('EventBusRegionId') is not None:
            self.event_bus_region_id = m.get('EventBusRegionId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        access_secret: str = None,
        description: str = None,
        endpoint: str = None,
        event_bus_name: str = None,
        event_bus_region_id: str = None,
        id: int = None,
        name: str = None,
        source: str = None,
    ):
        # The AccessKey ID that is used to connect to EventBridge.
        self.access_key = access_key
        # The AccessKey secret that is used to connect to EventBridge.
        self.access_secret = access_secret
        # The description of the EventBridge integration.
        self.description = description
        # The public endpoint of EventBridge.
        self.endpoint = endpoint
        # The name of the event bus.
        self.event_bus_name = event_bus_name
        # The region ID of the event bus.
        self.event_bus_region_id = event_bus_region_id
        # The ID of the EventBridge integration.
        self.id = id
        # The name of the EventBridge integration.
        self.name = name
        # The event source.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.access_secret is not None:
            result['AccessSecret'] = self.access_secret
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.event_bus_name is not None:
            result['EventBusName'] = self.event_bus_name
        if self.event_bus_region_id is not None:
            result['EventBusRegionId'] = self.event_bus_region_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('AccessSecret') is not None:
            self.access_secret = m.get('AccessSecret')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('EventBusName') is not None:
            self.event_bus_name = m.get('EventBusName')
        if m.get('EventBusRegionId') is not None:
            self.event_bus_region_id = m.get('EventBusRegionId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class CreateOrUpdateEventBridgeIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        event_bridge_integration: CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration = None,
        request_id: str = None,
    ):
        # The information about the EventBridge integration.
        self.event_bridge_integration = event_bridge_integration
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.event_bridge_integration:
            self.event_bridge_integration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_bridge_integration is not None:
            result['EventBridgeIntegration'] = self.event_bridge_integration.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventBridgeIntegration') is not None:
            temp_model = CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration()
            self.event_bridge_integration = temp_model.from_map(m['EventBridgeIntegration'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateEventBridgeIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateEventBridgeIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateEventBridgeIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateIMRobotRequest(TeaModel):
    def __init__(
        self,
        card_template: str = None,
        daily_noc: bool = None,
        daily_noc_time: str = None,
        ding_sign_key: str = None,
        enable_outgoing: bool = None,
        robot_address: str = None,
        robot_id: int = None,
        robot_name: str = None,
        token: str = None,
        type: str = None,
    ):
        # The configurations of the alert card template. For more information about the parameters in the template, see the following section.
        self.card_template = card_template
        # Specifies whether to send daily statistics. Valid values:
        # 
        # *   `false` (default): Daily statistics are not sent.
        # *   `true`: Daily statistics are sent. If you set the value to `true`, the **DailyNocTime** parameter is required.
        self.daily_noc = daily_noc
        # The points in time at which the daily statistics are sent. Separate multiple points in time with commas (,). The points in time are in the HH:SS format. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
        self.daily_noc_time = daily_noc_time
        # The signature key of DingTalk. If you specify a signature key, DingTalk authentication is performed by using the signature key. If you do not specify a signature key, a whitelist is used for authentication by default. The keyword of the whitelist is **Alert**.
        self.ding_sign_key = ding_sign_key
        # Specifies whether to enable the Outgoing feature.
        self.enable_outgoing = enable_outgoing
        # The webhook URL of the IM chatbot.
        # 
        # This parameter is required.
        self.robot_address = robot_address
        # The ID of the IM chatbot.
        # > If you do not specify the parameter, a new IM chatbot is created.
        self.robot_id = robot_id
        # The name of the IM chatbot.
        # 
        # This parameter is required.
        self.robot_name = robot_name
        # The token required to enable the Outgoing feature.
        self.token = token
        # The type of the IM chatbot. Valid values:
        # 
        # *   `dingding`: DingTalk chatbot
        # *   `wechat`: WeCom chatbot
        # *   `feishu`: Lark chatbot
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_template is not None:
            result['CardTemplate'] = self.card_template
        if self.daily_noc is not None:
            result['DailyNoc'] = self.daily_noc
        if self.daily_noc_time is not None:
            result['DailyNocTime'] = self.daily_noc_time
        if self.ding_sign_key is not None:
            result['DingSignKey'] = self.ding_sign_key
        if self.enable_outgoing is not None:
            result['EnableOutgoing'] = self.enable_outgoing
        if self.robot_address is not None:
            result['RobotAddress'] = self.robot_address
        if self.robot_id is not None:
            result['RobotId'] = self.robot_id
        if self.robot_name is not None:
            result['RobotName'] = self.robot_name
        if self.token is not None:
            result['Token'] = self.token
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CardTemplate') is not None:
            self.card_template = m.get('CardTemplate')
        if m.get('DailyNoc') is not None:
            self.daily_noc = m.get('DailyNoc')
        if m.get('DailyNocTime') is not None:
            self.daily_noc_time = m.get('DailyNocTime')
        if m.get('DingSignKey') is not None:
            self.ding_sign_key = m.get('DingSignKey')
        if m.get('EnableOutgoing') is not None:
            self.enable_outgoing = m.get('EnableOutgoing')
        if m.get('RobotAddress') is not None:
            self.robot_address = m.get('RobotAddress')
        if m.get('RobotId') is not None:
            self.robot_id = m.get('RobotId')
        if m.get('RobotName') is not None:
            self.robot_name = m.get('RobotName')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateOrUpdateIMRobotResponseBodyAlertRobot(TeaModel):
    def __init__(
        self,
        card_template: str = None,
        daily_noc: bool = None,
        daily_noc_time: str = None,
        enable_outgoing: bool = None,
        robot_address: str = None,
        robot_id: float = None,
        robot_name: str = None,
        token: str = None,
        type: str = None,
    ):
        # The configurations of the alert card template.
        self.card_template = card_template
        # Indicates whether daily statistics are sent. Valid values:
        # 
        # *   `false` (default): Daily statistics are not sent.
        # *   `true`: Daily statistics are sent.
        self.daily_noc = daily_noc
        # The point in time at which the daily statistics are sent. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
        self.daily_noc_time = daily_noc_time
        # Indicates whether the Outgoing feature is enabled.
        self.enable_outgoing = enable_outgoing
        # The webhook URL of the IM chatbot.
        self.robot_address = robot_address
        # The ID of the IM chatbot.
        self.robot_id = robot_id
        # The name of the IM chatbot.
        self.robot_name = robot_name
        # The token required to enable the Outgoing feature.
        self.token = token
        # The type of the IM chatbot. Valid values:
        # 
        # *   `dingding`: DingTalk chatbot
        # *   `wechat`: WeCom chatbot
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.card_template is not None:
            result['CardTemplate'] = self.card_template
        if self.daily_noc is not None:
            result['DailyNoc'] = self.daily_noc
        if self.daily_noc_time is not None:
            result['DailyNocTime'] = self.daily_noc_time
        if self.enable_outgoing is not None:
            result['EnableOutgoing'] = self.enable_outgoing
        if self.robot_address is not None:
            result['RobotAddress'] = self.robot_address
        if self.robot_id is not None:
            result['RobotId'] = self.robot_id
        if self.robot_name is not None:
            result['RobotName'] = self.robot_name
        if self.token is not None:
            result['Token'] = self.token
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CardTemplate') is not None:
            self.card_template = m.get('CardTemplate')
        if m.get('DailyNoc') is not None:
            self.daily_noc = m.get('DailyNoc')
        if m.get('DailyNocTime') is not None:
            self.daily_noc_time = m.get('DailyNocTime')
        if m.get('EnableOutgoing') is not None:
            self.enable_outgoing = m.get('EnableOutgoing')
        if m.get('RobotAddress') is not None:
            self.robot_address = m.get('RobotAddress')
        if m.get('RobotId') is not None:
            self.robot_id = m.get('RobotId')
        if m.get('RobotName') is not None:
            self.robot_name = m.get('RobotName')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateOrUpdateIMRobotResponseBody(TeaModel):
    def __init__(
        self,
        alert_robot: CreateOrUpdateIMRobotResponseBodyAlertRobot = None,
        request_id: str = None,
    ):
        # The information about the IM chatbot.
        self.alert_robot = alert_robot
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.alert_robot:
            self.alert_robot.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_robot is not None:
            result['AlertRobot'] = self.alert_robot.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertRobot') is not None:
            temp_model = CreateOrUpdateIMRobotResponseBodyAlertRobot()
            self.alert_robot = temp_model.from_map(m['AlertRobot'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateIMRobotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateIMRobotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateIMRobotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateNotificationPolicyRequest(TeaModel):
    def __init__(
        self,
        directed_mode: bool = None,
        escalation_policy_id: int = None,
        group_rule: str = None,
        id: int = None,
        integration_id: int = None,
        matching_rules: str = None,
        name: str = None,
        notify_rule: str = None,
        notify_template: str = None,
        region_id: str = None,
        repeat: bool = None,
        repeat_interval: int = None,
        send_recover_message: bool = None,
        state: str = None,
    ):
        # Specifies whether to enable simple mode.
        self.directed_mode = directed_mode
        # The ID of the escalation policy.
        self.escalation_policy_id = escalation_policy_id
        # An array of alert event group objects.
        # 
        # *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
        # *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
        # 
        # Sample statement:
        # 
        #     { 
        #     "groupWait":5,    // The waiting time for grouping. 
        #     "groupInterval":30,     // The time interval of grouping. 
        #     "groupingFields":["alertname"]       // The field that is used to group alert events. 
        #     }
        self.group_rule = group_rule
        # The ID of the notification policy.
        # 
        # *   If you do not specify this parameter, a new notification policy is created.
        # *   If you specify this parameter, the specified notification policy is modified.
        self.id = id
        # The integration ID of the ticket system to which alerts are pushed.
        self.integration_id = integration_id
        # The matching rules. Format:
        # 
        #     [
        #      {
        #      "matchingConditions": [
        #      { 
        #      "value": "test",    // The value of the matching condition. 
        #      "key": "alertname",     // The key of the matching condition. 
        #      "operator": "eq"   // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).   
        #      }
        #      ]
        #      } 
        #      ]
        self.matching_rules = matching_rules
        # The name of the notification policy.
        # 
        # This parameter is required.
        self.name = name
        # An array of notification rule objects. Format:
        # 
        #     { 
        #      "notifyStartTime":"00:00",      // The start time of the notification window. 
        #      "notifyEndTime":"23:59",       // The end time of the notification window. 
        #      "notifyChannels":["dingTalk", "email", "sms", "tts", "webhook"],       // The notification methods. Valid values: dingTalk, email, sms, tts, and webhook. 
        #      "notifyObjects":[{       // An array of notification objects. 
        #      "notifyObjectType":"CONTACT",       // The type of the notification object. Valid values: CONTACT (contact), CONTACT_GROUP (contact group), ARMS_CONTACT (ARMS contact), ARMS_CONTACT_GROUP (ARMS contact group), DING_ROBOT_GROUP (DingTalk, Lark, WeCom, or IM robot), and CONTACT_SCHEDULE (user on duty defined by a schedule). 
        #      "notifyObjectId":123,       // The ID of the notification object. 
        #      "notifyObjectName":"test"       // The name of the notification object. 
        #      }]
        # 
        # This parameter is required.
        self.notify_rule = notify_rule
        # The notification template. The default notification template is provided below the table.
        self.notify_template = notify_template
        # The ID of the region.
        self.region_id = region_id
        # Specifies whether to resend a notification for a long-lasting unresolved alert. Default value: true. Valid values:
        # 
        # *   `true`: If you set this parameter to `true`, you must set **RepeatInterval**.
        # *   `false`: If you set this parameter to `false`, you must set **EscalationPolicyId**.
        self.repeat = repeat
        # The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
        self.repeat_interval = repeat_interval
        # Specifies whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. ARMS notifies contacts when the alert status changes to Resolved.
        # 
        # *   `true`: The system sends a notification.
        # *   `false`: The system does not send a notification.
        self.send_recover_message = send_recover_message
        # Specifies whether to enable the notification policy. Valid values: enable and disable.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directed_mode is not None:
            result['DirectedMode'] = self.directed_mode
        if self.escalation_policy_id is not None:
            result['EscalationPolicyId'] = self.escalation_policy_id
        if self.group_rule is not None:
            result['GroupRule'] = self.group_rule
        if self.id is not None:
            result['Id'] = self.id
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        if self.matching_rules is not None:
            result['MatchingRules'] = self.matching_rules
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_rule is not None:
            result['NotifyRule'] = self.notify_rule
        if self.notify_template is not None:
            result['NotifyTemplate'] = self.notify_template
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat is not None:
            result['Repeat'] = self.repeat
        if self.repeat_interval is not None:
            result['RepeatInterval'] = self.repeat_interval
        if self.send_recover_message is not None:
            result['SendRecoverMessage'] = self.send_recover_message
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DirectedMode') is not None:
            self.directed_mode = m.get('DirectedMode')
        if m.get('EscalationPolicyId') is not None:
            self.escalation_policy_id = m.get('EscalationPolicyId')
        if m.get('GroupRule') is not None:
            self.group_rule = m.get('GroupRule')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        if m.get('MatchingRules') is not None:
            self.matching_rules = m.get('MatchingRules')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyRule') is not None:
            self.notify_rule = m.get('NotifyRule')
        if m.get('NotifyTemplate') is not None:
            self.notify_template = m.get('NotifyTemplate')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Repeat') is not None:
            self.repeat = m.get('Repeat')
        if m.get('RepeatInterval') is not None:
            self.repeat_interval = m.get('RepeatInterval')
        if m.get('SendRecoverMessage') is not None:
            self.send_recover_message = m.get('SendRecoverMessage')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule(TeaModel):
    def __init__(
        self,
        group_interval: int = None,
        group_wait: int = None,
        grouping_fields: List[str] = None,
    ):
        # The time interval of grouping. Unit: seconds. Default value: 30.
        self.group_interval = group_interval
        # The waiting time for grouping. Unit: seconds. Default value: 5.
        self.group_wait = group_wait
        # An array of alert event group objects.
        # 
        # *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
        # *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
        self.grouping_fields = grouping_fields

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_interval is not None:
            result['GroupInterval'] = self.group_interval
        if self.group_wait is not None:
            result['GroupWait'] = self.group_wait
        if self.grouping_fields is not None:
            result['GroupingFields'] = self.grouping_fields
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupInterval') is not None:
            self.group_interval = m.get('GroupInterval')
        if m.get('GroupWait') is not None:
            self.group_wait = m.get('GroupWait')
        if m.get('GroupingFields') is not None:
            self.grouping_fields = m.get('GroupingFields')
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The key of the matching condition.
        self.key = key
        # The logical operator of the matching condition. Valid values:
        # 
        # *   `eq`: equal to
        # *   `neq`: not equal to
        # *   `in`: contains
        # *   `nin`: does not contain
        # *   `re`: regular expression match
        # *   `nre`: regular expression mismatch
        self.operator = operator
        # The value of the matching condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules(TeaModel):
    def __init__(
        self,
        matching_conditions: List[CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions] = None,
    ):
        # The matching conditions.
        self.matching_conditions = matching_conditions

    def validate(self):
        if self.matching_conditions:
            for k in self.matching_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MatchingConditions'] = []
        if self.matching_conditions is not None:
            for k in self.matching_conditions:
                result['MatchingConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.matching_conditions = []
        if m.get('MatchingConditions') is not None:
            for k in m.get('MatchingConditions'):
                temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions()
                self.matching_conditions.append(temp_model.from_map(k))
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects(TeaModel):
    def __init__(
        self,
        notify_channels: List[str] = None,
        notify_object_id: int = None,
        notify_object_name: str = None,
        notify_object_type: str = None,
    ):
        # The notification methods specified for a contact.
        self.notify_channels = notify_channels
        # The ID of the notification object.
        self.notify_object_id = notify_object_id
        # The name of the notification object.
        self.notify_object_name = notify_object_name
        # The type of the notification object. Valid values:
        # 
        # *   CONTACT: contact
        # *   CONTACT_GROUP: contact group
        # *   ARMS_CONTACT: ARMS contact
        # *   ARMS_CONTACT_GROUP: ARMS contact group
        # *   DING_ROBOT_GROUP: DingTalk, Lark, WeCom, or IM robot
        # *   CONTACT_SCHEDULE: user on duty defined by a schedule
        self.notify_object_type = notify_object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_channels is not None:
            result['NotifyChannels'] = self.notify_channels
        if self.notify_object_id is not None:
            result['NotifyObjectId'] = self.notify_object_id
        if self.notify_object_name is not None:
            result['NotifyObjectName'] = self.notify_object_name
        if self.notify_object_type is not None:
            result['NotifyObjectType'] = self.notify_object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotifyChannels') is not None:
            self.notify_channels = m.get('NotifyChannels')
        if m.get('NotifyObjectId') is not None:
            self.notify_object_id = m.get('NotifyObjectId')
        if m.get('NotifyObjectName') is not None:
            self.notify_object_name = m.get('NotifyObjectName')
        if m.get('NotifyObjectType') is not None:
            self.notify_object_type = m.get('NotifyObjectType')
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule(TeaModel):
    def __init__(
        self,
        notify_channels: List[str] = None,
        notify_end_time: str = None,
        notify_objects: List[CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects] = None,
        notify_start_time: str = None,
    ):
        # The notification method.
        self.notify_channels = notify_channels
        # The end time of the notification window.
        self.notify_end_time = notify_end_time
        # An array of notification objects.
        self.notify_objects = notify_objects
        # The start time of the notification window.
        self.notify_start_time = notify_start_time

    def validate(self):
        if self.notify_objects:
            for k in self.notify_objects:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_channels is not None:
            result['NotifyChannels'] = self.notify_channels
        if self.notify_end_time is not None:
            result['NotifyEndTime'] = self.notify_end_time
        result['NotifyObjects'] = []
        if self.notify_objects is not None:
            for k in self.notify_objects:
                result['NotifyObjects'].append(k.to_map() if k else None)
        if self.notify_start_time is not None:
            result['NotifyStartTime'] = self.notify_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotifyChannels') is not None:
            self.notify_channels = m.get('NotifyChannels')
        if m.get('NotifyEndTime') is not None:
            self.notify_end_time = m.get('NotifyEndTime')
        self.notify_objects = []
        if m.get('NotifyObjects') is not None:
            for k in m.get('NotifyObjects'):
                temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects()
                self.notify_objects.append(temp_model.from_map(k))
        if m.get('NotifyStartTime') is not None:
            self.notify_start_time = m.get('NotifyStartTime')
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate(TeaModel):
    def __init__(
        self,
        email_content: str = None,
        email_recover_content: str = None,
        email_recover_title: str = None,
        email_title: str = None,
        robot_content: str = None,
        sms_content: str = None,
        sms_recover_content: str = None,
        tts_content: str = None,
        tts_recover_content: str = None,
    ):
        # The content of the alert notification sent through email.
        self.email_content = email_content
        # The content of the alert resolution notification sent through email.
        self.email_recover_content = email_recover_content
        # The title of the alert resolution notification sent through email.
        self.email_recover_title = email_recover_title
        # The title of the alert notification sent through email.
        self.email_title = email_title
        # The content of the alert notification sent by the IM robot.
        self.robot_content = robot_content
        # The content of the alert notification sent through text message.
        self.sms_content = sms_content
        # The content of the alert resolution notification sent through text message.
        self.sms_recover_content = sms_recover_content
        # The content of the alert notification by phone.
        self.tts_content = tts_content
        # The content of the alert resolution notification by phone.
        self.tts_recover_content = tts_recover_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email_content is not None:
            result['EmailContent'] = self.email_content
        if self.email_recover_content is not None:
            result['EmailRecoverContent'] = self.email_recover_content
        if self.email_recover_title is not None:
            result['EmailRecoverTitle'] = self.email_recover_title
        if self.email_title is not None:
            result['EmailTitle'] = self.email_title
        if self.robot_content is not None:
            result['RobotContent'] = self.robot_content
        if self.sms_content is not None:
            result['SmsContent'] = self.sms_content
        if self.sms_recover_content is not None:
            result['SmsRecoverContent'] = self.sms_recover_content
        if self.tts_content is not None:
            result['TtsContent'] = self.tts_content
        if self.tts_recover_content is not None:
            result['TtsRecoverContent'] = self.tts_recover_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EmailContent') is not None:
            self.email_content = m.get('EmailContent')
        if m.get('EmailRecoverContent') is not None:
            self.email_recover_content = m.get('EmailRecoverContent')
        if m.get('EmailRecoverTitle') is not None:
            self.email_recover_title = m.get('EmailRecoverTitle')
        if m.get('EmailTitle') is not None:
            self.email_title = m.get('EmailTitle')
        if m.get('RobotContent') is not None:
            self.robot_content = m.get('RobotContent')
        if m.get('SmsContent') is not None:
            self.sms_content = m.get('SmsContent')
        if m.get('SmsRecoverContent') is not None:
            self.sms_recover_content = m.get('SmsRecoverContent')
        if m.get('TtsContent') is not None:
            self.tts_content = m.get('TtsContent')
        if m.get('TtsRecoverContent') is not None:
            self.tts_recover_content = m.get('TtsRecoverContent')
        return self


class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy(TeaModel):
    def __init__(
        self,
        directed_mode: bool = None,
        escalation_policy_id: int = None,
        group_rule: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule = None,
        id: int = None,
        integration_id: int = None,
        matching_rules: List[CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules] = None,
        name: str = None,
        notify_rule: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule = None,
        notify_template: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate = None,
        repeat: bool = None,
        repeat_interval: int = None,
        send_recover_message: bool = None,
        state: str = None,
    ):
        # Specifies whether to enable simple mode.
        self.directed_mode = directed_mode
        # The ID of the escalation policy.
        self.escalation_policy_id = escalation_policy_id
        # An array of alert event group objects.
        self.group_rule = group_rule
        # The ID of the notification policy.
        self.id = id
        # The integration ID of the ticket system to which alerts are pushed.
        self.integration_id = integration_id
        # The matching rules.
        self.matching_rules = matching_rules
        # The name of the notification policy.
        self.name = name
        # An array of notification rule objects.
        self.notify_rule = notify_rule
        # The notification template.
        self.notify_template = notify_template
        # Indicates whether a notification is resent for a long-lasting unresolved alert. Default value: true. Valid values:
        # 
        # *   `true`: The system resends a notification for a long-lasting unresolved alert at a specified time interval.
        # *   `false`: The system sends a notification for a long-lasting unresolved alert based on an escalation policy.
        self.repeat = repeat
        # The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
        self.repeat_interval = repeat_interval
        # Indicates whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. ARMS notifies contacts when the alert status changes to Resolved.
        # 
        # *   `true`: The system sends a notification.
        # *   `false`: The system does not send a notification.
        self.send_recover_message = send_recover_message
        # Indicates whether the notification policy is enabled. Valid values: enable and disable.
        self.state = state

    def validate(self):
        if self.group_rule:
            self.group_rule.validate()
        if self.matching_rules:
            for k in self.matching_rules:
                if k:
                    k.validate()
        if self.notify_rule:
            self.notify_rule.validate()
        if self.notify_template:
            self.notify_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directed_mode is not None:
            result['DirectedMode'] = self.directed_mode
        if self.escalation_policy_id is not None:
            result['EscalationPolicyId'] = self.escalation_policy_id
        if self.group_rule is not None:
            result['GroupRule'] = self.group_rule.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        result['MatchingRules'] = []
        if self.matching_rules is not None:
            for k in self.matching_rules:
                result['MatchingRules'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_rule is not None:
            result['NotifyRule'] = self.notify_rule.to_map()
        if self.notify_template is not None:
            result['NotifyTemplate'] = self.notify_template.to_map()
        if self.repeat is not None:
            result['Repeat'] = self.repeat
        if self.repeat_interval is not None:
            result['RepeatInterval'] = self.repeat_interval
        if self.send_recover_message is not None:
            result['SendRecoverMessage'] = self.send_recover_message
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DirectedMode') is not None:
            self.directed_mode = m.get('DirectedMode')
        if m.get('EscalationPolicyId') is not None:
            self.escalation_policy_id = m.get('EscalationPolicyId')
        if m.get('GroupRule') is not None:
            temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule()
            self.group_rule = temp_model.from_map(m['GroupRule'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        self.matching_rules = []
        if m.get('MatchingRules') is not None:
            for k in m.get('MatchingRules'):
                temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules()
                self.matching_rules.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyRule') is not None:
            temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule()
            self.notify_rule = temp_model.from_map(m['NotifyRule'])
        if m.get('NotifyTemplate') is not None:
            temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate()
            self.notify_template = temp_model.from_map(m['NotifyTemplate'])
        if m.get('Repeat') is not None:
            self.repeat = m.get('Repeat')
        if m.get('RepeatInterval') is not None:
            self.repeat_interval = m.get('RepeatInterval')
        if m.get('SendRecoverMessage') is not None:
            self.send_recover_message = m.get('SendRecoverMessage')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class CreateOrUpdateNotificationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        notification_policy: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy = None,
        request_id: str = None,
    ):
        # An array of notification policy objects.
        self.notification_policy = notification_policy
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.notification_policy:
            self.notification_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notification_policy is not None:
            result['NotificationPolicy'] = self.notification_policy.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotificationPolicy') is not None:
            temp_model = CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy()
            self.notification_policy = temp_model.from_map(m['NotificationPolicy'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateOrUpdateNotificationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateNotificationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateNotificationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateSilencePolicyRequest(TeaModel):
    def __init__(
        self,
        effective_time_type: str = None,
        id: int = None,
        matching_rules: str = None,
        name: str = None,
        region_id: str = None,
        state: str = None,
        time_period: str = None,
        time_slots: str = None,
    ):
        # The effective duration of the silence policy. Valid values: PERMANENT, CUSTOM_TIME, and CYCLE_EFFECT.
        self.effective_time_type = effective_time_type
        # The ID of the silence policy.
        # 
        # *   If you do not configure this parameter, a new silence policy is created.
        # *   If you configure this parameter, the specified silence policy is modified.
        self.id = id
        # The matching rules. The following code shows the format of matching rules:
        # 
        #     [
        #          {
        #     	 "matchingConditions": [
        #     	 {
        #     	 "value": "test", // The value of the matching condition. 
        #     	 "key": "altertname", // The key of the matching condition. 
        #     	 "operator": "eq" // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).   
        #     	 }
        #     	 ]
        #          }
        #     	 ]
        self.matching_rules = matching_rules
        # The name of the silence policy.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the region.
        self.region_id = region_id
        # Specifies whether to enable the silence policy. Valid values: enable and disable.
        self.state = state
        # The recurring period. This parameter is required when EffectiveTimeType is set to CYCLE_EFFECT. DAY: The silence policy is effective by day. WEEK: The silence policy is effective by week.
        self.time_period = time_period
        # The time period during which the silence policy is effective. If you set EffectiveTimeType to CUSTOM_TIME, specify a custom time period in the following format: [{"startTime":"2024-08-04 22:13","endTime":"2024-08-04 22:21"}] If you set EffectiveTimeType to CYCLE_EFFECT and TimePeriod to DAY, specify a custom time period in the following format: [{"startTime":"22:13","endTime":"22:21"}]. The start time cannot be later than the end time. If you set EffectiveTimeType to CYCLE_EFFECT and TimePeriod to WEEK, specify a custom time period in the following format: [{"startWeek":"1", "endWeek":"2" "startTime":"22:13","endTime":"22:21"}]. Valid values of startWeek and endWeek: 1 to 7. The start time cannot be later than the end time.
        self.time_slots = time_slots

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effective_time_type is not None:
            result['EffectiveTimeType'] = self.effective_time_type
        if self.id is not None:
            result['Id'] = self.id
        if self.matching_rules is not None:
            result['MatchingRules'] = self.matching_rules
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.state is not None:
            result['State'] = self.state
        if self.time_period is not None:
            result['TimePeriod'] = self.time_period
        if self.time_slots is not None:
            result['TimeSlots'] = self.time_slots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EffectiveTimeType') is not None:
            self.effective_time_type = m.get('EffectiveTimeType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchingRules') is not None:
            self.matching_rules = m.get('MatchingRules')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TimePeriod') is not None:
            self.time_period = m.get('TimePeriod')
        if m.get('TimeSlots') is not None:
            self.time_slots = m.get('TimeSlots')
        return self


class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The key of the matching condition.
        self.key = key
        # The logical operator of the matching condition. Valid values:
        # 
        # *   `eq`: equal to
        # *   `neq`: not equal to
        # *   `in`: contains
        # *   `nin`: does not contain
        # *   `re`: regular expression match
        # *   `nre`: regular expression mismatch
        self.operator = operator
        # The value of the matching condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules(TeaModel):
    def __init__(
        self,
        matching_conditions: List[CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions] = None,
    ):
        # A list of matching conditions.
        self.matching_conditions = matching_conditions

    def validate(self):
        if self.matching_conditions:
            for k in self.matching_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MatchingConditions'] = []
        if self.matching_conditions is not None:
            for k in self.matching_conditions:
                result['MatchingConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.matching_conditions = []
        if m.get('MatchingConditions') is not None:
            for k in m.get('MatchingConditions'):
                temp_model = CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions()
                self.matching_conditions.append(temp_model.from_map(k))
        return self


class CreateOrUpdateSilencePolicyResponseBodySilencePolicy(TeaModel):
    def __init__(
        self,
        effective_time_type: str = None,
        id: int = None,
        matching_rules: List[CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules] = None,
        name: str = None,
        state: str = None,
        time_period: str = None,
        time_slots: str = None,
    ):
        self.effective_time_type = effective_time_type
        # The ID of the silence policy.
        self.id = id
        # A list of matching rules.
        self.matching_rules = matching_rules
        # The name of the silence policy.
        self.name = name
        # Specifies whether to enable the silence policy. Valid values: enable and disable.
        self.state = state
        self.time_period = time_period
        self.time_slots = time_slots

    def validate(self):
        if self.matching_rules:
            for k in self.matching_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effective_time_type is not None:
            result['EffectiveTimeType'] = self.effective_time_type
        if self.id is not None:
            result['Id'] = self.id
        result['MatchingRules'] = []
        if self.matching_rules is not None:
            for k in self.matching_rules:
                result['MatchingRules'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.time_period is not None:
            result['TimePeriod'] = self.time_period
        if self.time_slots is not None:
            result['TimeSlots'] = self.time_slots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EffectiveTimeType') is not None:
            self.effective_time_type = m.get('EffectiveTimeType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.matching_rules = []
        if m.get('MatchingRules') is not None:
            for k in m.get('MatchingRules'):
                temp_model = CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules()
                self.matching_rules.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TimePeriod') is not None:
            self.time_period = m.get('TimePeriod')
        if m.get('TimeSlots') is not None:
            self.time_slots = m.get('TimeSlots')
        return self


class CreateOrUpdateSilencePolicyResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        silence_policy: CreateOrUpdateSilencePolicyResponseBodySilencePolicy = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # A list of silence policies.
        self.silence_policy = silence_policy

    def validate(self):
        if self.silence_policy:
            self.silence_policy.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.silence_policy is not None:
            result['SilencePolicy'] = self.silence_policy.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SilencePolicy') is not None:
            temp_model = CreateOrUpdateSilencePolicyResponseBodySilencePolicy()
            self.silence_policy = temp_model.from_map(m['SilencePolicy'])
        return self


class CreateOrUpdateSilencePolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateSilencePolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateSilencePolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOrUpdateWebhookContactRequest(TeaModel):
    def __init__(
        self,
        biz_headers: str = None,
        biz_params: str = None,
        body: str = None,
        method: str = None,
        recover_body: str = None,
        url: str = None,
        webhook_id: int = None,
        webhook_name: str = None,
    ):
        # The HTTP request headers.
        self.biz_headers = biz_headers
        # The parameters in the HTTP request.
        self.biz_params = biz_params
        # The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the `$content` placeholder to specify the notification content. The content cannot exceed 500 characters in length. For more information, see [Variable description of a notification template](https://help.aliyun.com/document_detail/251834.html).\\\\
        self.body = body
        # The HTTP request method.
        # 
        # *   Post
        # *   Get
        # 
        # This parameter is required.
        self.method = method
        # The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the `$content` placeholder to specify the notification content. The content cannot exceed 500 characters in length. For more information, see [Variable description of a notification template](https://help.aliyun.com/document_detail/251834.html).
        self.recover_body = recover_body
        # The URL of the HTTP request **method**.
        # 
        # This parameter is required.
        self.url = url
        # The ID of the webhook alert contact.
        # 
        # *   If you do not specify this parameter, a new webhook alert contact is created.
        # * If you specify this parameter, the specified webhook alert contact is modified.
        self.webhook_id = webhook_id
        # The name of the webhook alert contact.
        # 
        # This parameter is required.
        self.webhook_name = webhook_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_headers is not None:
            result['BizHeaders'] = self.biz_headers
        if self.biz_params is not None:
            result['BizParams'] = self.biz_params
        if self.body is not None:
            result['Body'] = self.body
        if self.method is not None:
            result['Method'] = self.method
        if self.recover_body is not None:
            result['RecoverBody'] = self.recover_body
        if self.url is not None:
            result['Url'] = self.url
        if self.webhook_id is not None:
            result['WebhookId'] = self.webhook_id
        if self.webhook_name is not None:
            result['WebhookName'] = self.webhook_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizHeaders') is not None:
            self.biz_headers = m.get('BizHeaders')
        if m.get('BizParams') is not None:
            self.biz_params = m.get('BizParams')
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('RecoverBody') is not None:
            self.recover_body = m.get('RecoverBody')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('WebhookId') is not None:
            self.webhook_id = m.get('WebhookId')
        if m.get('WebhookName') is not None:
            self.webhook_name = m.get('WebhookName')
        return self


class CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook(TeaModel):
    def __init__(
        self,
        biz_headers: str = None,
        biz_params: str = None,
        body: str = None,
        method: str = None,
        recover_body: str = None,
        url: str = None,
    ):
        # The HTTP request headers.
        self.biz_headers = biz_headers
        # The parameters in the HTTP request.
        self.biz_params = biz_params
        # The alert notification template.
        self.body = body
        # The HTTP request method.
        # 
        # *   Post
        # *   Get
        self.method = method
        # The notification template for clearing alerts.
        self.recover_body = recover_body
        # The URL of the request method.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_headers is not None:
            result['BizHeaders'] = self.biz_headers
        if self.biz_params is not None:
            result['BizParams'] = self.biz_params
        if self.body is not None:
            result['Body'] = self.body
        if self.method is not None:
            result['Method'] = self.method
        if self.recover_body is not None:
            result['RecoverBody'] = self.recover_body
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizHeaders') is not None:
            self.biz_headers = m.get('BizHeaders')
        if m.get('BizParams') is not None:
            self.biz_params = m.get('BizParams')
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('RecoverBody') is not None:
            self.recover_body = m.get('RecoverBody')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateOrUpdateWebhookContactResponseBodyWebhookContact(TeaModel):
    def __init__(
        self,
        webhook: CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook = None,
        webhook_id: float = None,
        webhook_name: str = None,
    ):
        # The information about the webhook alert contact.
        self.webhook = webhook
        # The ID of the webhook alert contact.
        self.webhook_id = webhook_id
        # The name of the webhook alert contact.
        self.webhook_name = webhook_name

    def validate(self):
        if self.webhook:
            self.webhook.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.webhook is not None:
            result['Webhook'] = self.webhook.to_map()
        if self.webhook_id is not None:
            result['WebhookId'] = self.webhook_id
        if self.webhook_name is not None:
            result['WebhookName'] = self.webhook_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Webhook') is not None:
            temp_model = CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook()
            self.webhook = temp_model.from_map(m['Webhook'])
        if m.get('WebhookId') is not None:
            self.webhook_id = m.get('WebhookId')
        if m.get('WebhookName') is not None:
            self.webhook_name = m.get('WebhookName')
        return self


class CreateOrUpdateWebhookContactResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        webhook_contact: CreateOrUpdateWebhookContactResponseBodyWebhookContact = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The returned webhook alert contact.
        self.webhook_contact = webhook_contact

    def validate(self):
        if self.webhook_contact:
            self.webhook_contact.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.webhook_contact is not None:
            result['WebhookContact'] = self.webhook_contact.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('WebhookContact') is not None:
            temp_model = CreateOrUpdateWebhookContactResponseBodyWebhookContact()
            self.webhook_contact = temp_model.from_map(m['WebhookContact'])
        return self


class CreateOrUpdateWebhookContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOrUpdateWebhookContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOrUpdateWebhookContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePrometheusAlertRuleRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreatePrometheusAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_name: str = None,
        annotations: str = None,
        cluster_id: str = None,
        dispatch_rule_id: int = None,
        duration: str = None,
        expression: str = None,
        labels: str = None,
        message: str = None,
        notify_type: str = None,
        region_id: str = None,
        tags: List[CreatePrometheusAlertRuleRequestTags] = None,
        type: str = None,
    ):
        # The name of the alert rule.
        # 
        # This parameter is required.
        self.alert_name = alert_name
        # The annotations that are described in a JSON string. You must specify the name and value of each annotation.
        self.annotations = annotations
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the notification policy. This parameter is required if the NotifyType parameter is set to `DISPATCH_RULE`.
        self.dispatch_rule_id = dispatch_rule_id
        # The duration. The value ranges from 1 to 1440 minutes.
        # 
        # This parameter is required.
        self.duration = duration
        # The expression of the alert rule. The expression must follow the PromQL syntax.
        # 
        # This parameter is required.
        self.expression = expression
        # The tags that are described in a JSON string. You must specify the name and value of each tag.
        self.labels = labels
        # The content of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.
        # 
        # This parameter is required.
        self.message = message
        # The method that is used to send alert notifications. Valid values:
        # 
        # - `ALERT_MANAGER`: Alert notifications are sent by Operation Center. This is the default value.
        # - `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.
        self.notify_type = notify_type
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The tags.
        self.tags = tags
        # The type of the alert rule. Valid values:
        # 
        # - 99: custom alert
        # - 101: Prometheus Service alert
        self.type = type

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreatePrometheusAlertRuleRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the annotation.
        self.name = name
        # The value of the annotation.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the tag.
        self.name = name
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_name: str = None,
        annotations: List[CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations] = None,
        cluster_id: str = None,
        dispatch_rule_id: int = None,
        duration: str = None,
        expression: str = None,
        labels: List[CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels] = None,
        message: str = None,
        notify_type: str = None,
        status: int = None,
        type: str = None,
    ):
        # The ID of the alert rule.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The annotations of the alert rule.
        self.annotations = annotations
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The ID of the notification policy.
        self.dispatch_rule_id = dispatch_rule_id
        # The duration. The value ranges from 1 to 1440 minutes.
        self.duration = duration
        # The expression of the alert rule.
        self.expression = expression
        # The tags of the alert rule.
        self.labels = labels
        # The content of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.
        self.message = message
        # The method that is used to send alert notifications. Valid values:
        # 
        # - ALERT_MANAGER: Alert notifications are sent by Operation Center.
        # - DISPATCH_RULE: Alert notifications are sent based on the specified notification policy.
        self.notify_type = notify_type
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # - `1`: The alert rule is enabled.
        # - `0`: The alert rule is disabled.
        self.status = status
        # The type of the alert rule.
        self.type = type

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePrometheusAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        prometheus_alert_rule: CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.message = message
        # The returned struct.
        self.prometheus_alert_rule = prometheus_alert_rule
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.prometheus_alert_rule:
            self.prometheus_alert_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.prometheus_alert_rule is not None:
            result['PrometheusAlertRule'] = self.prometheus_alert_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PrometheusAlertRule') is not None:
            temp_model = CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule()
            self.prometheus_alert_rule = temp_model.from_map(m['PrometheusAlertRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreatePrometheusAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePrometheusAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePrometheusAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePrometheusInstanceRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreatePrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        all_sub_clusters_success: bool = None,
        archive_duration: int = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        duration: int = None,
        grafana_instance_id: str = None,
        payment_type: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        sub_clusters_json: str = None,
        tags: List[CreatePrometheusInstanceRequestTags] = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # Does it require all child instances to be verified successfully before creating a GlobalView instance. The default is false, which means partial success is possible.
        self.all_sub_clusters_success = all_sub_clusters_success
        # The number of days for which data is automatically archived after the storage expires. Valid values: 60, 90, 180, and 365. 0 indicates that the data is not archived.
        self.archive_duration = archive_duration
        # The ID of the ACK cluster. This parameter is required if you set the ClusterType parameter to aliyun-cs.
        self.cluster_id = cluster_id
        # The name of the created cluster. This parameter is required if you set the ClusterType parameter to remote-write or ecs.
        self.cluster_name = cluster_name
        # The type of the Prometheus instance. Valid values:
        # 
        # *   remote-write: Prometheus instance for Remote Write
        # *   ecs (unavailable): Prometheus instance for ECS
        # *   global-view: Prometheus instance for GlobalView
        # *   aliyun-cs: Prometheus instance for Container Service
        # *   cloud-product (unavailable): Prometheus instance for Alibaba Cloud services
        # *   cloud-monitor (unavailable): Prometheus instance for Hybrid Cloud Monitoring
        # *   flink (unavailable): Prometheus instance for Flink
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The data storage duration. Unit: days.
        self.duration = duration
        # The ID of the Grafana dedicated instance. This parameter is available if you set the ClusterType parameter to ecs.
        self.grafana_instance_id = grafana_instance_id
        # The billing mode. Valid values: POSTPAY: charges fees based on the amount of reported metric data. POSTPAY_GB: charges fees based on the amount of written metric data. Empty value: The user-defined default billing mode is used. If no such a billing mode is available, you are charged based on the amount of reported metric data.
        self.payment_type = payment_type
        # The ID of the region. If you use a Prometheus instance to monitor an Alibaba Cloud service in China, this parameter must be set to cn-shanghai.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the custom resource group. You can configure this parameter to bind the instance to the resource group.
        self.resource_group_id = resource_group_id
        # The ID of the security group. This parameter is required if you set the ClusterType parameter to ecs.
        self.security_group_id = security_group_id
        # JSON string for child instances of the globalView instance.
        self.sub_clusters_json = sub_clusters_json
        # The tags of the instance. You can configure this parameter to manage tags for the instance.
        self.tags = tags
        # The ID of the vSwitch. This parameter is required if you set the ClusterType parameter to ecs.
        self.v_switch_id = v_switch_id
        # The ID of virtual private cloud (VPC). This parameter is required if you set the ClusterType parameter to ecs.
        self.vpc_id = vpc_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_sub_clusters_success is not None:
            result['AllSubClustersSuccess'] = self.all_sub_clusters_success
        if self.archive_duration is not None:
            result['ArchiveDuration'] = self.archive_duration
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.grafana_instance_id is not None:
            result['GrafanaInstanceId'] = self.grafana_instance_id
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.sub_clusters_json is not None:
            result['SubClustersJson'] = self.sub_clusters_json
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllSubClustersSuccess') is not None:
            self.all_sub_clusters_success = m.get('AllSubClustersSuccess')
        if m.get('ArchiveDuration') is not None:
            self.archive_duration = m.get('ArchiveDuration')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('GrafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('GrafanaInstanceId')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SubClustersJson') is not None:
            self.sub_clusters_json = m.get('SubClustersJson')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreatePrometheusInstanceRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreatePrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The ID of the created Prometheus instance.
        self.data = data
        # The message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePrometheusMonitoringRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        config_yaml: str = None,
        region_id: str = None,
        status: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The monitoring configuration. Specify a YAML string.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The status of the monitoring configuration. Valid values: run and stop. Default value: run. This parameter is not available if the Type parameter is set to Probe.
        self.status = status
        # The type of the monitoring configuration. 
        # Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
        # Valid values for a Prometheus instance for ECS: customJob and probe.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePrometheusMonitoringResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The name of the monitoring configuration that was added, or the exception information.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePrometheusMonitoringResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePrometheusMonitoringResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePrometheusMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRetcodeAppRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateRetcodeAppRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        retcode_app_name: str = None,
        retcode_app_type: str = None,
        tags: List[CreateRetcodeAppRequestTags] = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
        self.resource_group_id = resource_group_id
        # The name of the application.
        # 
        # This parameter is required.
        self.retcode_app_name = retcode_app_name
        # The type of the application. Valid values:
        # 
        # *   `web`: web application
        # *   `weex`: Weex mobile app
        # *   `mini_dd`: DingTalk mini program
        # *   `mini_alipay`: Alipay mini program
        # *   `mini_wx`: WeChat mini program
        # *   `mini_common`: mini program on other platforms
        # 
        # This parameter is required.
        self.retcode_app_type = retcode_app_type
        # The tags that you want to add to the task.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retcode_app_name is not None:
            result['RetcodeAppName'] = self.retcode_app_name
        if self.retcode_app_type is not None:
            result['RetcodeAppType'] = self.retcode_app_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetcodeAppName') is not None:
            self.retcode_app_name = m.get('RetcodeAppName')
        if m.get('RetcodeAppType') is not None:
            self.retcode_app_type = m.get('RetcodeAppType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateRetcodeAppRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags(TeaModel):
    def __init__(
        self,
        tags: List[CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags] = None,
    ):
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags()
                self.tags.append(temp_model.from_map(k))
        return self


class CreateRetcodeAppResponseBodyRetcodeAppDataBean(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        pid: str = None,
        resource_group_id: str = None,
        tags: CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The process identifier (PID) of the application.
        self.pid = pid
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags of the task.
        self.tags = tags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            temp_model = CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class CreateRetcodeAppResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        retcode_app_data_bean: CreateRetcodeAppResponseBodyRetcodeAppDataBean = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # The response parameters.
        self.data = data
        # The message returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # The information of the Browser Monitoring task.
        self.retcode_app_data_bean = retcode_app_data_bean
        # Indicates whether the call was successful. Valid values:
        # 
        # - true: The call was successful.
        # - false: The call failed.
        self.success = success

    def validate(self):
        if self.retcode_app_data_bean:
            self.retcode_app_data_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.retcode_app_data_bean is not None:
            result['RetcodeAppDataBean'] = self.retcode_app_data_bean.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetcodeAppDataBean') is not None:
            temp_model = CreateRetcodeAppResponseBodyRetcodeAppDataBean()
            self.retcode_app_data_bean = temp_model.from_map(m['RetcodeAppDataBean'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRetcodeAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRetcodeAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRetcodeAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRumAppRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateRumAppRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        app_name: str = None,
        description: str = None,
        nick_name: str = None,
        package_name: str = None,
        real_region_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        site_type: str = None,
        source: str = None,
        tag: List[CreateRumAppRequestTag] = None,
    ):
        # The name of the application group.
        self.app_group = app_group
        # The application name.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The description of the application.
        self.description = description
        # The nickname of the application.
        self.nick_name = nick_name
        # The name of the Android application package. This parameter is required if you create an Android application.
        self.package_name = package_name
        self.real_region_id = real_region_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The application type. Valid values: web, miniapp, ios, and android.
        # 
        # This parameter is required.
        self.site_type = site_type
        # The source. This is a reserved parameter.
        self.source = source
        # The list of tags. You can specify a maximum of 20 tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.description is not None:
            result['Description'] = self.description
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.package_name is not None:
            result['PackageName'] = self.package_name
        if self.real_region_id is not None:
            result['RealRegionId'] = self.real_region_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.site_type is not None:
            result['SiteType'] = self.site_type
        if self.source is not None:
            result['Source'] = self.source
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('PackageName') is not None:
            self.package_name = m.get('PackageName')
        if m.get('RealRegionId') is not None:
            self.real_region_id = m.get('RealRegionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SiteType') is not None:
            self.site_type = m.get('SiteType')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateRumAppRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateRumAppShrinkRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        app_name: str = None,
        description: str = None,
        nick_name: str = None,
        package_name: str = None,
        real_region_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        site_type: str = None,
        source: str = None,
        tag_shrink: str = None,
    ):
        # The name of the application group.
        self.app_group = app_group
        # The application name.
        # 
        # This parameter is required.
        self.app_name = app_name
        # The description of the application.
        self.description = description
        # The nickname of the application.
        self.nick_name = nick_name
        # The name of the Android application package. This parameter is required if you create an Android application.
        self.package_name = package_name
        self.real_region_id = real_region_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The application type. Valid values: web, miniapp, ios, and android.
        # 
        # This parameter is required.
        self.site_type = site_type
        # The source. This is a reserved parameter.
        self.source = source
        # The list of tags. You can specify a maximum of 20 tags.
        self.tag_shrink = tag_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.description is not None:
            result['Description'] = self.description
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.package_name is not None:
            result['PackageName'] = self.package_name
        if self.real_region_id is not None:
            result['RealRegionId'] = self.real_region_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.site_type is not None:
            result['SiteType'] = self.site_type
        if self.source is not None:
            result['Source'] = self.source
        if self.tag_shrink is not None:
            result['Tag'] = self.tag_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('PackageName') is not None:
            self.package_name = m.get('PackageName')
        if m.get('RealRegionId') is not None:
            self.real_region_id = m.get('RealRegionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SiteType') is not None:
            self.site_type = m.get('SiteType')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Tag') is not None:
            self.tag_shrink = m.get('Tag')
        return self


class CreateRumAppResponseBodyData(TeaModel):
    def __init__(
        self,
        cdn_domain: str = None,
        endpoint: str = None,
        pid: str = None,
    ):
        # The domain name of the SDK.
        self.cdn_domain = cdn_domain
        # The endpoint that is used to report application data.
        self.endpoint = endpoint
        # The process ID (PID) of the application.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cdn_domain is not None:
            result['CdnDomain'] = self.cdn_domain
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CdnDomain') is not None:
            self.cdn_domain = m.get('CdnDomain')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class CreateRumAppResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: CreateRumAppResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        resource_group_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
        self.code = code
        # The application ID and domain names. This parameter is returned if the application is created. Multiple domain names are separated with commas (,).
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateRumAppResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRumAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRumAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRumAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRumUploadFileUrlRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        content_type: str = None,
        file_name: str = None,
        pid: str = None,
        region_id: str = None,
        sourcemap_type: str = None,
        uuid: str = None,
        version_id: str = None,
    ):
        # The application name.
        self.app_name = app_name
        # The type of the file. You can set this parameter to "application/zip", "text/plain", or an empty string.
        self.content_type = content_type
        # The file name.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The process ID (PID) of the application.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The file type. Valid values: source-map: SourceMap files. mapping: symbol table files for Android. dsym: dSYM files for iOS.
        self.sourcemap_type = sourcemap_type
        # The file ID.
        self.uuid = uuid
        # The version number of the file.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sourcemap_type is not None:
            result['SourcemapType'] = self.sourcemap_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SourcemapType') is not None:
            self.sourcemap_type = m.get('SourcemapType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class CreateRumUploadFileUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response code. The status code 200 indicates that the request was successful.
        self.code = code
        # The file upload URL.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRumUploadFileUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRumUploadFileUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRumUploadFileUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSyntheticTaskRequestCommonParamAlertList(TeaModel):
    def __init__(
        self,
        is_critical: int = None,
        name: str = None,
        symbols: int = None,
    ):
        # Specifies whether the condition must be met.
        self.is_critical = is_critical
        # The name of the alert rule.
        # 
        # For network synthetic monitoring, use the following names:
        # 
        # *   Latency: PING_SET
        # *   Packet loss rate: PING_LOST_RATE
        # *   Hijacking: HIJACKPER
        self.name = name
        # Specifies how the condition is evaluated. Valid values:
        # 
        # *   1: greater than
        # *   0: less than
        self.symbols = symbols

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_critical is not None:
            result['IsCritical'] = self.is_critical
        if self.name is not None:
            result['Name'] = self.name
        if self.symbols is not None:
            result['Symbols'] = self.symbols
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsCritical') is not None:
            self.is_critical = m.get('IsCritical')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Symbols') is not None:
            self.symbols = m.get('Symbols')
        return self


class CreateSyntheticTaskRequestCommonParam(TeaModel):
    def __init__(
        self,
        alarm_flag: str = None,
        alert_list: List[CreateSyntheticTaskRequestCommonParamAlertList] = None,
        alert_notifier_id: str = None,
        alert_policy_id: str = None,
        monitor_samples: int = None,
        start_execution_time: int = None,
    ):
        # Specifies whether to create an alert rule.
        # 
        # *   1: creates an alert.
        # *   0: does not create an alert.
        self.alarm_flag = alarm_flag
        # The alert parameters.
        self.alert_list = alert_list
        # The ID of the alert recipient. Separate multiple recipients with commas (,).
        self.alert_notifier_id = alert_notifier_id
        # The ID of the notification policy.
        self.alert_policy_id = alert_policy_id
        # Specifies whether to evenly distribute monitoring samples. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.monitor_samples = monitor_samples
        # The time when execution starts.
        self.start_execution_time = start_execution_time

    def validate(self):
        if self.alert_list:
            for k in self.alert_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_flag is not None:
            result['AlarmFlag'] = self.alarm_flag
        result['AlertList'] = []
        if self.alert_list is not None:
            for k in self.alert_list:
                result['AlertList'].append(k.to_map() if k else None)
        if self.alert_notifier_id is not None:
            result['AlertNotifierId'] = self.alert_notifier_id
        if self.alert_policy_id is not None:
            result['AlertPolicyId'] = self.alert_policy_id
        if self.monitor_samples is not None:
            result['MonitorSamples'] = self.monitor_samples
        if self.start_execution_time is not None:
            result['StartExecutionTime'] = self.start_execution_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmFlag') is not None:
            self.alarm_flag = m.get('AlarmFlag')
        self.alert_list = []
        if m.get('AlertList') is not None:
            for k in m.get('AlertList'):
                temp_model = CreateSyntheticTaskRequestCommonParamAlertList()
                self.alert_list.append(temp_model.from_map(k))
        if m.get('AlertNotifierId') is not None:
            self.alert_notifier_id = m.get('AlertNotifierId')
        if m.get('AlertPolicyId') is not None:
            self.alert_policy_id = m.get('AlertPolicyId')
        if m.get('MonitorSamples') is not None:
            self.monitor_samples = m.get('MonitorSamples')
        if m.get('StartExecutionTime') is not None:
            self.start_execution_time = m.get('StartExecutionTime')
        return self


class CreateSyntheticTaskRequestDownload(TeaModel):
    def __init__(
        self,
        connection_timeout: float = None,
        download_custom_header_content: str = None,
        download_custom_host: int = None,
        download_custom_host_ip: str = None,
        download_ignore_certificate_error: str = None,
        download_kernel: int = None,
        download_redirection: int = None,
        download_transmission_size: int = None,
        monitor_timeout: int = None,
        quick_protocol: str = None,
        validate_keywords: str = None,
        verify_way: int = None,
        white_list: str = None,
    ):
        # The connection timeout period.
        self.connection_timeout = connection_timeout
        # The items to be ignored in a certificate error. Pass the values of the check boxes that are separated with vertical bars (|).
        self.download_custom_header_content = download_custom_header_content
        # The custom host mode.
        # 
        # *   1: round robin
        # *   0: random
        self.download_custom_host = download_custom_host
        # The custom host IP address. You can enter multiple IP addresses. Separate the IP addresses with commas (,).
        self.download_custom_host_ip = download_custom_host_ip
        # The items to be ignored in a certificate error. Pass the values of the check boxes that are separated with vertical bars (|).
        self.download_ignore_certificate_error = download_ignore_certificate_error
        # The kernel type.
        # 
        # *   1: curl
        # *   0: WinInet
        self.download_kernel = download_kernel
        # Specifies whether to support redirection.
        self.download_redirection = download_redirection
        # The size of the download file. Unit: KB.
        self.download_transmission_size = download_transmission_size
        # The monitoring duration.
        self.monitor_timeout = monitor_timeout
        # The QUIC protocol type.
        # 
        # *   1: http1
        # *   2: http2
        # *   3: http3
        self.quick_protocol = quick_protocol
        # The keyword that is used in verification.
        self.validate_keywords = validate_keywords
        # The verification method.
        # 
        # *   0: no verification
        # *   1: string verification
        # *   2: MD5 verification
        self.verify_way = verify_way
        # The whitelist for DNS hijacking.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_timeout is not None:
            result['ConnectionTimeout'] = self.connection_timeout
        if self.download_custom_header_content is not None:
            result['DownloadCustomHeaderContent'] = self.download_custom_header_content
        if self.download_custom_host is not None:
            result['DownloadCustomHost'] = self.download_custom_host
        if self.download_custom_host_ip is not None:
            result['DownloadCustomHostIp'] = self.download_custom_host_ip
        if self.download_ignore_certificate_error is not None:
            result['DownloadIgnoreCertificateError'] = self.download_ignore_certificate_error
        if self.download_kernel is not None:
            result['DownloadKernel'] = self.download_kernel
        if self.download_redirection is not None:
            result['DownloadRedirection'] = self.download_redirection
        if self.download_transmission_size is not None:
            result['DownloadTransmissionSize'] = self.download_transmission_size
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.quick_protocol is not None:
            result['QuickProtocol'] = self.quick_protocol
        if self.validate_keywords is not None:
            result['ValidateKeywords'] = self.validate_keywords
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionTimeout') is not None:
            self.connection_timeout = m.get('ConnectionTimeout')
        if m.get('DownloadCustomHeaderContent') is not None:
            self.download_custom_header_content = m.get('DownloadCustomHeaderContent')
        if m.get('DownloadCustomHost') is not None:
            self.download_custom_host = m.get('DownloadCustomHost')
        if m.get('DownloadCustomHostIp') is not None:
            self.download_custom_host_ip = m.get('DownloadCustomHostIp')
        if m.get('DownloadIgnoreCertificateError') is not None:
            self.download_ignore_certificate_error = m.get('DownloadIgnoreCertificateError')
        if m.get('DownloadKernel') is not None:
            self.download_kernel = m.get('DownloadKernel')
        if m.get('DownloadRedirection') is not None:
            self.download_redirection = m.get('DownloadRedirection')
        if m.get('DownloadTransmissionSize') is not None:
            self.download_transmission_size = m.get('DownloadTransmissionSize')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('QuickProtocol') is not None:
            self.quick_protocol = m.get('QuickProtocol')
        if m.get('ValidateKeywords') is not None:
            self.validate_keywords = m.get('ValidateKeywords')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateSyntheticTaskRequestExtendInterval(TeaModel):
    def __init__(
        self,
        days: List[int] = None,
        end_hour: int = None,
        end_minute: int = None,
        end_time: str = None,
        start_hour: int = None,
        start_minute: int = None,
        start_time: str = None,
    ):
        # The day on which synthetic monitoring is performed.
        self.days = days
        # The hour at which synthetic monitoring ends.
        self.end_hour = end_hour
        # The minute at which synthetic monitoring ends.
        self.end_minute = end_minute
        # The time when synthetic monitoring ends. The format is `yyyy-MM-dd HH`.
        self.end_time = end_time
        # The hour at which synthetic monitoring starts.
        self.start_hour = start_hour
        # The minute at which synthetic monitoring starts.
        self.start_minute = start_minute
        # The time when synthetic monitoring starts. The format is `yyyy-MM-dd HH`.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.end_hour is not None:
            result['EndHour'] = self.end_hour
        if self.end_minute is not None:
            result['EndMinute'] = self.end_minute
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_hour is not None:
            result['StartHour'] = self.start_hour
        if self.start_minute is not None:
            result['StartMinute'] = self.start_minute
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('EndHour') is not None:
            self.end_hour = m.get('EndHour')
        if m.get('EndMinute') is not None:
            self.end_minute = m.get('EndMinute')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartHour') is not None:
            self.start_hour = m.get('StartHour')
        if m.get('StartMinute') is not None:
            self.start_minute = m.get('StartMinute')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CreateSyntheticTaskRequestMonitorList(TeaModel):
    def __init__(
        self,
        city_code: int = None,
        monitor_type: int = None,
        net_service_id: int = None,
    ):
        # The ID of the city to which the monitoring point belongs.
        # 
        # This parameter is required.
        self.city_code = city_code
        # The carrier type:
        # 
        # *   IDC
        # *   LastMilie
        # 
        # This parameter is required.
        self.monitor_type = monitor_type
        # The ID of the carrier.
        # 
        # This parameter is required.
        self.net_service_id = net_service_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.monitor_type is not None:
            result['MonitorType'] = self.monitor_type
        if self.net_service_id is not None:
            result['NetServiceId'] = self.net_service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('MonitorType') is not None:
            self.monitor_type = m.get('MonitorType')
        if m.get('NetServiceId') is not None:
            self.net_service_id = m.get('NetServiceId')
        return self


class CreateSyntheticTaskRequestNavigation(TeaModel):
    def __init__(
        self,
        dnshijack_white_list: str = None,
        element_blacklist: str = None,
        execute_active_x: int = None,
        execute_application: int = None,
        execute_script: int = None,
        filter_invalid_ip: int = None,
        flow_hijack_jump_times: int = None,
        flow_hijack_logo: str = None,
        monitor_timeout: str = None,
        nav_automatic_scrolling: str = None,
        nav_custom_header: str = None,
        nav_custom_header_content: str = None,
        nav_custom_host: int = None,
        nav_custom_host_ip: str = None,
        nav_disable_cache: int = None,
        nav_disable_compression: str = None,
        nav_ignore_certificate_error: int = None,
        nav_redirection: int = None,
        nav_return_element: int = None,
        page_tamper: str = None,
        process_name: str = None,
        quicdomain: str = None,
        quicversion: int = None,
        request_header: int = None,
        response_header: int = None,
        slow_element_threshold: float = None,
        verify_string_blacklist: str = None,
        verify_string_white_list: str = None,
        wait_completion_time: float = None,
    ):
        # The whitelist for DNS hijacking.
        self.dnshijack_white_list = dnshijack_white_list
        # The element blacklist.
        self.element_blacklist = element_blacklist
        # Specifies whether to execute ActiveX.
        # 
        # *   3: yes
        # *   0: no
        # 
        # >  This parameter is supported only by IE Full Elements.
        self.execute_active_x = execute_active_x
        # Specifies whether to run applets.
        # 
        # *   1: yes
        # *   0: no
        # 
        # >  This parameter is supported only by IE Full Elements.
        self.execute_application = execute_application
        # Specifies whether to execute scripts.
        # 
        # *   1: yes
        # *   0: no
        # 
        # >  This parameter is supported only by IE Full Elements.
        self.execute_script = execute_script
        # Specifies whether to filter invalid IP addresses.
        # 
        # *   1: no
        # *   0: yes
        self.filter_invalid_ip = filter_invalid_ip
        # The element that is used in DNS hijacking.
        self.flow_hijack_jump_times = flow_hijack_jump_times
        # The tag that is used in DNS hijacking.
        self.flow_hijack_logo = flow_hijack_logo
        # The timeout period of monitoring. Unit: seconds.
        self.monitor_timeout = monitor_timeout
        # Specifies whether to automatically scroll up and down the screen to load a page.
        # 
        # *   1: yes
        # *   0: no
        self.nav_automatic_scrolling = nav_automatic_scrolling
        # The method that is used to customize the header. Valid values:
        # 
        # *   0: disables the customer header.
        # *   1: modifies the first package.
        # *   2: modifies all packages.
        self.nav_custom_header = nav_custom_header
        # The format of the custom header. You can specify multiple fields. Separate the fields with vertical bars (|).
        self.nav_custom_header_content = nav_custom_header_content
        # The custom host mode.
        # 
        # *   1: round robin
        # *   0: random
        self.nav_custom_host = nav_custom_host
        # The custom host IP address. You can enter multiple IP addresses. Separate the IP addresses with commas (,).
        self.nav_custom_host_ip = nav_custom_host_ip
        # Specifies whether to disable caching.
        # 
        # *   1: disable
        # *   0: enable
        self.nav_disable_cache = nav_disable_cache
        # Specifies whether to enable the feature of using the Accept-Encoding field to determine whether to accept compressed files.
        # 
        # *   1: disable
        # *   0: enable
        self.nav_disable_compression = nav_disable_compression
        # Specifies whether to ignore certificate errors during certificate verification in the SSL handshake and continue browsing.
        # 
        # *   1: ignore
        # *   0: does not ignore
        self.nav_ignore_certificate_error = nav_ignore_certificate_error
        # Specifies whether to continue browsing after a redirection occurs.
        # 
        # *   1: yes
        # *   0: no
        self.nav_redirection = nav_redirection
        # Specifies whether to return the elements on the page.
        # 
        # *   1: no. Returns the basic document data.
        # *   2: yes. Returns all document data.
        self.nav_return_element = nav_return_element
        # The web page defacement.
        self.page_tamper = page_tamper
        # The process ID.
        self.process_name = process_name
        # The domain name of the QUIC request element.
        # 
        # >  This parameter is supported by all elements of only Chrome
        self.quicdomain = quicdomain
        # The Quick UDP Internet Connections (QUIC) protocol version. Default value: 0. Valid values:
        # 
        # *\
        # *   35
        # *   39
        # *   43
        # *   44
        # 
        # >  This parameter is supported by all elements of only Chrome
        self.quicversion = quicversion
        # Specifies whether to return the request header.
        # 
        # *   0: does not return the response header.
        # *   1: returns the basic document header.
        # *   2: returns all headers.
        self.request_header = request_header
        # The method that is used to return the response header. Valid values:
        # 
        # *   0: does not return the response header.
        # *   1: returns the basic document header.
        # *   2: returns all headers.
        self.response_header = response_header
        # The time threshold that is used to define a slow element. Unit: seconds.
        self.slow_element_threshold = slow_element_threshold
        # The blacklist for string verification.
        self.verify_string_blacklist = verify_string_blacklist
        # The whitelist for string verification.
        self.verify_string_white_list = verify_string_white_list
        # The timeout period of waiting for the monitoring to complete.
        self.wait_completion_time = wait_completion_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dnshijack_white_list is not None:
            result['DNSHijackWhiteList'] = self.dnshijack_white_list
        if self.element_blacklist is not None:
            result['ElementBlacklist'] = self.element_blacklist
        if self.execute_active_x is not None:
            result['ExecuteActiveX'] = self.execute_active_x
        if self.execute_application is not None:
            result['ExecuteApplication'] = self.execute_application
        if self.execute_script is not None:
            result['ExecuteScript'] = self.execute_script
        if self.filter_invalid_ip is not None:
            result['FilterInvalidIP'] = self.filter_invalid_ip
        if self.flow_hijack_jump_times is not None:
            result['FlowHijackJumpTimes'] = self.flow_hijack_jump_times
        if self.flow_hijack_logo is not None:
            result['FlowHijackLogo'] = self.flow_hijack_logo
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.nav_automatic_scrolling is not None:
            result['NavAutomaticScrolling'] = self.nav_automatic_scrolling
        if self.nav_custom_header is not None:
            result['NavCustomHeader'] = self.nav_custom_header
        if self.nav_custom_header_content is not None:
            result['NavCustomHeaderContent'] = self.nav_custom_header_content
        if self.nav_custom_host is not None:
            result['NavCustomHost'] = self.nav_custom_host
        if self.nav_custom_host_ip is not None:
            result['NavCustomHostIp'] = self.nav_custom_host_ip
        if self.nav_disable_cache is not None:
            result['NavDisableCache'] = self.nav_disable_cache
        if self.nav_disable_compression is not None:
            result['NavDisableCompression'] = self.nav_disable_compression
        if self.nav_ignore_certificate_error is not None:
            result['NavIgnoreCertificateError'] = self.nav_ignore_certificate_error
        if self.nav_redirection is not None:
            result['NavRedirection'] = self.nav_redirection
        if self.nav_return_element is not None:
            result['NavReturnElement'] = self.nav_return_element
        if self.page_tamper is not None:
            result['PageTamper'] = self.page_tamper
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.quicdomain is not None:
            result['QUICDomain'] = self.quicdomain
        if self.quicversion is not None:
            result['QUICVersion'] = self.quicversion
        if self.request_header is not None:
            result['RequestHeader'] = self.request_header
        if self.response_header is not None:
            result['ResponseHeader'] = self.response_header
        if self.slow_element_threshold is not None:
            result['SlowElementThreshold'] = self.slow_element_threshold
        if self.verify_string_blacklist is not None:
            result['VerifyStringBlacklist'] = self.verify_string_blacklist
        if self.verify_string_white_list is not None:
            result['VerifyStringWhiteList'] = self.verify_string_white_list
        if self.wait_completion_time is not None:
            result['WaitCompletionTime'] = self.wait_completion_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DNSHijackWhiteList') is not None:
            self.dnshijack_white_list = m.get('DNSHijackWhiteList')
        if m.get('ElementBlacklist') is not None:
            self.element_blacklist = m.get('ElementBlacklist')
        if m.get('ExecuteActiveX') is not None:
            self.execute_active_x = m.get('ExecuteActiveX')
        if m.get('ExecuteApplication') is not None:
            self.execute_application = m.get('ExecuteApplication')
        if m.get('ExecuteScript') is not None:
            self.execute_script = m.get('ExecuteScript')
        if m.get('FilterInvalidIP') is not None:
            self.filter_invalid_ip = m.get('FilterInvalidIP')
        if m.get('FlowHijackJumpTimes') is not None:
            self.flow_hijack_jump_times = m.get('FlowHijackJumpTimes')
        if m.get('FlowHijackLogo') is not None:
            self.flow_hijack_logo = m.get('FlowHijackLogo')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('NavAutomaticScrolling') is not None:
            self.nav_automatic_scrolling = m.get('NavAutomaticScrolling')
        if m.get('NavCustomHeader') is not None:
            self.nav_custom_header = m.get('NavCustomHeader')
        if m.get('NavCustomHeaderContent') is not None:
            self.nav_custom_header_content = m.get('NavCustomHeaderContent')
        if m.get('NavCustomHost') is not None:
            self.nav_custom_host = m.get('NavCustomHost')
        if m.get('NavCustomHostIp') is not None:
            self.nav_custom_host_ip = m.get('NavCustomHostIp')
        if m.get('NavDisableCache') is not None:
            self.nav_disable_cache = m.get('NavDisableCache')
        if m.get('NavDisableCompression') is not None:
            self.nav_disable_compression = m.get('NavDisableCompression')
        if m.get('NavIgnoreCertificateError') is not None:
            self.nav_ignore_certificate_error = m.get('NavIgnoreCertificateError')
        if m.get('NavRedirection') is not None:
            self.nav_redirection = m.get('NavRedirection')
        if m.get('NavReturnElement') is not None:
            self.nav_return_element = m.get('NavReturnElement')
        if m.get('PageTamper') is not None:
            self.page_tamper = m.get('PageTamper')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('QUICDomain') is not None:
            self.quicdomain = m.get('QUICDomain')
        if m.get('QUICVersion') is not None:
            self.quicversion = m.get('QUICVersion')
        if m.get('RequestHeader') is not None:
            self.request_header = m.get('RequestHeader')
        if m.get('ResponseHeader') is not None:
            self.response_header = m.get('ResponseHeader')
        if m.get('SlowElementThreshold') is not None:
            self.slow_element_threshold = m.get('SlowElementThreshold')
        if m.get('VerifyStringBlacklist') is not None:
            self.verify_string_blacklist = m.get('VerifyStringBlacklist')
        if m.get('VerifyStringWhiteList') is not None:
            self.verify_string_white_list = m.get('VerifyStringWhiteList')
        if m.get('WaitCompletionTime') is not None:
            self.wait_completion_time = m.get('WaitCompletionTime')
        return self


class CreateSyntheticTaskRequestNet(TeaModel):
    def __init__(
        self,
        net_dnsns: str = None,
        net_dnsquery_method: int = None,
        net_dnsserver: int = None,
        net_dnsswitch: int = None,
        net_dnstimeout: int = None,
        net_dig_switch: int = None,
        net_icmpactive: int = None,
        net_icmpdata_cut: int = None,
        net_icmpinterval: int = None,
        net_icmpnum: int = None,
        net_icmpsize: int = None,
        net_icmpswitch: int = None,
        net_icmptimeout: int = None,
        net_trace_route_num: int = None,
        net_trace_route_switch: int = None,
        net_trace_route_timeout: int = None,
        white_list: str = None,
    ):
        # The DNS server.
        self.net_dnsns = net_dnsns
        # The DNS query method. Valid values:
        # 
        # *   1: recursion
        # *   2: iteration
        self.net_dnsquery_method = net_dnsquery_method
        # The IP address type of the DNS server.
        # 
        # *   0: IPv4
        # *   1: IPv6
        # *   2: an automatic IP address
        self.net_dnsserver = net_dnsserver
        # Specifies whether to enable domain name system (DNS) monitoring.
        # 
        # *   0: Off.
        # *   1: On. You must set DNS parameters if you want to enable DNS monitoring.
        self.net_dnsswitch = net_dnsswitch
        # The timeout period of DNS monitoring. Default value: 5 seconds. Valid values: 0 to 45 seconds.
        self.net_dnstimeout = net_dnstimeout
        # Specifies whether to display the data in the DIG format. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.net_dig_switch = net_dig_switch
        # The protocol type. Valid values:
        # 
        # *   0: ICMP
        # *   1: TCP
        self.net_icmpactive = net_icmpactive
        # Specifies whether to split packages.
        # 
        # *   0: no
        # *   1: yes
        self.net_icmpdata_cut = net_icmpdata_cut
        # The interval at which the network synthetic monitoring task is executed. Unit: seconds.
        self.net_icmpinterval = net_icmpinterval
        # The number of packages.
        self.net_icmpnum = net_icmpnum
        # The package size.
        self.net_icmpsize = net_icmpsize
        # Specifies whether to enable ping monitoring.
        # 
        # *   0: Off.
        # *   1: On. You must set Internet control message protocol (ICMP) parameters if you want to enable ping monitoring.
        self.net_icmpswitch = net_icmpswitch
        # The timeout period of Ping monitoring.
        self.net_icmptimeout = net_icmptimeout
        # The maximum number of active monitoring points.
        self.net_trace_route_num = net_trace_route_num
        # Specifies whether to enable tracert monitoring.
        # 
        # *   0: Off.
        # *   1: On. You must set the tracert parameters if you want to enable tracert monitoring.
        self.net_trace_route_switch = net_trace_route_switch
        # The timeout period of tracert monitoring. Valid values: 0 to 300 seconds.
        self.net_trace_route_timeout = net_trace_route_timeout
        # The whitelist for DNS hijacking. The format is `Domain name: Matching rule`.
        # 
        # >  Wireless application protocol (WAP) networks do not support DNS hijacking.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.net_dnsns is not None:
            result['NetDNSNs'] = self.net_dnsns
        if self.net_dnsquery_method is not None:
            result['NetDNSQueryMethod'] = self.net_dnsquery_method
        if self.net_dnsserver is not None:
            result['NetDNSServer'] = self.net_dnsserver
        if self.net_dnsswitch is not None:
            result['NetDNSSwitch'] = self.net_dnsswitch
        if self.net_dnstimeout is not None:
            result['NetDNSTimeout'] = self.net_dnstimeout
        if self.net_dig_switch is not None:
            result['NetDigSwitch'] = self.net_dig_switch
        if self.net_icmpactive is not None:
            result['NetICMPActive'] = self.net_icmpactive
        if self.net_icmpdata_cut is not None:
            result['NetICMPDataCut'] = self.net_icmpdata_cut
        if self.net_icmpinterval is not None:
            result['NetICMPInterval'] = self.net_icmpinterval
        if self.net_icmpnum is not None:
            result['NetICMPNum'] = self.net_icmpnum
        if self.net_icmpsize is not None:
            result['NetICMPSize'] = self.net_icmpsize
        if self.net_icmpswitch is not None:
            result['NetICMPSwitch'] = self.net_icmpswitch
        if self.net_icmptimeout is not None:
            result['NetICMPTimeout'] = self.net_icmptimeout
        if self.net_trace_route_num is not None:
            result['NetTraceRouteNum'] = self.net_trace_route_num
        if self.net_trace_route_switch is not None:
            result['NetTraceRouteSwitch'] = self.net_trace_route_switch
        if self.net_trace_route_timeout is not None:
            result['NetTraceRouteTimeout'] = self.net_trace_route_timeout
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetDNSNs') is not None:
            self.net_dnsns = m.get('NetDNSNs')
        if m.get('NetDNSQueryMethod') is not None:
            self.net_dnsquery_method = m.get('NetDNSQueryMethod')
        if m.get('NetDNSServer') is not None:
            self.net_dnsserver = m.get('NetDNSServer')
        if m.get('NetDNSSwitch') is not None:
            self.net_dnsswitch = m.get('NetDNSSwitch')
        if m.get('NetDNSTimeout') is not None:
            self.net_dnstimeout = m.get('NetDNSTimeout')
        if m.get('NetDigSwitch') is not None:
            self.net_dig_switch = m.get('NetDigSwitch')
        if m.get('NetICMPActive') is not None:
            self.net_icmpactive = m.get('NetICMPActive')
        if m.get('NetICMPDataCut') is not None:
            self.net_icmpdata_cut = m.get('NetICMPDataCut')
        if m.get('NetICMPInterval') is not None:
            self.net_icmpinterval = m.get('NetICMPInterval')
        if m.get('NetICMPNum') is not None:
            self.net_icmpnum = m.get('NetICMPNum')
        if m.get('NetICMPSize') is not None:
            self.net_icmpsize = m.get('NetICMPSize')
        if m.get('NetICMPSwitch') is not None:
            self.net_icmpswitch = m.get('NetICMPSwitch')
        if m.get('NetICMPTimeout') is not None:
            self.net_icmptimeout = m.get('NetICMPTimeout')
        if m.get('NetTraceRouteNum') is not None:
            self.net_trace_route_num = m.get('NetTraceRouteNum')
        if m.get('NetTraceRouteSwitch') is not None:
            self.net_trace_route_switch = m.get('NetTraceRouteSwitch')
        if m.get('NetTraceRouteTimeout') is not None:
            self.net_trace_route_timeout = m.get('NetTraceRouteTimeout')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateSyntheticTaskRequestProtocolRequestContentBodyFormData(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of **form-data**.
        self.key = key
        # The value of **form-data**.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of **x-www-form-urlencoded**.
        self.key = key
        # The value of **x-www-form-urlencoded**.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateSyntheticTaskRequestProtocolRequestContentBody(TeaModel):
    def __init__(
        self,
        form_data: List[CreateSyntheticTaskRequestProtocolRequestContentBodyFormData] = None,
        language: str = None,
        mode: str = None,
        raw: str = None,
        url_encoding: List[CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding] = None,
    ):
        # The data that is passed when the **Mode** parameter is set to **form-data**.
        self.form_data = form_data
        # The language that is selected when the Mode parameter is set to raw.
        # 
        # *   json
        # *   xml
        # *   javascript
        # *   html
        # *   text
        self.language = language
        # The data type of the content.
        # 
        # *   form-data
        # *   x-www-form-urlencoded
        # *   raw
        self.mode = mode
        # The data that is passed when the **Mode** parameter is set to **raw**.
        self.raw = raw
        # The data that is passed when the **Mode** parameter is set to **x-www-form-urlencoded**.
        self.url_encoding = url_encoding

    def validate(self):
        if self.form_data:
            for k in self.form_data:
                if k:
                    k.validate()
        if self.url_encoding:
            for k in self.url_encoding:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FormData'] = []
        if self.form_data is not None:
            for k in self.form_data:
                result['FormData'].append(k.to_map() if k else None)
        if self.language is not None:
            result['Language'] = self.language
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.raw is not None:
            result['Raw'] = self.raw
        result['UrlEncoding'] = []
        if self.url_encoding is not None:
            for k in self.url_encoding:
                result['UrlEncoding'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.form_data = []
        if m.get('FormData') is not None:
            for k in m.get('FormData'):
                temp_model = CreateSyntheticTaskRequestProtocolRequestContentBodyFormData()
                self.form_data.append(temp_model.from_map(k))
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Raw') is not None:
            self.raw = m.get('Raw')
        self.url_encoding = []
        if m.get('UrlEncoding') is not None:
            for k in m.get('UrlEncoding'):
                temp_model = CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding()
                self.url_encoding.append(temp_model.from_map(k))
        return self


class CreateSyntheticTaskRequestProtocolRequestContentHeader(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the request header.
        self.key = key
        # The value of the request header.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateSyntheticTaskRequestProtocolRequestContent(TeaModel):
    def __init__(
        self,
        body: CreateSyntheticTaskRequestProtocolRequestContentBody = None,
        header: List[CreateSyntheticTaskRequestProtocolRequestContentHeader] = None,
        method: str = None,
    ):
        # The custom body of a request to initiate an API performance synthetic monitoring task.
        self.body = body
        # The custom header of a request to initiate an API performance synthetic monitoring task.
        self.header = header
        # The request method.
        # 
        # *   POST
        # *   GET
        self.method = method

    def validate(self):
        if self.body:
            self.body.validate()
        if self.header:
            for k in self.header:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body.to_map()
        result['Header'] = []
        if self.header is not None:
            for k in self.header:
                result['Header'].append(k.to_map() if k else None)
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            temp_model = CreateSyntheticTaskRequestProtocolRequestContentBody()
            self.body = temp_model.from_map(m['Body'])
        self.header = []
        if m.get('Header') is not None:
            for k in m.get('Header'):
                temp_model = CreateSyntheticTaskRequestProtocolRequestContentHeader()
                self.header.append(temp_model.from_map(k))
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class CreateSyntheticTaskRequestProtocol(TeaModel):
    def __init__(
        self,
        character_encoding: int = None,
        custom_host: int = None,
        custom_host_ip: str = None,
        protocol_connection_time: int = None,
        protocol_monitor_timeout: str = None,
        received_data_size: int = None,
        request_content: CreateSyntheticTaskRequestProtocolRequestContent = None,
        verify_content: str = None,
        verify_way: int = None,
    ):
        # The encoding format.
        # 
        # *   0: UTF-8
        # *   1: GBK
        # *   2: GB2312
        # *   3: Unicode
        self.character_encoding = character_encoding
        # The custom host mode.
        # 
        # *   1: round robin
        # *   0: random
        self.custom_host = custom_host
        # The custom host IP address. You can enter multiple IP addresses. Separate the IP addresses with commas (,).
        self.custom_host_ip = custom_host_ip
        # The connection timeout period of the protocol. Unit: seconds.
        self.protocol_connection_time = protocol_connection_time
        # The timeout period of API performance synthetic monitoring. Unit: seconds.
        self.protocol_monitor_timeout = protocol_monitor_timeout
        # The size of the received data. This parameter is required when you set the value of the VerifyWay parameter to 2.
        self.received_data_size = received_data_size
        # The request content, including the request header and request body.
        self.request_content = request_content
        # The verification string.
        self.verify_content = verify_content
        # The method that is used to verify the response content.
        # 
        # *   0: no verification.
        # *   1: exact match with the verification string.
        # *   2: partial match with the verification string.
        # *   3: MD5 verification.
        self.verify_way = verify_way

    def validate(self):
        if self.request_content:
            self.request_content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.character_encoding is not None:
            result['CharacterEncoding'] = self.character_encoding
        if self.custom_host is not None:
            result['CustomHost'] = self.custom_host
        if self.custom_host_ip is not None:
            result['CustomHostIp'] = self.custom_host_ip
        if self.protocol_connection_time is not None:
            result['ProtocolConnectionTime'] = self.protocol_connection_time
        if self.protocol_monitor_timeout is not None:
            result['ProtocolMonitorTimeout'] = self.protocol_monitor_timeout
        if self.received_data_size is not None:
            result['ReceivedDataSize'] = self.received_data_size
        if self.request_content is not None:
            result['RequestContent'] = self.request_content.to_map()
        if self.verify_content is not None:
            result['VerifyContent'] = self.verify_content
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharacterEncoding') is not None:
            self.character_encoding = m.get('CharacterEncoding')
        if m.get('CustomHost') is not None:
            self.custom_host = m.get('CustomHost')
        if m.get('CustomHostIp') is not None:
            self.custom_host_ip = m.get('CustomHostIp')
        if m.get('ProtocolConnectionTime') is not None:
            self.protocol_connection_time = m.get('ProtocolConnectionTime')
        if m.get('ProtocolMonitorTimeout') is not None:
            self.protocol_monitor_timeout = m.get('ProtocolMonitorTimeout')
        if m.get('ReceivedDataSize') is not None:
            self.received_data_size = m.get('ReceivedDataSize')
        if m.get('RequestContent') is not None:
            temp_model = CreateSyntheticTaskRequestProtocolRequestContent()
            self.request_content = temp_model.from_map(m['RequestContent'])
        if m.get('VerifyContent') is not None:
            self.verify_content = m.get('VerifyContent')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        return self


class CreateSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        common_param: CreateSyntheticTaskRequestCommonParam = None,
        download: CreateSyntheticTaskRequestDownload = None,
        extend_interval: CreateSyntheticTaskRequestExtendInterval = None,
        interval_time: str = None,
        interval_type: str = None,
        ip_type: int = None,
        monitor_list: List[CreateSyntheticTaskRequestMonitorList] = None,
        navigation: CreateSyntheticTaskRequestNavigation = None,
        net: CreateSyntheticTaskRequestNet = None,
        protocol: CreateSyntheticTaskRequestProtocol = None,
        region_id: str = None,
        task_name: str = None,
        task_type: int = None,
        update_task: bool = None,
        url: str = None,
    ):
        # The common parameters.
        self.common_param = common_param
        # The file download task.
        self.download = download
        # The frequency.
        self.extend_interval = extend_interval
        # The interval at which synthetic monitoring is performed. Unit: minutes. Valid values:
        # 
        # *   1
        # *   5
        # *   10
        # *   15
        # *   20
        # *   30
        # *   60
        # *   120
        # *   180
        # *   240
        # *   360
        # *   480
        # *   720
        # *   1440
        # 
        # This parameter is required.
        self.interval_time = interval_time
        # The interval type.
        # 
        # *   0: daily
        # *   1: custom frequency
        # 
        # This parameter is required.
        self.interval_type = interval_type
        # The IP address type:
        # 
        # *   0: an automatic IP address
        # *   1: IPv4
        # *   2: IPv6
        # 
        # This parameter is required.
        self.ip_type = ip_type
        # The list of monitoring points.
        # 
        # This parameter is required.
        self.monitor_list = monitor_list
        # The monitoring items that are associated with the browse tasks.
        self.navigation = navigation
        # The network synthetic monitoring task.
        self.net = net
        # The API performance synthetic monitoring task.
        self.protocol = protocol
        # The ID of the region in which the application is located.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The name of the task. To update a synthetic monitoring task, enter the task name and set the **UpdateTask** parameter to **true**.
        # 
        # This parameter is required.
        self.task_name = task_name
        # The type of the monitoring task. Valid values:
        # 
        # 1.  3: web page performance - IE
        # 2.  34: web Page Performance - Chrome
        # 3.  0: network quality
        # 4.  40: file download
        # 5.  7:API performance
        # 
        # This parameter is required.
        self.task_type = task_type
        # Specifies whether to update existing synthetic monitoring tasks.
        # 
        # *   true: updates existing synthetic monitoring tasks.
        # *   false: creates new synthetic monitoring tasks.
        self.update_task = update_task
        # The URL for synthetic monitoring.
        # 
        # This parameter is required.
        self.url = url

    def validate(self):
        if self.common_param:
            self.common_param.validate()
        if self.download:
            self.download.validate()
        if self.extend_interval:
            self.extend_interval.validate()
        if self.monitor_list:
            for k in self.monitor_list:
                if k:
                    k.validate()
        if self.navigation:
            self.navigation.validate()
        if self.net:
            self.net.validate()
        if self.protocol:
            self.protocol.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_param is not None:
            result['CommonParam'] = self.common_param.to_map()
        if self.download is not None:
            result['Download'] = self.download.to_map()
        if self.extend_interval is not None:
            result['ExtendInterval'] = self.extend_interval.to_map()
        if self.interval_time is not None:
            result['IntervalTime'] = self.interval_time
        if self.interval_type is not None:
            result['IntervalType'] = self.interval_type
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        result['MonitorList'] = []
        if self.monitor_list is not None:
            for k in self.monitor_list:
                result['MonitorList'].append(k.to_map() if k else None)
        if self.navigation is not None:
            result['Navigation'] = self.navigation.to_map()
        if self.net is not None:
            result['Net'] = self.net.to_map()
        if self.protocol is not None:
            result['Protocol'] = self.protocol.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.update_task is not None:
            result['UpdateTask'] = self.update_task
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommonParam') is not None:
            temp_model = CreateSyntheticTaskRequestCommonParam()
            self.common_param = temp_model.from_map(m['CommonParam'])
        if m.get('Download') is not None:
            temp_model = CreateSyntheticTaskRequestDownload()
            self.download = temp_model.from_map(m['Download'])
        if m.get('ExtendInterval') is not None:
            temp_model = CreateSyntheticTaskRequestExtendInterval()
            self.extend_interval = temp_model.from_map(m['ExtendInterval'])
        if m.get('IntervalTime') is not None:
            self.interval_time = m.get('IntervalTime')
        if m.get('IntervalType') is not None:
            self.interval_type = m.get('IntervalType')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        self.monitor_list = []
        if m.get('MonitorList') is not None:
            for k in m.get('MonitorList'):
                temp_model = CreateSyntheticTaskRequestMonitorList()
                self.monitor_list.append(temp_model.from_map(k))
        if m.get('Navigation') is not None:
            temp_model = CreateSyntheticTaskRequestNavigation()
            self.navigation = temp_model.from_map(m['Navigation'])
        if m.get('Net') is not None:
            temp_model = CreateSyntheticTaskRequestNet()
            self.net = temp_model.from_map(m['Net'])
        if m.get('Protocol') is not None:
            temp_model = CreateSyntheticTaskRequestProtocol()
            self.protocol = temp_model.from_map(m['Protocol'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UpdateTask') is not None:
            self.update_task = m.get('UpdateTask')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateSyntheticTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        common_param_shrink: str = None,
        download_shrink: str = None,
        extend_interval_shrink: str = None,
        interval_time: str = None,
        interval_type: str = None,
        ip_type: int = None,
        monitor_list_shrink: str = None,
        navigation_shrink: str = None,
        net_shrink: str = None,
        protocol_shrink: str = None,
        region_id: str = None,
        task_name: str = None,
        task_type: int = None,
        update_task: bool = None,
        url: str = None,
    ):
        # The common parameters.
        self.common_param_shrink = common_param_shrink
        # The file download task.
        self.download_shrink = download_shrink
        # The frequency.
        self.extend_interval_shrink = extend_interval_shrink
        # The interval at which synthetic monitoring is performed. Unit: minutes. Valid values:
        # 
        # *   1
        # *   5
        # *   10
        # *   15
        # *   20
        # *   30
        # *   60
        # *   120
        # *   180
        # *   240
        # *   360
        # *   480
        # *   720
        # *   1440
        # 
        # This parameter is required.
        self.interval_time = interval_time
        # The interval type.
        # 
        # *   0: daily
        # *   1: custom frequency
        # 
        # This parameter is required.
        self.interval_type = interval_type
        # The IP address type:
        # 
        # *   0: an automatic IP address
        # *   1: IPv4
        # *   2: IPv6
        # 
        # This parameter is required.
        self.ip_type = ip_type
        # The list of monitoring points.
        # 
        # This parameter is required.
        self.monitor_list_shrink = monitor_list_shrink
        # The monitoring items that are associated with the browse tasks.
        self.navigation_shrink = navigation_shrink
        # The network synthetic monitoring task.
        self.net_shrink = net_shrink
        # The API performance synthetic monitoring task.
        self.protocol_shrink = protocol_shrink
        # The ID of the region in which the application is located.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The name of the task. To update a synthetic monitoring task, enter the task name and set the **UpdateTask** parameter to **true**.
        # 
        # This parameter is required.
        self.task_name = task_name
        # The type of the monitoring task. Valid values:
        # 
        # 1.  3: web page performance - IE
        # 2.  34: web Page Performance - Chrome
        # 3.  0: network quality
        # 4.  40: file download
        # 5.  7:API performance
        # 
        # This parameter is required.
        self.task_type = task_type
        # Specifies whether to update existing synthetic monitoring tasks.
        # 
        # *   true: updates existing synthetic monitoring tasks.
        # *   false: creates new synthetic monitoring tasks.
        self.update_task = update_task
        # The URL for synthetic monitoring.
        # 
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_param_shrink is not None:
            result['CommonParam'] = self.common_param_shrink
        if self.download_shrink is not None:
            result['Download'] = self.download_shrink
        if self.extend_interval_shrink is not None:
            result['ExtendInterval'] = self.extend_interval_shrink
        if self.interval_time is not None:
            result['IntervalTime'] = self.interval_time
        if self.interval_type is not None:
            result['IntervalType'] = self.interval_type
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.monitor_list_shrink is not None:
            result['MonitorList'] = self.monitor_list_shrink
        if self.navigation_shrink is not None:
            result['Navigation'] = self.navigation_shrink
        if self.net_shrink is not None:
            result['Net'] = self.net_shrink
        if self.protocol_shrink is not None:
            result['Protocol'] = self.protocol_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.update_task is not None:
            result['UpdateTask'] = self.update_task
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommonParam') is not None:
            self.common_param_shrink = m.get('CommonParam')
        if m.get('Download') is not None:
            self.download_shrink = m.get('Download')
        if m.get('ExtendInterval') is not None:
            self.extend_interval_shrink = m.get('ExtendInterval')
        if m.get('IntervalTime') is not None:
            self.interval_time = m.get('IntervalTime')
        if m.get('IntervalType') is not None:
            self.interval_type = m.get('IntervalType')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('MonitorList') is not None:
            self.monitor_list_shrink = m.get('MonitorList')
        if m.get('Navigation') is not None:
            self.navigation_shrink = m.get('Navigation')
        if m.get('Net') is not None:
            self.net_shrink = m.get('Net')
        if m.get('Protocol') is not None:
            self.protocol_shrink = m.get('Protocol')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UpdateTask') is not None:
            self.update_task = m.get('UpdateTask')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateSyntheticTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: int = None,
    ):
        # The ID of the synthetic monitoring task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateSyntheticTaskResponseBodyData = None,
        msg: str = None,
        request_id: str = None,
    ):
        # The status code returned.
        # 
        # *   1001: The request was successful.
        # *   1002: The request failed.
        # *   1003: Parameter errors occurred.
        # *   1004: Authentication failed.
        # *   1006: The task does not exist.
        # *   1099: Internal errors occurred.
        self.code = code
        # The information about the synthetic monitoring task.
        self.data = data
        # The message that is returned when the task failed to be created.
        self.msg = msg
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateSyntheticTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTimingSyntheticTaskRequestAvailableAssertions(TeaModel):
    def __init__(
        self,
        expect: str = None,
        operator: str = None,
        target: str = None,
        type: str = None,
    ):
        # The expected value.
        # 
        # This parameter is required.
        self.expect = expect
        # The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
        # 
        # This parameter is required.
        self.operator = operator
        # The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
        self.target = target
        # The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect is not None:
            result['Expect'] = self.expect
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expect') is not None:
            self.expect = m.get('Expect')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts(TeaModel):
    def __init__(
        self,
        domain: str = None,
        ip_type: int = None,
        ips: List[str] = None,
    ):
        # The domain name.
        # 
        # This parameter is required.
        self.domain = domain
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4.
        # *   2: IPv6.
        # 
        # This parameter is required.
        self.ip_type = ip_type
        # The list of IP addresses.
        # 
        # This parameter is required.
        self.ips = ips

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.ips is not None:
            result['Ips'] = self.ips
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        return self


class CreateTimingSyntheticTaskRequestCommonSettingCustomHost(TeaModel):
    def __init__(
        self,
        hosts: List[CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts] = None,
        select_type: int = None,
    ):
        # The list of hosts.
        # 
        # This parameter is required.
        self.hosts = hosts
        # The selection mode. Valid values:
        # 
        # *   0: random
        # *   1: polling
        # 
        # This parameter is required.
        self.select_type = select_type

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['Hosts'].append(k.to_map() if k else None)
        if self.select_type is not None:
            result['SelectType'] = self.select_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.hosts = []
        if m.get('Hosts') is not None:
            for k in m.get('Hosts'):
                temp_model = CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts()
                self.hosts.append(temp_model.from_map(k))
        if m.get('SelectType') is not None:
            self.select_type = m.get('SelectType')
        return self


class CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting(TeaModel):
    def __init__(
        self,
        prometheus_cluster_id: str = None,
        prometheus_cluster_region: str = None,
        prometheus_labels: Dict[str, str] = None,
    ):
        # A reserved parameter.
        self.prometheus_cluster_id = prometheus_cluster_id
        # A reserved parameter.
        self.prometheus_cluster_region = prometheus_cluster_region
        # A reserved parameter.
        self.prometheus_labels = prometheus_labels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_cluster_id is not None:
            result['PrometheusClusterId'] = self.prometheus_cluster_id
        if self.prometheus_cluster_region is not None:
            result['PrometheusClusterRegion'] = self.prometheus_cluster_region
        if self.prometheus_labels is not None:
            result['PrometheusLabels'] = self.prometheus_labels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PrometheusClusterId') is not None:
            self.prometheus_cluster_id = m.get('PrometheusClusterId')
        if m.get('PrometheusClusterRegion') is not None:
            self.prometheus_cluster_region = m.get('PrometheusClusterRegion')
        if m.get('PrometheusLabels') is not None:
            self.prometheus_labels = m.get('PrometheusLabels')
        return self


class CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        secure_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The ID of the security group to which the client belongs. The security group specifies the inbound and outbound rules of the client for the VPC. You need to allow the security group to which the client belongs to access the security group to which the VPC belongs. Otherwise, the client cannot access resources in the VPC.
        self.secure_group_id = secure_group_id
        # The vSwitch ID.
        self.v_switch_id = v_switch_id
        # VPC ID.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.secure_group_id is not None:
            result['SecureGroupId'] = self.secure_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecureGroupId') is not None:
            self.secure_group_id = m.get('SecureGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateTimingSyntheticTaskRequestCommonSetting(TeaModel):
    def __init__(
        self,
        custom_host: CreateTimingSyntheticTaskRequestCommonSettingCustomHost = None,
        custom_prometheus_setting: CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting = None,
        custom_vpcsetting: CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting = None,
        ip_type: int = None,
        is_open_trace: bool = None,
        monitor_samples: int = None,
        trace_client_type: int = None,
        xtrace_region: str = None,
    ):
        # The custom host settings.
        self.custom_host = custom_host
        # The reserved parameters.
        self.custom_prometheus_setting = custom_prometheus_setting
        # The information about the virtual private cloud (VPC). If the destination URL is an Alibaba Cloud internal endpoint, you need to configure a VPC.
        self.custom_vpcsetting = custom_vpcsetting
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4.
        # *   2: IPv6.
        self.ip_type = ip_type
        # Specifies whether to enable tracing.
        self.is_open_trace = is_open_trace
        # Specifies whether to evenly distribute monitoring samples. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.monitor_samples = monitor_samples
        # The type of the client for tracing. Valid values:
        # 
        # *   0: ARMS agent
        # *   1: OpenTelemetry
        # *   2: Jaeger
        self.trace_client_type = trace_client_type
        # The region to which trace data is reported.
        self.xtrace_region = xtrace_region

    def validate(self):
        if self.custom_host:
            self.custom_host.validate()
        if self.custom_prometheus_setting:
            self.custom_prometheus_setting.validate()
        if self.custom_vpcsetting:
            self.custom_vpcsetting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_host is not None:
            result['CustomHost'] = self.custom_host.to_map()
        if self.custom_prometheus_setting is not None:
            result['CustomPrometheusSetting'] = self.custom_prometheus_setting.to_map()
        if self.custom_vpcsetting is not None:
            result['CustomVPCSetting'] = self.custom_vpcsetting.to_map()
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.is_open_trace is not None:
            result['IsOpenTrace'] = self.is_open_trace
        if self.monitor_samples is not None:
            result['MonitorSamples'] = self.monitor_samples
        if self.trace_client_type is not None:
            result['TraceClientType'] = self.trace_client_type
        if self.xtrace_region is not None:
            result['XtraceRegion'] = self.xtrace_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHost') is not None:
            temp_model = CreateTimingSyntheticTaskRequestCommonSettingCustomHost()
            self.custom_host = temp_model.from_map(m['CustomHost'])
        if m.get('CustomPrometheusSetting') is not None:
            temp_model = CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting()
            self.custom_prometheus_setting = temp_model.from_map(m['CustomPrometheusSetting'])
        if m.get('CustomVPCSetting') is not None:
            temp_model = CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting()
            self.custom_vpcsetting = temp_model.from_map(m['CustomVPCSetting'])
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('IsOpenTrace') is not None:
            self.is_open_trace = m.get('IsOpenTrace')
        if m.get('MonitorSamples') is not None:
            self.monitor_samples = m.get('MonitorSamples')
        if m.get('TraceClientType') is not None:
            self.trace_client_type = m.get('TraceClientType')
        if m.get('XtraceRegion') is not None:
            self.xtrace_region = m.get('XtraceRegion')
        return self


class CreateTimingSyntheticTaskRequestCustomPeriod(TeaModel):
    def __init__(
        self,
        end_hour: int = None,
        start_hour: int = None,
    ):
        # The custom host settings.
        # 
        # This parameter is required.
        self.end_hour = end_hour
        # The list of hosts.
        # 
        # This parameter is required.
        self.start_hour = start_hour

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_hour is not None:
            result['EndHour'] = self.end_hour
        if self.start_hour is not None:
            result['StartHour'] = self.start_hour
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndHour') is not None:
            self.end_hour = m.get('EndHour')
        if m.get('StartHour') is not None:
            self.start_hour = m.get('StartHour')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        type: str = None,
    ):
        # The content of the request body. Format: JSON string. The parameter is required if the Type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
        self.content = content
        # The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfApiHTTP(TeaModel):
    def __init__(
        self,
        check_cert: bool = None,
        connect_timeout: int = None,
        method: str = None,
        protocol_alpn_protocol: int = None,
        request_body: CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody = None,
        request_headers: Dict[str, str] = None,
        target_url: str = None,
        timeout: int = None,
    ):
        # Specifies whether to verify the certificate. Default value: no.
        self.check_cert = check_cert
        # The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
        self.connect_timeout = connect_timeout
        # The request method. Valid values: GET and POST.
        self.method = method
        # The ALPN protocol version. You can configure this parameter when you perform an HTTPS synthetic test on a WAP mobile client. Valid values:
        # 
        # 0: default
        # 
        # 1: http/1.1
        # 
        # 2: h2
        # 
        # 3: disables the ALPN protocol
        self.protocol_alpn_protocol = protocol_alpn_protocol
        # The HTTP request body.
        self.request_body = request_body
        # The HTTP request header.
        self.request_headers = request_headers
        # The URL or request path for synthetic monitoring.
        # 
        # This parameter is required.
        self.target_url = target_url
        # The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
        self.timeout = timeout

    def validate(self):
        if self.request_body:
            self.request_body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_cert is not None:
            result['CheckCert'] = self.check_cert
        if self.connect_timeout is not None:
            result['ConnectTimeout'] = self.connect_timeout
        if self.method is not None:
            result['Method'] = self.method
        if self.protocol_alpn_protocol is not None:
            result['ProtocolAlpnProtocol'] = self.protocol_alpn_protocol
        if self.request_body is not None:
            result['RequestBody'] = self.request_body.to_map()
        if self.request_headers is not None:
            result['RequestHeaders'] = self.request_headers
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckCert') is not None:
            self.check_cert = m.get('CheckCert')
        if m.get('ConnectTimeout') is not None:
            self.connect_timeout = m.get('ConnectTimeout')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('ProtocolAlpnProtocol') is not None:
            self.protocol_alpn_protocol = m.get('ProtocolAlpnProtocol')
        if m.get('RequestBody') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody()
            self.request_body = temp_model.from_map(m['RequestBody'])
        if m.get('RequestHeaders') is not None:
            self.request_headers = m.get('RequestHeaders')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfFileDownload(TeaModel):
    def __init__(
        self,
        connection_timeout: int = None,
        custom_header_content: Dict[str, str] = None,
        download_kernel: int = None,
        ignore_certificate_auth_error: int = None,
        ignore_certificate_canceled_error: int = None,
        ignore_certificate_out_of_date_error: int = None,
        ignore_certificate_status_error: int = None,
        ignore_certificate_untrustworthy_error: int = None,
        ignore_certificate_using_error: int = None,
        ignore_invalid_host_error: int = None,
        monitor_timeout: int = None,
        quick_protocol: int = None,
        redirection: int = None,
        target_url: str = None,
        transmission_size: int = None,
        validate_keywords: str = None,
        verify_way: int = None,
        white_list: str = None,
    ):
        # Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
        self.connection_timeout = connection_timeout
        # The content of the custom request header.
        self.custom_header_content = custom_header_content
        # The kernel type. Valid values:
        # 
        # *   1: curl
        # *   0: WinInet
        # 
        # Default value: 1
        self.download_kernel = download_kernel
        # Specifies whether to ignore CA certificate authentication errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_auth_error = ignore_certificate_auth_error
        # Specifies whether to ignore certificate revocation errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_canceled_error = ignore_certificate_canceled_error
        # Specifies whether to ignore certificate invalidity. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_out_of_date_error = ignore_certificate_out_of_date_error
        # Specifies whether to ignore certificate status errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_status_error = ignore_certificate_status_error
        # Specifies whether to ignore certificate incredibility. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_untrustworthy_error = ignore_certificate_untrustworthy_error
        # Specifies whether to ignore certificate usage errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_using_error = ignore_certificate_using_error
        # Specifies whether to ignore host invalidity. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_invalid_host_error = ignore_invalid_host_error
        # The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
        self.monitor_timeout = monitor_timeout
        # The QUIC protocol type. Valid values:
        # 
        # *   1: HTTP/1
        # *   2: HTTP/2
        # *   3: HTTP/3
        # 
        # Default value: 1
        self.quick_protocol = quick_protocol
        # Specifies whether to support redirection. Valid values: 0: no. 1: yes. Default value: 1.
        self.redirection = redirection
        # The URL that is used to download the file.
        # 
        # This parameter is required.
        self.target_url = target_url
        # The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
        self.transmission_size = transmission_size
        # The keyword that is used in verification.
        self.validate_keywords = validate_keywords
        # The verification method. Valid values:
        # 
        # *   0: no verification
        # *   1: string verification
        # *   2: MD5 verification
        self.verify_way = verify_way
        # The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_timeout is not None:
            result['ConnectionTimeout'] = self.connection_timeout
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.download_kernel is not None:
            result['DownloadKernel'] = self.download_kernel
        if self.ignore_certificate_auth_error is not None:
            result['IgnoreCertificateAuthError'] = self.ignore_certificate_auth_error
        if self.ignore_certificate_canceled_error is not None:
            result['IgnoreCertificateCanceledError'] = self.ignore_certificate_canceled_error
        if self.ignore_certificate_out_of_date_error is not None:
            result['IgnoreCertificateOutOfDateError'] = self.ignore_certificate_out_of_date_error
        if self.ignore_certificate_status_error is not None:
            result['IgnoreCertificateStatusError'] = self.ignore_certificate_status_error
        if self.ignore_certificate_untrustworthy_error is not None:
            result['IgnoreCertificateUntrustworthyError'] = self.ignore_certificate_untrustworthy_error
        if self.ignore_certificate_using_error is not None:
            result['IgnoreCertificateUsingError'] = self.ignore_certificate_using_error
        if self.ignore_invalid_host_error is not None:
            result['IgnoreInvalidHostError'] = self.ignore_invalid_host_error
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.quick_protocol is not None:
            result['QuickProtocol'] = self.quick_protocol
        if self.redirection is not None:
            result['Redirection'] = self.redirection
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.transmission_size is not None:
            result['TransmissionSize'] = self.transmission_size
        if self.validate_keywords is not None:
            result['ValidateKeywords'] = self.validate_keywords
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionTimeout') is not None:
            self.connection_timeout = m.get('ConnectionTimeout')
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('DownloadKernel') is not None:
            self.download_kernel = m.get('DownloadKernel')
        if m.get('IgnoreCertificateAuthError') is not None:
            self.ignore_certificate_auth_error = m.get('IgnoreCertificateAuthError')
        if m.get('IgnoreCertificateCanceledError') is not None:
            self.ignore_certificate_canceled_error = m.get('IgnoreCertificateCanceledError')
        if m.get('IgnoreCertificateOutOfDateError') is not None:
            self.ignore_certificate_out_of_date_error = m.get('IgnoreCertificateOutOfDateError')
        if m.get('IgnoreCertificateStatusError') is not None:
            self.ignore_certificate_status_error = m.get('IgnoreCertificateStatusError')
        if m.get('IgnoreCertificateUntrustworthyError') is not None:
            self.ignore_certificate_untrustworthy_error = m.get('IgnoreCertificateUntrustworthyError')
        if m.get('IgnoreCertificateUsingError') is not None:
            self.ignore_certificate_using_error = m.get('IgnoreCertificateUsingError')
        if m.get('IgnoreInvalidHostError') is not None:
            self.ignore_invalid_host_error = m.get('IgnoreInvalidHostError')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('QuickProtocol') is not None:
            self.quick_protocol = m.get('QuickProtocol')
        if m.get('Redirection') is not None:
            self.redirection = m.get('Redirection')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('TransmissionSize') is not None:
            self.transmission_size = m.get('TransmissionSize')
        if m.get('ValidateKeywords') is not None:
            self.validate_keywords = m.get('ValidateKeywords')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfNetDNS(TeaModel):
    def __init__(
        self,
        dns_server_ip_type: int = None,
        ns_server: str = None,
        query_method: int = None,
        target_url: str = None,
        timeout: int = None,
    ):
        # The IP version of the DNS server.
        # 
        # *   0 (default): IPv4.
        # *   1: IPv6.
        # *   2: A version is automatically selected.
        self.dns_server_ip_type = dns_server_ip_type
        # The IP address of the DNS server. Default value: 114.114.114.114.
        self.ns_server = ns_server
        # The DNS query method. Valid values:
        # 
        # *   0 (default): recursive
        # *   1: iterative
        self.query_method = query_method
        # The destination domain name.
        # 
        # This parameter is required.
        self.target_url = target_url
        # The timeout period for the DNS synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 45000. Default value: 5000.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server_ip_type is not None:
            result['DnsServerIpType'] = self.dns_server_ip_type
        if self.ns_server is not None:
            result['NsServer'] = self.ns_server
        if self.query_method is not None:
            result['QueryMethod'] = self.query_method
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServerIpType') is not None:
            self.dns_server_ip_type = m.get('DnsServerIpType')
        if m.get('NsServer') is not None:
            self.ns_server = m.get('NsServer')
        if m.get('QueryMethod') is not None:
            self.query_method = m.get('QueryMethod')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfNetICMP(TeaModel):
    def __init__(
        self,
        interval: int = None,
        package_num: int = None,
        package_size: int = None,
        split_package: bool = None,
        target_url: str = None,
        timeout: int = None,
        tracert_enable: bool = None,
        tracert_num_max: int = None,
        tracert_timeout: int = None,
    ):
        # The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 2000. Default value: 200.
        self.interval = interval
        # The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
        self.package_num = package_num
        # The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        self.package_size = package_size
        # Specifies whether to split ICMP packets. Default value: true.
        self.split_package = split_package
        # The destination IP address or domain name.
        # 
        # This parameter is required.
        self.target_url = target_url
        # The timeout period for the ICMP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
        self.timeout = timeout
        # Specifies whether to enable the tracert command. Default value: true.
        self.tracert_enable = tracert_enable
        # The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
        self.tracert_num_max = tracert_num_max
        # The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
        self.tracert_timeout = tracert_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.package_num is not None:
            result['PackageNum'] = self.package_num
        if self.package_size is not None:
            result['PackageSize'] = self.package_size
        if self.split_package is not None:
            result['SplitPackage'] = self.split_package
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.tracert_enable is not None:
            result['TracertEnable'] = self.tracert_enable
        if self.tracert_num_max is not None:
            result['TracertNumMax'] = self.tracert_num_max
        if self.tracert_timeout is not None:
            result['TracertTimeout'] = self.tracert_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PackageNum') is not None:
            self.package_num = m.get('PackageNum')
        if m.get('PackageSize') is not None:
            self.package_size = m.get('PackageSize')
        if m.get('SplitPackage') is not None:
            self.split_package = m.get('SplitPackage')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TracertEnable') is not None:
            self.tracert_enable = m.get('TracertEnable')
        if m.get('TracertNumMax') is not None:
            self.tracert_num_max = m.get('TracertNumMax')
        if m.get('TracertTimeout') is not None:
            self.tracert_timeout = m.get('TracertTimeout')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfNetTCP(TeaModel):
    def __init__(
        self,
        connect_times: int = None,
        interval: int = None,
        target_url: str = None,
        timeout: int = None,
        tracert_enable: bool = None,
        tracert_num_max: int = None,
        tracert_timeout: int = None,
    ):
        # The number of TCP connections that are established. Minimum value: 1. Maximum value: 16. Default value: 4.
        self.connect_times = connect_times
        # The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
        self.interval = interval
        # The IP address of the destination host.
        # 
        # This parameter is required.
        self.target_url = target_url
        # The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
        self.timeout = timeout
        # Specifies whether to enable the tracert command. Default value: true.
        self.tracert_enable = tracert_enable
        # The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
        self.tracert_num_max = tracert_num_max
        # The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
        self.tracert_timeout = tracert_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_times is not None:
            result['ConnectTimes'] = self.connect_times
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.tracert_enable is not None:
            result['TracertEnable'] = self.tracert_enable
        if self.tracert_num_max is not None:
            result['TracertNumMax'] = self.tracert_num_max
        if self.tracert_timeout is not None:
            result['TracertTimeout'] = self.tracert_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectTimes') is not None:
            self.connect_times = m.get('ConnectTimes')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TracertEnable') is not None:
            self.tracert_enable = m.get('TracertEnable')
        if m.get('TracertNumMax') is not None:
            self.tracert_num_max = m.get('TracertNumMax')
        if m.get('TracertTimeout') is not None:
            self.tracert_timeout = m.get('TracertTimeout')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfStream(TeaModel):
    def __init__(
        self,
        custom_header_content: Dict[str, str] = None,
        player_type: int = None,
        stream_address_type: int = None,
        stream_monitor_timeout: int = None,
        stream_type: int = None,
        target_url: str = None,
        white_list: str = None,
    ):
        # The custom header. Format: JSON map.
        self.custom_header_content = custom_header_content
        # The player. Default value: 12. Valid values:
        # 
        # *   12: VLC
        # *   2: Flash Player
        self.player_type = player_type
        # The address type of the resource. Valid values:
        # 
        # *   1: resource URL
        # *   0 (default): page URL
        self.stream_address_type = stream_address_type
        # The monitoring duration. Unit: seconds. Maximum and default value: 60.
        self.stream_monitor_timeout = stream_monitor_timeout
        # Specifies whether the resource is a video or audio. Valid values: 0: video. 1: audio.
        self.stream_type = stream_type
        # The resource URL of the streaming media.
        self.target_url = target_url
        # The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.player_type is not None:
            result['PlayerType'] = self.player_type
        if self.stream_address_type is not None:
            result['StreamAddressType'] = self.stream_address_type
        if self.stream_monitor_timeout is not None:
            result['StreamMonitorTimeout'] = self.stream_monitor_timeout
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('PlayerType') is not None:
            self.player_type = m.get('PlayerType')
        if m.get('StreamAddressType') is not None:
            self.stream_address_type = m.get('StreamAddressType')
        if m.get('StreamMonitorTimeout') is not None:
            self.stream_monitor_timeout = m.get('StreamMonitorTimeout')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class CreateTimingSyntheticTaskRequestMonitorConfWebsite(TeaModel):
    def __init__(
        self,
        automatic_scrolling: int = None,
        custom_header: int = None,
        custom_header_content: Dict[str, str] = None,
        dnshijack_whitelist: str = None,
        disable_cache: int = None,
        disable_compression: int = None,
        element_blacklist: str = None,
        filter_invalid_ip: int = None,
        flow_hijack_jump_times: int = None,
        flow_hijack_logo: str = None,
        ignore_certificate_error: int = None,
        monitor_timeout: int = None,
        page_tamper: str = None,
        redirection: int = None,
        slow_element_threshold: int = None,
        target_url: str = None,
        verify_string_blacklist: str = None,
        verify_string_whitelist: str = None,
        wait_completion_time: int = None,
    ):
        # Specifies whether to automatically scroll up and down the screen to load a page.
        # 
        # *   0 (default): no
        # *   1: yes
        self.automatic_scrolling = automatic_scrolling
        # Specifies whether to create a custom header.
        # 
        # *   0 (default): No custom header is created.
        # *   1: A custom header is created for the first packet.
        # *   2: A custom header is created for all packets.
        self.custom_header = custom_header
        # The custom header. Format: JSON map.
        self.custom_header_content = custom_header_content
        # If the IP address or CNAME record resolved from a domain name is not included in the DNS whitelist, you cannot access the domain name, or an IP address that belongs to a different domain name is returned. If the IP address or CNAME record is included in the DNS whitelist, DNS hijacking does not occur.
        # 
        # Format: \\<domain name>:\\<objects>. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
        self.dnshijack_whitelist = dnshijack_whitelist
        # Specifies whether to disable caching.
        # 
        # *   0: no
        # *   1 (default): yes
        self.disable_cache = disable_cache
        # Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. Valid values: 0: no. 1: yes. Default value: 0.
        self.disable_compression = disable_compression
        # The elements not to be loaded in the page loading process.
        self.element_blacklist = element_blacklist
        # Specifies whether to exclude invalid IP addresses. Valid values: 0: yes. 1: no. Default value: 0.
        self.filter_invalid_ip = filter_invalid_ip
        # The total number of elements on the page.
        self.flow_hijack_jump_times = flow_hijack_jump_times
        # The keyword that is used to identify hijacking. Asterisks (\\*) are allowed.
        self.flow_hijack_logo = flow_hijack_logo
        # Specifies whether to ignore certificate errors during certificate verification in the SSL handshake process and continue browsing. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_error = ignore_certificate_error
        # The monitoring timeout period. Unit: milliseconds. This parameter is optional. Default value: 20000.
        self.monitor_timeout = monitor_timeout
        # Elements that are not included in the whitelist and appear on the page are tampered with. These elements can be pop-up ads, floating ads, and page redirection.
        # 
        # Format: \\<domain name>:\\<elements>. The elements can be wildcard masks. Separate multiple elements with vertical bars (|). Example: www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg. It indicates that all elements that belong to the www.aliyun.com domain name except the basic documents, /cc/bb/a.gif, and /vv/bb/cc.jpg are tampered with.
        self.page_tamper = page_tamper
        # Specifies whether to continue browsing after redirection. Valid values: 0: no. 1: yes. Default value: 1.
        self.redirection = redirection
        # The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
        self.slow_element_threshold = slow_element_threshold
        # The URL of the website.
        # 
        # This parameter is required.
        self.target_url = target_url
        # An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is in the blacklist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
        self.verify_string_blacklist = verify_string_blacklist
        # An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is not in the whitelist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
        self.verify_string_whitelist = verify_string_whitelist
        # The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
        self.wait_completion_time = wait_completion_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.automatic_scrolling is not None:
            result['AutomaticScrolling'] = self.automatic_scrolling
        if self.custom_header is not None:
            result['CustomHeader'] = self.custom_header
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.dnshijack_whitelist is not None:
            result['DNSHijackWhitelist'] = self.dnshijack_whitelist
        if self.disable_cache is not None:
            result['DisableCache'] = self.disable_cache
        if self.disable_compression is not None:
            result['DisableCompression'] = self.disable_compression
        if self.element_blacklist is not None:
            result['ElementBlacklist'] = self.element_blacklist
        if self.filter_invalid_ip is not None:
            result['FilterInvalidIP'] = self.filter_invalid_ip
        if self.flow_hijack_jump_times is not None:
            result['FlowHijackJumpTimes'] = self.flow_hijack_jump_times
        if self.flow_hijack_logo is not None:
            result['FlowHijackLogo'] = self.flow_hijack_logo
        if self.ignore_certificate_error is not None:
            result['IgnoreCertificateError'] = self.ignore_certificate_error
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.page_tamper is not None:
            result['PageTamper'] = self.page_tamper
        if self.redirection is not None:
            result['Redirection'] = self.redirection
        if self.slow_element_threshold is not None:
            result['SlowElementThreshold'] = self.slow_element_threshold
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.verify_string_blacklist is not None:
            result['VerifyStringBlacklist'] = self.verify_string_blacklist
        if self.verify_string_whitelist is not None:
            result['VerifyStringWhitelist'] = self.verify_string_whitelist
        if self.wait_completion_time is not None:
            result['WaitCompletionTime'] = self.wait_completion_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutomaticScrolling') is not None:
            self.automatic_scrolling = m.get('AutomaticScrolling')
        if m.get('CustomHeader') is not None:
            self.custom_header = m.get('CustomHeader')
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('DNSHijackWhitelist') is not None:
            self.dnshijack_whitelist = m.get('DNSHijackWhitelist')
        if m.get('DisableCache') is not None:
            self.disable_cache = m.get('DisableCache')
        if m.get('DisableCompression') is not None:
            self.disable_compression = m.get('DisableCompression')
        if m.get('ElementBlacklist') is not None:
            self.element_blacklist = m.get('ElementBlacklist')
        if m.get('FilterInvalidIP') is not None:
            self.filter_invalid_ip = m.get('FilterInvalidIP')
        if m.get('FlowHijackJumpTimes') is not None:
            self.flow_hijack_jump_times = m.get('FlowHijackJumpTimes')
        if m.get('FlowHijackLogo') is not None:
            self.flow_hijack_logo = m.get('FlowHijackLogo')
        if m.get('IgnoreCertificateError') is not None:
            self.ignore_certificate_error = m.get('IgnoreCertificateError')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('PageTamper') is not None:
            self.page_tamper = m.get('PageTamper')
        if m.get('Redirection') is not None:
            self.redirection = m.get('Redirection')
        if m.get('SlowElementThreshold') is not None:
            self.slow_element_threshold = m.get('SlowElementThreshold')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('VerifyStringBlacklist') is not None:
            self.verify_string_blacklist = m.get('VerifyStringBlacklist')
        if m.get('VerifyStringWhitelist') is not None:
            self.verify_string_whitelist = m.get('VerifyStringWhitelist')
        if m.get('WaitCompletionTime') is not None:
            self.wait_completion_time = m.get('WaitCompletionTime')
        return self


class CreateTimingSyntheticTaskRequestMonitorConf(TeaModel):
    def __init__(
        self,
        api_http: CreateTimingSyntheticTaskRequestMonitorConfApiHTTP = None,
        file_download: CreateTimingSyntheticTaskRequestMonitorConfFileDownload = None,
        net_dns: CreateTimingSyntheticTaskRequestMonitorConfNetDNS = None,
        net_icmp: CreateTimingSyntheticTaskRequestMonitorConfNetICMP = None,
        net_tcp: CreateTimingSyntheticTaskRequestMonitorConfNetTCP = None,
        stream: CreateTimingSyntheticTaskRequestMonitorConfStream = None,
        website: CreateTimingSyntheticTaskRequestMonitorConfWebsite = None,
    ):
        # The parameters of the HTTP(S) synthetic test.
        self.api_http = api_http
        # The parameters of file downloading.
        self.file_download = file_download
        # The parameters of the DNS synthetic test. This parameter is required if the TaskType parameter is set to 3.
        self.net_dns = net_dns
        # The parameters of the ICMP synthetic test. This parameter is required if the TaskType parameter is set to 1.
        self.net_icmp = net_icmp
        # The parameters of the TCP synthetic test. This parameter is required if the TaskType parameter is set to 2.
        self.net_tcp = net_tcp
        # The parameters of the streaming-media synthetic test.
        self.stream = stream
        # The parameters of the website speed measurement.
        self.website = website

    def validate(self):
        if self.api_http:
            self.api_http.validate()
        if self.file_download:
            self.file_download.validate()
        if self.net_dns:
            self.net_dns.validate()
        if self.net_icmp:
            self.net_icmp.validate()
        if self.net_tcp:
            self.net_tcp.validate()
        if self.stream:
            self.stream.validate()
        if self.website:
            self.website.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_http is not None:
            result['ApiHTTP'] = self.api_http.to_map()
        if self.file_download is not None:
            result['FileDownload'] = self.file_download.to_map()
        if self.net_dns is not None:
            result['NetDNS'] = self.net_dns.to_map()
        if self.net_icmp is not None:
            result['NetICMP'] = self.net_icmp.to_map()
        if self.net_tcp is not None:
            result['NetTCP'] = self.net_tcp.to_map()
        if self.stream is not None:
            result['Stream'] = self.stream.to_map()
        if self.website is not None:
            result['Website'] = self.website.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiHTTP') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfApiHTTP()
            self.api_http = temp_model.from_map(m['ApiHTTP'])
        if m.get('FileDownload') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfFileDownload()
            self.file_download = temp_model.from_map(m['FileDownload'])
        if m.get('NetDNS') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfNetDNS()
            self.net_dns = temp_model.from_map(m['NetDNS'])
        if m.get('NetICMP') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfNetICMP()
            self.net_icmp = temp_model.from_map(m['NetICMP'])
        if m.get('NetTCP') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfNetTCP()
            self.net_tcp = temp_model.from_map(m['NetTCP'])
        if m.get('Stream') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfStream()
            self.stream = temp_model.from_map(m['Stream'])
        if m.get('Website') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConfWebsite()
            self.website = temp_model.from_map(m['Website'])
        return self


class CreateTimingSyntheticTaskRequestMonitors(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        client_type: int = None,
        operator_code: str = None,
    ):
        # The city code.
        # 
        # This parameter is required.
        self.city_code = city_code
        # The client type of the detection point. Valid values:
        # 
        # - 1: data center
        # - 2: Internet
        # - 3: mobile device
        # - 4: ECS instance
        # 
        # This parameter is required.
        self.client_type = client_type
        # The carrier code.
        # 
        # This parameter is required.
        self.operator_code = operator_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.operator_code is not None:
            result['OperatorCode'] = self.operator_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('OperatorCode') is not None:
            self.operator_code = m.get('OperatorCode')
        return self


class CreateTimingSyntheticTaskRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateTimingSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        available_assertions: List[CreateTimingSyntheticTaskRequestAvailableAssertions] = None,
        common_setting: CreateTimingSyntheticTaskRequestCommonSetting = None,
        custom_period: CreateTimingSyntheticTaskRequestCustomPeriod = None,
        frequency: str = None,
        monitor_category: int = None,
        monitor_conf: CreateTimingSyntheticTaskRequestMonitorConf = None,
        monitors: List[CreateTimingSyntheticTaskRequestMonitors] = None,
        name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[CreateTimingSyntheticTaskRequestTags] = None,
        task_type: int = None,
    ):
        # The list of assertions.
        self.available_assertions = available_assertions
        # The general settings.
        self.common_setting = common_setting
        # The general settings.
        self.custom_period = custom_period
        # The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
        # 
        # This parameter is required.
        self.frequency = frequency
        # The detection point type. Valid values:
        # 
        # - 1: PC
        # - 2: mobile device
        # 
        # This parameter is required.
        self.monitor_category = monitor_category
        # The monitoring configurations.
        # 
        # This parameter is required.
        self.monitor_conf = monitor_conf
        # The list of detection points.
        # 
        # This parameter is required.
        self.monitors = monitors
        # The name of the task.
        # 
        # This parameter is required.
        self.name = name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The parameter is optional.
        self.resource_group_id = resource_group_id
        # The tag list.
        self.tags = tags
        # The type of the task. Valid values:
        # 
        # 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed measurement. 6: file download.
        # 
        # This parameter is required.
        self.task_type = task_type

    def validate(self):
        if self.available_assertions:
            for k in self.available_assertions:
                if k:
                    k.validate()
        if self.common_setting:
            self.common_setting.validate()
        if self.custom_period:
            self.custom_period.validate()
        if self.monitor_conf:
            self.monitor_conf.validate()
        if self.monitors:
            for k in self.monitors:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableAssertions'] = []
        if self.available_assertions is not None:
            for k in self.available_assertions:
                result['AvailableAssertions'].append(k.to_map() if k else None)
        if self.common_setting is not None:
            result['CommonSetting'] = self.common_setting.to_map()
        if self.custom_period is not None:
            result['CustomPeriod'] = self.custom_period.to_map()
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.monitor_category is not None:
            result['MonitorCategory'] = self.monitor_category
        if self.monitor_conf is not None:
            result['MonitorConf'] = self.monitor_conf.to_map()
        result['Monitors'] = []
        if self.monitors is not None:
            for k in self.monitors:
                result['Monitors'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.available_assertions = []
        if m.get('AvailableAssertions') is not None:
            for k in m.get('AvailableAssertions'):
                temp_model = CreateTimingSyntheticTaskRequestAvailableAssertions()
                self.available_assertions.append(temp_model.from_map(k))
        if m.get('CommonSetting') is not None:
            temp_model = CreateTimingSyntheticTaskRequestCommonSetting()
            self.common_setting = temp_model.from_map(m['CommonSetting'])
        if m.get('CustomPeriod') is not None:
            temp_model = CreateTimingSyntheticTaskRequestCustomPeriod()
            self.custom_period = temp_model.from_map(m['CustomPeriod'])
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('MonitorCategory') is not None:
            self.monitor_category = m.get('MonitorCategory')
        if m.get('MonitorConf') is not None:
            temp_model = CreateTimingSyntheticTaskRequestMonitorConf()
            self.monitor_conf = temp_model.from_map(m['MonitorConf'])
        self.monitors = []
        if m.get('Monitors') is not None:
            for k in m.get('Monitors'):
                temp_model = CreateTimingSyntheticTaskRequestMonitors()
                self.monitors.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = CreateTimingSyntheticTaskRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateTimingSyntheticTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        available_assertions_shrink: str = None,
        common_setting_shrink: str = None,
        custom_period_shrink: str = None,
        frequency: str = None,
        monitor_category: int = None,
        monitor_conf_shrink: str = None,
        monitors_shrink: str = None,
        name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags_shrink: str = None,
        task_type: int = None,
    ):
        # The list of assertions.
        self.available_assertions_shrink = available_assertions_shrink
        # The general settings.
        self.common_setting_shrink = common_setting_shrink
        # The general settings.
        self.custom_period_shrink = custom_period_shrink
        # The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
        # 
        # This parameter is required.
        self.frequency = frequency
        # The detection point type. Valid values:
        # 
        # - 1: PC
        # - 2: mobile device
        # 
        # This parameter is required.
        self.monitor_category = monitor_category
        # The monitoring configurations.
        # 
        # This parameter is required.
        self.monitor_conf_shrink = monitor_conf_shrink
        # The list of detection points.
        # 
        # This parameter is required.
        self.monitors_shrink = monitors_shrink
        # The name of the task.
        # 
        # This parameter is required.
        self.name = name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The parameter is optional.
        self.resource_group_id = resource_group_id
        # The tag list.
        self.tags_shrink = tags_shrink
        # The type of the task. Valid values:
        # 
        # 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed measurement. 6: file download.
        # 
        # This parameter is required.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_assertions_shrink is not None:
            result['AvailableAssertions'] = self.available_assertions_shrink
        if self.common_setting_shrink is not None:
            result['CommonSetting'] = self.common_setting_shrink
        if self.custom_period_shrink is not None:
            result['CustomPeriod'] = self.custom_period_shrink
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.monitor_category is not None:
            result['MonitorCategory'] = self.monitor_category
        if self.monitor_conf_shrink is not None:
            result['MonitorConf'] = self.monitor_conf_shrink
        if self.monitors_shrink is not None:
            result['Monitors'] = self.monitors_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableAssertions') is not None:
            self.available_assertions_shrink = m.get('AvailableAssertions')
        if m.get('CommonSetting') is not None:
            self.common_setting_shrink = m.get('CommonSetting')
        if m.get('CustomPeriod') is not None:
            self.custom_period_shrink = m.get('CustomPeriod')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('MonitorCategory') is not None:
            self.monitor_category = m.get('MonitorCategory')
        if m.get('MonitorConf') is not None:
            self.monitor_conf_shrink = m.get('MonitorConf')
        if m.get('Monitors') is not None:
            self.monitors_shrink = m.get('Monitors')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateTimingSyntheticTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        status: str = None,
        task_id: str = None,
    ):
        # The task status. Valid values:
        # 
        # - INIT: The task is in the initial state.
        # - RELEASE: The task is being parsed.
        # - RUNNING: The task is running.
        # - STOP: The task is suspended.
        # - SYSTEM_STOP: The task is suspended by the system.
        # - CANCEL: The task is canceled.
        # - SYSTEM_CANCEL: The task is canceled by the system.
        # - DONE: The task is complete.
        self.status = status
        # The ID of the synthetic monitoring task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateTimingSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: CreateTimingSyntheticTaskResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned. The status code 200 indicates that the request was successful.
        self.code = code
        # The struct returned.
        self.data = data
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateTimingSyntheticTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTimingSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTimingSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTimingSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWebhookRequest(TeaModel):
    def __init__(
        self,
        body: str = None,
        contact_name: str = None,
        http_headers: str = None,
        http_params: str = None,
        method: str = None,
        recover_body: str = None,
        region_id: str = None,
        url: str = None,
    ):
        # The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
        # 
        # This parameter is required.
        self.body = body
        # The name of the contact.
        # 
        # This parameter is required.
        self.contact_name = contact_name
        # The HTTP request header.
        self.http_headers = http_headers
        # The parameters in the HTTP request.
        self.http_params = http_params
        # The HTTP request method.
        # 
        # *   `Get`
        # *   `Post`
        # 
        # This parameter is required.
        self.method = method
        # The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
        self.recover_body = recover_body
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The URL of the request **method**.
        # 
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.http_headers is not None:
            result['HttpHeaders'] = self.http_headers
        if self.http_params is not None:
            result['HttpParams'] = self.http_params
        if self.method is not None:
            result['Method'] = self.method
        if self.recover_body is not None:
            result['RecoverBody'] = self.recover_body
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('HttpHeaders') is not None:
            self.http_headers = m.get('HttpHeaders')
        if m.get('HttpParams') is not None:
            self.http_params = m.get('HttpParams')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('RecoverBody') is not None:
            self.recover_body = m.get('RecoverBody')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateWebhookResponseBody(TeaModel):
    def __init__(
        self,
        contact_id: str = None,
        request_id: str = None,
    ):
        # The ID of the contact for webhook alerts.
        self.contact_id = contact_id
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DelAuthTokenRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DelAuthTokenResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DelAuthTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DelAuthTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DelAuthTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        environment_id: str = None,
        force: bool = None,
        region_id: str = None,
        release_name: str = None,
    ):
        # The name of the add-on. If you assign a value to AddonName, the ReleaseName parameter is ignored and all AddonReleases that belong to the same add-on are deleted.
        self.addon_name = addon_name
        # Environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # Whether to be forcibly deleted. The default value is false.
        self.force = force
        # The region ID.
        self.region_id = region_id
        # Name of Release.
        # 
        # This parameter is required.
        self.release_name = release_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.force is not None:
            result['Force'] = self.force
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        return self


class DeleteAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code: 200 indicates success.
        self.code = code
        # Return a message.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the alert rule was deleted. Valid values:
        # 
        # *   `true`: The alert rule was deleted.
        # *   `false`: The alert rule failed to be deleted.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertContactRequest(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
        region_id: str = None,
    ):
        # The ID of the alert contact.
        # 
        # This parameter is required.
        self.contact_id = contact_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteAlertContactResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.is_success = is_success
        # The ID of the request. You can query logs and troubleshoot issues based on the ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAlertContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_id: int = None,
        region_id: str = None,
    ):
        # The ID of the alert contact group.
        # 
        # This parameter is required.
        self.contact_group_id = contact_group_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteAlertContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.is_success = is_success
        # The ID of the request, which is used to locate and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAlertContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
    ):
        # The alert rule ID.
        # 
        # For more information about how to obtain the ID of an alert rule, see [GetAlertRules](https://help.aliyun.com/document_detail/2612348.html).
        # 
        # This parameter is required.
        self.alert_id = alert_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        return self


class DeleteAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.is_success = is_success
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_ids: str = None,
        region_id: str = None,
    ):
        # The IDs of the alert rules that you want to delete. The value is a JSON array, for example, `[123, 234]`. You can call the SearchAlertRules operation and view the `Id` parameter in the response to obtain the alert rule ID. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
        # 
        # This parameter is required.
        self.alert_ids = alert_ids
        # The region ID. Default value: `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_ids is not None:
            result['AlertIds'] = self.alert_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertIds') is not None:
            self.alert_ids = m.get('AlertIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the alert rule was deleted.
        # 
        # *   `true`: The alert rule was deleted.
        # *   `false`: The alert rule failed to be deleted.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAppListRequest(TeaModel):
    def __init__(
        self,
        pids: List[str] = None,
        region_id: str = None,
    ):
        # The PIDs of the applications monitored by ARMS Application Monitoring.
        self.pids = pids
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pids is not None:
            result['Pids'] = self.pids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pids') is not None:
            self.pids = m.get('Pids')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteAppListResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
        self.code = code
        # The returned message.
        self.data = data
        # The error message returned when the request parameters are invalid.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the specified applications are deleted. Valid values:
        # 
        # *   `true`: The applications are deleted.
        # *   `false`: The applications failed to be deleted.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteAppListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAppListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAppListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCmsExporterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.cluster_id = cluster_id
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCmsExporterResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCmsExporterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCmsExporterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCmsExporterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactRequest(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
    ):
        # The ID of the alert contact.
        # 
        # This parameter is required.
        self.contact_id = contact_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        return self


class DeleteContactResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the alert contact is deleted. Valid values:
        # 
        # *   `true`: The alert contact is deleted.
        # *   `false`: The alert contact is not deleted.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_id: int = None,
    ):
        # The ID of the alert contact group.
        # 
        # This parameter is required.
        self.contact_group_id = contact_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        return self


class DeleteContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the alert contact group was deleted. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.is_success = is_success
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDispatchRuleRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        region_id: str = None,
    ):
        # The ID of the dispatch policy.
        # 
        # This parameter is required.
        self.id = id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDispatchRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDispatchRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDispatchRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDispatchRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvCustomJobRequest(TeaModel):
    def __init__(
        self,
        custom_job_name: str = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The name of the custom job.
        # 
        # This parameter is required.
        self.custom_job_name = custom_job_name
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_job_name is not None:
            result['CustomJobName'] = self.custom_job_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomJobName') is not None:
            self.custom_job_name = m.get('CustomJobName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEnvCustomJobResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnvCustomJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvCustomJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvCustomJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvPodMonitorRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        namespace: str = None,
        pod_monitor_name: str = None,
        region_id: str = None,
    ):
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The namespace where the PodMonitor is located.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The name of the PodMonitor.
        # 
        # This parameter is required.
        self.pod_monitor_name = pod_monitor_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod_monitor_name is not None:
            result['PodMonitorName'] = self.pod_monitor_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PodMonitorName') is not None:
            self.pod_monitor_name = m.get('PodMonitorName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEnvPodMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnvPodMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvPodMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvPodMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvServiceMonitorRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        namespace: str = None,
        region_id: str = None,
        service_monitor_name: str = None,
    ):
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The namespace where the ServiceMonitor is located.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The name of the ServiceMonitor.
        # 
        # This parameter is required.
        self.service_monitor_name = service_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service_monitor_name is not None:
            result['ServiceMonitorName'] = self.service_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServiceMonitorName') is not None:
            self.service_monitor_name = m.get('ServiceMonitorName')
        return self


class DeleteEnvServiceMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnvServiceMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvServiceMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvServiceMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvironmentRequest(TeaModel):
    def __init__(
        self,
        delete_prom_instance: bool = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # Specifies whether to delete the related Prometheus instance.
        self.delete_prom_instance = delete_prom_instance
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_prom_instance is not None:
            result['DeletePromInstance'] = self.delete_prom_instance
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeletePromInstance') is not None:
            self.delete_prom_instance = m.get('DeletePromInstance')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        feature_name: str = None,
        region_id: str = None,
    ):
        # The ID of the environment.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The feature name. Valid values: app-agent-pilot, metric-agent, ebpf-agent, and service-check.
        # 
        # This parameter is required.
        self.feature_name = feature_name
        # The region ID. Valid values: cn-beijing and cn-hangzhou.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.feature_name is not None:
            result['FeatureName'] = self.feature_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('FeatureName') is not None:
            self.feature_name = m.get('FeatureName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned message.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventBridgeIntegrationRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # Required. The ID of the EventBridge notification integration. You can call the **ListEventBridgeIntegrations** operation to query the ID.
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteEventBridgeIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the EventBridge integration is deleted.
        # 
        # *   `true`
        # *   `false`
        self.is_success = is_success
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEventBridgeIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEventBridgeIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventBridgeIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGrafanaResourceRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the cluster.
        # 
        # This parameter is required.
        self.cluster_name = cluster_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteGrafanaResourceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The message returned.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteGrafanaResourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGrafanaResourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGrafanaResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGrafanaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        grafana_workspace_id: str = None,
        region_id: str = None,
    ):
        # The ID of the workspace.
        # 
        # This parameter is required.
        self.grafana_workspace_id = grafana_workspace_id
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteGrafanaWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # Indicates whether the workspace was deleted. Valid values:
        # 
        # *   true
        # *   false
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DeleteGrafanaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGrafanaWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGrafanaWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIMRobotRequest(TeaModel):
    def __init__(
        self,
        robot_id: int = None,
    ):
        # The ID of the IM chatbot.
        # 
        # This parameter is required.
        self.robot_id = robot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.robot_id is not None:
            result['RobotId'] = self.robot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RobotId') is not None:
            self.robot_id = m.get('RobotId')
        return self


class DeleteIMRobotResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.is_success = is_success
        # The request ID. You can use the ID to find logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteIMRobotResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIMRobotResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIMRobotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        integration: str = None,
        region_id: str = None,
    ):
        # The ID of the ACK cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
        # 
        # This parameter is required.
        self.integration = integration
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.integration is not None:
            result['Integration'] = self.integration
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Integration') is not None:
            self.integration = m.get('Integration')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # Indicates whether the call was successful.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteIntegrationsRequest(TeaModel):
    def __init__(
        self,
        integration_id: int = None,
    ):
        # The ID of the alert integration.
        # 
        # This parameter is required.
        self.integration_id = integration_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        return self


class DeleteIntegrationsResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the alert integration is deleted. Valid values:
        # 
        # *   true
        # *   false
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteIntegrationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteIntegrationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteIntegrationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNotificationPolicyRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the notification policy.
        # 
        # For more information about how to obtain the ID of a notification policy, see [ListNotificationPolicies](https://help.aliyun.com/document_detail/2612375.html).
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteNotificationPolicyResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # The ID of the request.
        self.is_success = is_success
        # The ID of the notification policy.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNotificationPolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteNotificationPolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNotificationPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrometheusAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        cluster_id: str = None,
    ):
        # The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.
        # 
        # This parameter is required.
        self.alert_id = alert_id
        # The cluster ID of the Prometheus monitoring alarm rule.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DeletePrometheusAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # More Information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the alert rule was deleted. Valid values:
        # 
        # *   `true`: The alert rule was deleted.
        # *   `false`: The alert rule failed to be deleted.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeletePrometheusAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrometheusAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrometheusAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        global_view_cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the global aggregation instance.
        # 
        # This parameter is required.
        self.global_view_cluster_id = global_view_cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeletePrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The response parameters in the JSON format.
        self.data = data
        # Additional Message.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrometheusIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        instance_id: int = None,
        integration_type: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the exporter.
        self.instance_id = instance_id
        # The type of the integration.
        # 
        # This parameter is required.
        self.integration_type = integration_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeletePrometheusIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # success or an error message.
        self.data = data
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePrometheusIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrometheusIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrometheusIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrometheusMonitoringRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        monitoring_name: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the monitoring configuration.
        # 
        # This parameter is required.
        self.monitoring_name = monitoring_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the monitoring configuration. 
        # Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
        # Valid values for a Prometheus instance for ECS: customJob and probe.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.monitoring_name is not None:
            result['MonitoringName'] = self.monitoring_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MonitoringName') is not None:
            self.monitoring_name = m.get('MonitoringName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeletePrometheusMonitoringResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePrometheusMonitoringResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePrometheusMonitoringResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrometheusMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRetcodeAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        pid: str = None,
        region_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The process identifier (PID) of the application.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteRetcodeAppResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # Indicates whether the Browser Monitoring task was deleted. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.data = data
        # Additional information. The value description is as follows:
        # - If the request is normal, return success.
        # - If the request is abnormal, return specific abnormal information.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Whether the operation was successful:
        # - `true`: The operation was successful
        # - `false`: The operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRetcodeAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRetcodeAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRetcodeAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRumAppRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        app_id: str = None,
        real_region_id: str = None,
        region_id: str = None,
    ):
        # The group where the application resides.
        self.app_group = app_group
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        self.real_region_id = real_region_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.real_region_id is not None:
            result['RealRegionId'] = self.real_region_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('RealRegionId') is not None:
            self.real_region_id = m.get('RealRegionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteRumAppResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        resource_group_id: str = None,
        result: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The message that appears when the application is deleted.
        self.result = result
        # Indicates whether the request is successful. Valid values: true and false.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRumAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRumAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRumAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRumUploadFileRequest(TeaModel):
    def __init__(
        self,
        batch_items: str = None,
        file_name: str = None,
        pid: str = None,
        region_id: str = None,
        uuid: str = None,
        version_id: str = None,
    ):
        # Information of files to be deleted in JSON array format. If a single file needs to be deleted, this field should be left empty. If multiple files need to be deleted, just fill in this field.
        self.batch_items = batch_items
        # The file name, with the extension.
        self.file_name = file_name
        # The application ID.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The file ID.
        self.uuid = uuid
        # The version number of the file.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_items is not None:
            result['BatchItems'] = self.batch_items
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchItems') is not None:
            self.batch_items = m.get('BatchItems')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class DeleteRumUploadFileResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # Indicates whether the file is deleted. If the file is deleted, "success" is returned.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request is successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRumUploadFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRumUploadFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRumUploadFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteScenarioRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        scenario_id: int = None,
    ):
        # The ID of the region.
        self.region_id = region_id
        # The ID of the business monitoring job. You can obtain the ID by calling the ListScenario operation.
        # 
        # This parameter is required.
        self.scenario_id = scenario_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scenario_id is not None:
            result['ScenarioId'] = self.scenario_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScenarioId') is not None:
            self.scenario_id = m.get('ScenarioId')
        return self


class DeleteScenarioResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: bool = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request is successful.
        # 
        # *   `true`: successful
        # *   `false`: failed
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DeleteScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSilencePolicyRequest(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        # The ID of the silence policy.
        # 
        # For more information about how to obtain the ID of a silence policy, see [ListSilencePolicies](https://help.aliyun.com/document_detail/2612383.html).
        # 
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteSilencePolicyResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the silence policy was deleted successfully. Valid values:
        # 
        # *   `true`: The silence policy was deleted successfully.
        # *   `false`: The silence policy failed to be deleted.
        self.is_success = is_success
        # The operation that you want to perform. Set the value to **DeleteSilencePolicy**.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSilencePolicyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSilencePolicyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSilencePolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSourceMapRequest(TeaModel):
    def __init__(
        self,
        fid_list: List[str] = None,
        pid: str = None,
        region_id: str = None,
    ):
        # The IDs of the SourceMap files.
        # 
        # This parameter is required.
        self.fid_list = fid_list
        # The process identifier (PID) of the application.
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fid_list is not None:
            result['FidList'] = self.fid_list
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FidList') is not None:
            self.fid_list = m.get('FidList')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteSourceMapShrinkRequest(TeaModel):
    def __init__(
        self,
        fid_list_shrink: str = None,
        pid: str = None,
        region_id: str = None,
    ):
        # The IDs of the SourceMap files.
        # 
        # This parameter is required.
        self.fid_list_shrink = fid_list_shrink
        # The process identifier (PID) of the application.
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fid_list_shrink is not None:
            result['FidList'] = self.fid_list_shrink
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FidList') is not None:
            self.fid_list_shrink = m.get('FidList')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteSourceMapResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the SourceMap files are deleted. Valid values:
        # 
        # *   success: The SourceMap files are deleted.
        # *   false: The SourceMap files fail to be deleted.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSourceMapResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSourceMapResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSourceMapResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_ids: List[str] = None,
    ):
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The task IDs.
        # 
        # This parameter is required.
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DeleteSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the specified tasks are deleted.
        # 
        # *   `true`: The tasks are deleted.
        # *   `false`: The tasks fail to be deleted.
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DeleteSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTimingSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        task_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The ID of the synthetic monitoring task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DeleteTimingSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # Indicates whether the synthetic monitoring task was deleted. true: The synthetic monitoring task was deleted. false: The synthetic monitoring task failed to be deleted.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTimingSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTimingSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTimingSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTraceAppRequestDeleteReasonReasonIds(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the reason for deletion.
        self.id = id
        # A description of the reason for removal.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DeleteTraceAppRequestDeleteReason(TeaModel):
    def __init__(
        self,
        reason_ids: List[DeleteTraceAppRequestDeleteReasonReasonIds] = None,
        remark: str = None,
    ):
        # Reasons Ids.
        self.reason_ids = reason_ids
        # Additional remarks when none of the reasons for removal provided are met.
        self.remark = remark

    def validate(self):
        if self.reason_ids:
            for k in self.reason_ids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ReasonIds'] = []
        if self.reason_ids is not None:
            for k in self.reason_ids:
                result['ReasonIds'].append(k.to_map() if k else None)
        if self.remark is not None:
            result['Remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.reason_ids = []
        if m.get('ReasonIds') is not None:
            for k in m.get('ReasonIds'):
                temp_model = DeleteTraceAppRequestDeleteReasonReasonIds()
                self.reason_ids.append(temp_model.from_map(k))
        if m.get('Remark') is not None:
            self.remark = m.get('Remark')
        return self


class DeleteTraceAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        delete_reason: DeleteTraceAppRequestDeleteReason = None,
        pid: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The reason(s) to delete application.
        self.delete_reason = delete_reason
        # The PID of the application. For more information about how to query the PID, see [QueryMetricByPage](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region in which the application is located.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html). Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: frontend monitoring
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        if self.delete_reason:
            self.delete_reason.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.delete_reason is not None:
            result['DeleteReason'] = self.delete_reason.to_map()
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DeleteReason') is not None:
            temp_model = DeleteTraceAppRequestDeleteReason()
            self.delete_reason = temp_model.from_map(m['DeleteReason'])
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeleteTraceAppShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        delete_reason_shrink: str = None,
        pid: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html).
        # 
        # This parameter is required.
        self.app_id = app_id
        # The reason(s) to delete application.
        self.delete_reason_shrink = delete_reason_shrink
        # The PID of the application. For more information about how to query the PID, see [QueryMetricByPage](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region in which the application is located.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html). Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: frontend monitoring
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.delete_reason_shrink is not None:
            result['DeleteReason'] = self.delete_reason_shrink
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DeleteReason') is not None:
            self.delete_reason_shrink = m.get('DeleteReason')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeleteTraceAppResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The response in JSON format, including the HTTP status code, error code, response message, and trace ID.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # true: The request was successful.
        # 
        # false: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTraceAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTraceAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTraceAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWebhookContactRequest(TeaModel):
    def __init__(
        self,
        webhook_id: int = None,
    ):
        # The ID of the webhook alert contact.
        # 
        # This parameter is required.
        self.webhook_id = webhook_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.webhook_id is not None:
            result['WebhookId'] = self.webhook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WebhookId') is not None:
            self.webhook_id = m.get('WebhookId')
        return self


class DeleteWebhookContactResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the webhook alert contact was deleted.
        # 
        # *   `true`
        # *   `false`
        self.is_success = is_success
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteWebhookContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWebhookContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWebhookContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonMetricsRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        aliyun_lang: str = None,
        environment_type: str = None,
        name: str = None,
        region_id: str = None,
    ):
        # The version of the component.
        self.addon_version = addon_version
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The environment.
        self.environment_type = environment_type
        # The name of the component.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeAddonMetricsResponseBodyDataLabels(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        source: str = None,
    ):
        # The description of the tag.
        self.description = description
        # The tag key.
        self.key = key
        # The source of the tag.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class DescribeAddonMetricsResponseBodyDataMetricsLabels(TeaModel):
    def __init__(
        self,
        description: str = None,
        key: str = None,
        source: str = None,
    ):
        # The description of the tag.
        self.description = description
        # The tag key.
        self.key = key
        # The source of the tag.
        self.source = source

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.key is not None:
            result['Key'] = self.key
        if self.source is not None:
            result['Source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        return self


class DescribeAddonMetricsResponseBodyDataMetrics(TeaModel):
    def __init__(
        self,
        description: str = None,
        labels: List[DescribeAddonMetricsResponseBodyDataMetricsLabels] = None,
        metric: str = None,
        type: str = None,
        unit: str = None,
    ):
        # The description of the metric.
        self.description = description
        # The tags.
        self.labels = labels
        # The metric name.
        self.metric = metric
        # The type of the metric.
        self.type = type
        # The unit of the metric.
        self.unit = unit

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.type is not None:
            result['Type'] = self.type
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeAddonMetricsResponseBodyDataMetricsLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class DescribeAddonMetricsResponseBodyData(TeaModel):
    def __init__(
        self,
        group: str = None,
        labels: List[DescribeAddonMetricsResponseBodyDataLabels] = None,
        metrics: List[DescribeAddonMetricsResponseBodyDataMetrics] = None,
    ):
        # The metric group.
        self.group = group
        # The tags.
        self.labels = labels
        # The metrics.
        self.metrics = metrics

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['Group'] = self.group
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Group') is not None:
            self.group = m.get('Group')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeAddonMetricsResponseBodyDataLabels()
                self.labels.append(temp_model.from_map(k))
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeAddonMetricsResponseBodyDataMetrics()
                self.metrics.append(temp_model.from_map(k))
        return self


class DescribeAddonMetricsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[DescribeAddonMetricsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The metric details.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeAddonMetricsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeAddonMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
        release_name: str = None,
    ):
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id
        # The name of the add-on release.
        # 
        # This parameter is required.
        self.release_name = release_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        return self


class DescribeAddonReleaseResponseBodyDataReleaseConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        # The first transition time.
        self.first_transition_time = first_transition_time
        # The last transition time.
        self.last_transition_time = last_transition_time
        # The returned message.
        self.message = message
        # The reason for the failure.
        self.reason = reason
        # The status of the phase.
        self.status = status
        # The type of the phase.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['FirstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['LastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['Message'] = self.message
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstTransitionTime') is not None:
            self.first_transition_time = m.get('FirstTransitionTime')
        if m.get('LastTransitionTime') is not None:
            self.last_transition_time = m.get('LastTransitionTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAddonReleaseResponseBodyDataRelease(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[DescribeAddonReleaseResponseBodyDataReleaseConditions] = None,
        create_time: str = None,
        dashboard_count: int = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
    ):
        # The name of the add-on.
        self.addon_name = addon_name
        # The number of alert rules.
        self.alert_rule_count = alert_rule_count
        # The installation phase.
        self.conditions = conditions
        # The time when the add-on was created.
        self.create_time = create_time
        # The number of dashboards.
        self.dashboard_count = dashboard_count
        # The environment ID.
        self.environment_id = environment_id
        # The number of exporters.
        self.exporter_count = exporter_count
        # Indicates whether the configuration is available.
        self.have_config = have_config
        # The user ID.
        self.install_user_id = install_user_id
        # The language.
        self.language = language
        # Indicates whether the component is fully managed.
        self.managed = managed
        # The region ID.
        self.region_id = region_id
        # The release ID after installation.
        self.release_id = release_id
        # The name of the release.
        self.release_name = release_name
        # The scenario.
        self.scene = scene
        # The status.
        self.status = status
        # The time when the add-on was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id
        # The version of the add-on.
        self.version = version

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['AlertRuleCount'] = self.alert_rule_count
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dashboard_count is not None:
            result['DashboardCount'] = self.dashboard_count
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['ExporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['HaveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['InstallUserId'] = self.install_user_id
        if self.language is not None:
            result['Language'] = self.language
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_id is not None:
            result['ReleaseId'] = self.release_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserID'] = self.user_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AlertRuleCount') is not None:
            self.alert_rule_count = m.get('AlertRuleCount')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = DescribeAddonReleaseResponseBodyDataReleaseConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DashboardCount') is not None:
            self.dashboard_count = m.get('DashboardCount')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('ExporterCount') is not None:
            self.exporter_count = m.get('ExporterCount')
        if m.get('HaveConfig') is not None:
            self.have_config = m.get('HaveConfig')
        if m.get('InstallUserId') is not None:
            self.install_user_id = m.get('InstallUserId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseId') is not None:
            self.release_id = m.get('ReleaseId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserID') is not None:
            self.user_id = m.get('UserID')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeAddonReleaseResponseBodyData(TeaModel):
    def __init__(
        self,
        config: str = None,
        release: DescribeAddonReleaseResponseBodyDataRelease = None,
    ):
        # The configuration information of the add-on release.
        self.config = config
        # The release information.
        self.release = release

    def validate(self):
        if self.release:
            self.release.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.release is not None:
            result['Release'] = self.release.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Release') is not None:
            temp_model = DescribeAddonReleaseResponseBodyDataRelease()
            self.release = temp_model.from_map(m['Release'])
        return self


class DescribeAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DescribeAddonReleaseResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The release information.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeAddonReleaseResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContactGroupsRequest(TeaModel):
    def __init__(
        self,
        contact_group_name: str = None,
        group_ids: str = None,
        is_detail: bool = None,
        page: int = None,
        region_id: str = None,
        size: int = None,
    ):
        # The name of the alert contact group.
        self.contact_group_name = contact_group_name
        # The ID of the alert contact group.
        self.group_ids = group_ids
        # Specifies whether to return all the alert contacts in the queried alert contact group. Valid values:
        # 
        # *   `false`
        # *   `true`
        self.is_detail = is_detail
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The region ID.
        self.region_id = region_id
        # The number of alert contact groups displayed on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.group_ids is not None:
            result['GroupIds'] = self.group_ids
        if self.is_detail is not None:
            result['IsDetail'] = self.is_detail
        if self.page is not None:
            result['Page'] = self.page
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('GroupIds') is not None:
            self.group_ids = m.get('GroupIds')
        if m.get('IsDetail') is not None:
            self.is_detail = m.get('IsDetail')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts(TeaModel):
    def __init__(
        self,
        arms_contact_id: int = None,
        contact_id: float = None,
        contact_name: str = None,
        email: str = None,
        phone: str = None,
    ):
        # The ID of the alert contact.
        self.arms_contact_id = arms_contact_id
        # The ID of the alert contact.
        self.contact_id = contact_id
        # The name of the alert contact.
        self.contact_name = contact_name
        # The email address of the alert contact.
        self.email = email
        # The mobile number of the alert contact.
        self.phone = phone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arms_contact_id is not None:
            result['ArmsContactId'] = self.arms_contact_id
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.email is not None:
            result['Email'] = self.email
        if self.phone is not None:
            result['Phone'] = self.phone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArmsContactId') is not None:
            self.arms_contact_id = m.get('ArmsContactId')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        return self


class DescribeContactGroupsResponseBodyPageBeanAlertContactGroups(TeaModel):
    def __init__(
        self,
        arms_contact_group_id: int = None,
        contact_group_id: float = None,
        contact_group_name: str = None,
        contacts: List[DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts] = None,
    ):
        # The ID of the alert contact group.
        self.arms_contact_group_id = arms_contact_group_id
        # The ID of the alert contact group.
        self.contact_group_id = contact_group_id
        # The name of the alert contact group.
        self.contact_group_name = contact_group_name
        # The contact information. If the **IsDetail** parameter is set to `false`, no **contact** information is displayed.
        self.contacts = contacts

    def validate(self):
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arms_contact_group_id is not None:
            result['ArmsContactGroupId'] = self.arms_contact_group_id
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        result['Contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['Contacts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArmsContactGroupId') is not None:
            self.arms_contact_group_id = m.get('ArmsContactGroupId')
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        self.contacts = []
        if m.get('Contacts') is not None:
            for k in m.get('Contacts'):
                temp_model = DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts()
                self.contacts.append(temp_model.from_map(k))
        return self


class DescribeContactGroupsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        alert_contact_groups: List[DescribeContactGroupsResponseBodyPageBeanAlertContactGroups] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The name of the alert contact group.
        self.alert_contact_groups = alert_contact_groups
        # The page number of the returned page.
        self.page = page
        # The number of alert contact groups displayed on each page.
        self.size = size
        # The total number of alert contact groups.
        self.total = total

    def validate(self):
        if self.alert_contact_groups:
            for k in self.alert_contact_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertContactGroups'] = []
        if self.alert_contact_groups is not None:
            for k in self.alert_contact_groups:
                result['AlertContactGroups'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_contact_groups = []
        if m.get('AlertContactGroups') is not None:
            for k in m.get('AlertContactGroups'):
                temp_model = DescribeContactGroupsResponseBodyPageBeanAlertContactGroups()
                self.alert_contact_groups.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeContactGroupsResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: DescribeContactGroupsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The objects that were returned.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = DescribeContactGroupsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContactGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeContactGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContactGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContactsRequest(TeaModel):
    def __init__(
        self,
        contact_ids: str = None,
        contact_name: str = None,
        email: str = None,
        page: int = None,
        phone: str = None,
        region_id: str = None,
        size: int = None,
        verbose: str = None,
    ):
        # The ID of the alert contact that you want to query. Separate multiple contact IDs with spaces.
        self.contact_ids = contact_ids
        # The name of the alert contact.
        self.contact_name = contact_name
        # The email address of the alert contact.
        self.email = email
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The mobile number of the alert contact.
        self.phone = phone
        # The region ID.
        self.region_id = region_id
        # The number of alert contacts to return on each page.
        # 
        # This parameter is required.
        self.size = size
        # Specifies whether to return redundant information.
        self.verbose = verbose

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.email is not None:
            result['Email'] = self.email
        if self.page is not None:
            result['Page'] = self.page
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.size is not None:
            result['Size'] = self.size
        if self.verbose is not None:
            result['Verbose'] = self.verbose
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Verbose') is not None:
            self.verbose = m.get('Verbose')
        return self


class DescribeContactsResponseBodyPageBeanAlertContacts(TeaModel):
    def __init__(
        self,
        arms_contact_id: int = None,
        contact_id: float = None,
        contact_name: str = None,
        email: str = None,
        is_email_verify: bool = None,
        is_verify: bool = None,
        phone: str = None,
        reissue_send_notice: int = None,
    ):
        # The ID of the alert contact.
        self.arms_contact_id = arms_contact_id
        # The ID of the alert contact.
        self.contact_id = contact_id
        # The name of the alert contact.
        self.contact_name = contact_name
        # The email address of the alert contact.
        self.email = email
        # Indicates whether the email address was verified.
        self.is_email_verify = is_email_verify
        # Indicates whether the mobile number was verified. Valid values:
        # 
        # *   `false`: no
        # *   `true`: yes
        self.is_verify = is_verify
        # The mobile number of the alert contact.
        self.phone = phone
        # The operation that you want to perform if phone calls fail to be answered. Valid values:
        # 
        # *   0: No operation is performed.
        # *   1: A phone call is made again.
        # *   2: A text message is sent.
        # *   3 (default value): The global default value is used.
        self.reissue_send_notice = reissue_send_notice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arms_contact_id is not None:
            result['ArmsContactId'] = self.arms_contact_id
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.email is not None:
            result['Email'] = self.email
        if self.is_email_verify is not None:
            result['IsEmailVerify'] = self.is_email_verify
        if self.is_verify is not None:
            result['IsVerify'] = self.is_verify
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.reissue_send_notice is not None:
            result['ReissueSendNotice'] = self.reissue_send_notice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArmsContactId') is not None:
            self.arms_contact_id = m.get('ArmsContactId')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('IsEmailVerify') is not None:
            self.is_email_verify = m.get('IsEmailVerify')
        if m.get('IsVerify') is not None:
            self.is_verify = m.get('IsVerify')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('ReissueSendNotice') is not None:
            self.reissue_send_notice = m.get('ReissueSendNotice')
        return self


class DescribeContactsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        alert_contacts: List[DescribeContactsResponseBodyPageBeanAlertContacts] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The alert contacts.
        self.alert_contacts = alert_contacts
        # The page number of the returned page.
        self.page = page
        # The number of alert contacts returned per page.
        self.size = size
        # The total number of alert contacts.
        self.total = total

    def validate(self):
        if self.alert_contacts:
            for k in self.alert_contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertContacts'] = []
        if self.alert_contacts is not None:
            for k in self.alert_contacts:
                result['AlertContacts'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_contacts = []
        if m.get('AlertContacts') is not None:
            for k in m.get('AlertContacts'):
                temp_model = DescribeContactsResponseBodyPageBeanAlertContacts()
                self.alert_contacts.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeContactsResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: DescribeContactsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The objects that were returned.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = DescribeContactsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeContactsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeContactsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContactsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDispatchRuleRequest(TeaModel):
    def __init__(
        self,
        id: str = None,
        region_id: str = None,
    ):
        # The ID of the dispatch policy.
        # 
        # This parameter is required.
        self.id = id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeDispatchRuleResponseBodyDispatchRuleGroupRules(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        group_interval: int = None,
        group_wait_time: int = None,
        grouping_fields: List[str] = None,
        repeat_interval: int = None,
    ):
        # The ID of the group.
        self.group_id = group_id
        # The grouping interval.
        self.group_interval = group_interval
        # The waiting time for grouping.
        self.group_wait_time = group_wait_time
        # The grouping fields.
        self.grouping_fields = grouping_fields
        # The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
        self.repeat_interval = repeat_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_interval is not None:
            result['GroupInterval'] = self.group_interval
        if self.group_wait_time is not None:
            result['GroupWaitTime'] = self.group_wait_time
        if self.grouping_fields is not None:
            result['GroupingFields'] = self.grouping_fields
        if self.repeat_interval is not None:
            result['RepeatInterval'] = self.repeat_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupInterval') is not None:
            self.group_interval = m.get('GroupInterval')
        if m.get('GroupWaitTime') is not None:
            self.group_wait_time = m.get('GroupWaitTime')
        if m.get('GroupingFields') is not None:
            self.grouping_fields = m.get('GroupingFields')
        if m.get('RepeatInterval') is not None:
            self.repeat_interval = m.get('RepeatInterval')
        return self


class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The key of the tag of the dispatch rule. Valid values:
        # 
        # *   `_aliyun_arms_userid`: user ID
        # *   `_aliyun_arms_involvedObject_kind`: type of the associated object
        # *   `_aliyun_arms_involvedObject_id`: ID of the associated object
        # *   `_aliyun_arms_involvedObject_name`: name of the associated object
        # *   `_aliyun_arms_alert_name`: alert name
        # *   `_aliyun_arms_alert_rule_id`: alert rule ID
        # *   `_aliyun_arms_alert_type`: alert type
        # *   `_aliyun_arms_alert_level`: alert severity
        self.key = key
        # The operator used in the dispatch rule. Valid values:
        # 
        # *   `eq`: equals to.
        # *   `re`: matches a regular expression.
        self.operator = operator
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups(TeaModel):
    def __init__(
        self,
        label_match_expressions: List[DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions] = None,
    ):
        # The collection of conditions of the dispatch rule.
        self.label_match_expressions = label_match_expressions

    def validate(self):
        if self.label_match_expressions:
            for k in self.label_match_expressions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LabelMatchExpressions'] = []
        if self.label_match_expressions is not None:
            for k in self.label_match_expressions:
                result['LabelMatchExpressions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.label_match_expressions = []
        if m.get('LabelMatchExpressions') is not None:
            for k in m.get('LabelMatchExpressions'):
                temp_model = DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions()
                self.label_match_expressions.append(temp_model.from_map(k))
        return self


class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid(TeaModel):
    def __init__(
        self,
        label_match_expression_groups: List[DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups] = None,
    ):
        # The collection of dispatch rules.
        self.label_match_expression_groups = label_match_expression_groups

    def validate(self):
        if self.label_match_expression_groups:
            for k in self.label_match_expression_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LabelMatchExpressionGroups'] = []
        if self.label_match_expression_groups is not None:
            for k in self.label_match_expression_groups:
                result['LabelMatchExpressionGroups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.label_match_expression_groups = []
        if m.get('LabelMatchExpressionGroups') is not None:
            for k in m.get('LabelMatchExpressionGroups'):
                temp_model = DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups()
                self.label_match_expression_groups.append(temp_model.from_map(k))
        return self


class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects(TeaModel):
    def __init__(
        self,
        name: str = None,
        notify_object_id: str = None,
        notify_type: str = None,
    ):
        # The name of the contact or contact group.
        self.name = name
        # The ID of the contact or contact group.
        self.notify_object_id = notify_object_id
        # The type of the alert contact. Valid values:
        # 
        # - `CONTACT`: contact
        # - `CONTACT_GROUP`: contact group
        self.notify_type = notify_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_object_id is not None:
            result['NotifyObjectId'] = self.notify_object_id
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyObjectId') is not None:
            self.notify_object_id = m.get('NotifyObjectId')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        return self


class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules(TeaModel):
    def __init__(
        self,
        notify_channels: List[str] = None,
        notify_objects: List[DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects] = None,
    ):
        # The notification method Array.
        self.notify_channels = notify_channels
        # The collection of alert contacts.
        self.notify_objects = notify_objects

    def validate(self):
        if self.notify_objects:
            for k in self.notify_objects:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_channels is not None:
            result['NotifyChannels'] = self.notify_channels
        result['NotifyObjects'] = []
        if self.notify_objects is not None:
            for k in self.notify_objects:
                result['NotifyObjects'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotifyChannels') is not None:
            self.notify_channels = m.get('NotifyChannels')
        self.notify_objects = []
        if m.get('NotifyObjects') is not None:
            for k in m.get('NotifyObjects'):
                temp_model = DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects()
                self.notify_objects.append(temp_model.from_map(k))
        return self


class DescribeDispatchRuleResponseBodyDispatchRule(TeaModel):
    def __init__(
        self,
        dispatch_type: str = None,
        group_rules: List[DescribeDispatchRuleResponseBodyDispatchRuleGroupRules] = None,
        is_recover: bool = None,
        label_match_expression_grid: DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid = None,
        name: str = None,
        notify_rules: List[DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules] = None,
        rule_id: int = None,
        state: str = None,
    ):
        # Alarm handling method.
        # 
        # CREATE_ALERT: Generate an alert.
        # 
        # DISCARD_ALERT: Discard the alarm event, that is, no alarm.
        self.dispatch_type = dispatch_type
        # The information about groups.
        self.group_rules = group_rules
        # Whether to send recovered alerts.
        # true: send.
        # false: do not send.
        self.is_recover = is_recover
        # The information about the dispatch rule.
        self.label_match_expression_grid = label_match_expression_grid
        # The name of the dispatch policy.
        self.name = name
        # The collection of notification methods.
        self.notify_rules = notify_rules
        # The ID of the dispatch rule.
        self.rule_id = rule_id
        # Indicates whether the dispatch policy is enabled. Valid values: 
        # 
        # - `true`: enabled
        # - `false`: disabled
        self.state = state

    def validate(self):
        if self.group_rules:
            for k in self.group_rules:
                if k:
                    k.validate()
        if self.label_match_expression_grid:
            self.label_match_expression_grid.validate()
        if self.notify_rules:
            for k in self.notify_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dispatch_type is not None:
            result['DispatchType'] = self.dispatch_type
        result['GroupRules'] = []
        if self.group_rules is not None:
            for k in self.group_rules:
                result['GroupRules'].append(k.to_map() if k else None)
        if self.is_recover is not None:
            result['IsRecover'] = self.is_recover
        if self.label_match_expression_grid is not None:
            result['LabelMatchExpressionGrid'] = self.label_match_expression_grid.to_map()
        if self.name is not None:
            result['Name'] = self.name
        result['NotifyRules'] = []
        if self.notify_rules is not None:
            for k in self.notify_rules:
                result['NotifyRules'].append(k.to_map() if k else None)
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DispatchType') is not None:
            self.dispatch_type = m.get('DispatchType')
        self.group_rules = []
        if m.get('GroupRules') is not None:
            for k in m.get('GroupRules'):
                temp_model = DescribeDispatchRuleResponseBodyDispatchRuleGroupRules()
                self.group_rules.append(temp_model.from_map(k))
        if m.get('IsRecover') is not None:
            self.is_recover = m.get('IsRecover')
        if m.get('LabelMatchExpressionGrid') is not None:
            temp_model = DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid()
            self.label_match_expression_grid = temp_model.from_map(m['LabelMatchExpressionGrid'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.notify_rules = []
        if m.get('NotifyRules') is not None:
            for k in m.get('NotifyRules'):
                temp_model = DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules()
                self.notify_rules.append(temp_model.from_map(k))
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribeDispatchRuleResponseBody(TeaModel):
    def __init__(
        self,
        dispatch_rule: DescribeDispatchRuleResponseBodyDispatchRule = None,
        request_id: str = None,
    ):
        # The struct returned.
        self.dispatch_rule = dispatch_rule
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.dispatch_rule:
            self.dispatch_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dispatch_rule is not None:
            result['DispatchRule'] = self.dispatch_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DispatchRule') is not None:
            temp_model = DescribeDispatchRuleResponseBodyDispatchRule()
            self.dispatch_rule = temp_model.from_map(m['DispatchRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDispatchRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeDispatchRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDispatchRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvCustomJobRequest(TeaModel):
    def __init__(
        self,
        custom_job_name: str = None,
        encrypt_yaml: bool = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The name of the custom job.
        # 
        # This parameter is required.
        self.custom_job_name = custom_job_name
        # Specifies whether to return an encrypted YAML string.
        self.encrypt_yaml = encrypt_yaml
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_job_name is not None:
            result['CustomJobName'] = self.custom_job_name
        if self.encrypt_yaml is not None:
            result['EncryptYaml'] = self.encrypt_yaml
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomJobName') is not None:
            self.custom_job_name = m.get('CustomJobName')
        if m.get('EncryptYaml') is not None:
            self.encrypt_yaml = m.get('EncryptYaml')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvCustomJobResponseBodyData(TeaModel):
    def __init__(
        self,
        config_yaml: str = None,
        custom_job_name: str = None,
        environment_id: str = None,
        region_id: str = None,
        status: str = None,
    ):
        # If the **encryptYaml** parameter is set to `true`, a Base64-encoded YAML string is returned. Otherwise, a plaintext YAML string is returned.
        self.config_yaml = config_yaml
        # The name of the custom job.
        self.custom_job_name = custom_job_name
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id
        # The status. Valid values:
        # 
        # *   run
        # *   stop
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.custom_job_name is not None:
            result['CustomJobName'] = self.custom_job_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('CustomJobName') is not None:
            self.custom_job_name = m.get('CustomJobName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEnvCustomJobResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvCustomJobResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvCustomJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnvCustomJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvCustomJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvCustomJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvPodMonitorRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        namespace: str = None,
        pod_monitor_name: str = None,
        region_id: str = None,
    ):
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The namespace where the PodMonitor resides.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The name of the PodMonitor.
        # 
        # This parameter is required.
        self.pod_monitor_name = pod_monitor_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod_monitor_name is not None:
            result['PodMonitorName'] = self.pod_monitor_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PodMonitorName') is not None:
            self.pod_monitor_name = m.get('PodMonitorName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvPodMonitorResponseBodyData(TeaModel):
    def __init__(
        self,
        config_yaml: str = None,
        environment_id: str = None,
        namespace: str = None,
        pod_monitor_name: str = None,
        region_id: str = None,
        status: str = None,
    ):
        # The YAML string of the PodMonitor.
        self.config_yaml = config_yaml
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The namespace.
        self.namespace = namespace
        # The name of the PodMonitor.
        self.pod_monitor_name = pod_monitor_name
        # The region ID.
        self.region_id = region_id
        # The status. Valid values:
        # 
        # *   run
        # *   stop
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod_monitor_name is not None:
            result['PodMonitorName'] = self.pod_monitor_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PodMonitorName') is not None:
            self.pod_monitor_name = m.get('PodMonitorName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEnvPodMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvPodMonitorResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvPodMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnvPodMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvPodMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvPodMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvServiceMonitorRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        namespace: str = None,
        region_id: str = None,
        service_monitor_name: str = None,
    ):
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The namespace where the ServiceMonitor resides.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The name of the ServiceMonitor.
        # 
        # This parameter is required.
        self.service_monitor_name = service_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service_monitor_name is not None:
            result['ServiceMonitorName'] = self.service_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServiceMonitorName') is not None:
            self.service_monitor_name = m.get('ServiceMonitorName')
        return self


class DescribeEnvServiceMonitorResponseBodyData(TeaModel):
    def __init__(
        self,
        config_yaml: str = None,
        environment_id: str = None,
        namespace: str = None,
        region_id: str = None,
        service_monitor_name: str = None,
        status: str = None,
    ):
        # The YAML configuration file of the ServiceMonitor.
        self.config_yaml = config_yaml
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The namespace.
        self.namespace = namespace
        # The region ID.
        self.region_id = region_id
        # The name of the ServiceMonitor.
        self.service_monitor_name = service_monitor_name
        # The status. Valid values:
        # 
        # *   run
        # *   stop
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service_monitor_name is not None:
            result['ServiceMonitorName'] = self.service_monitor_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServiceMonitorName') is not None:
            self.service_monitor_name = m.get('ServiceMonitorName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEnvServiceMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvServiceMonitorResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvServiceMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnvServiceMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvServiceMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvServiceMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvironmentRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvironmentResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeEnvironmentResponseBodyData(TeaModel):
    def __init__(
        self,
        bind_resource_id: str = None,
        bind_resource_profile: str = None,
        bind_resource_status: str = None,
        bind_resource_store_duration: str = None,
        bind_resource_type: str = None,
        bind_vpc_cidr: str = None,
        db_instance_status: str = None,
        environment_id: str = None,
        environment_name: str = None,
        environment_sub_type: str = None,
        environment_type: str = None,
        fee_package: str = None,
        grafa_data_source_name: str = None,
        grafana_datasource_uid: str = None,
        grafana_folder_title: str = None,
        grafana_folder_uid: str = None,
        grafana_folder_url: str = None,
        grafana_workspace_id: str = None,
        managed_type: str = None,
        prometheus_instance_id: str = None,
        prometheus_instance_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        tags: List[DescribeEnvironmentResponseBodyDataTags] = None,
        user_id: str = None,
        vpc_id: str = None,
        vswitch_id: str = None,
    ):
        # The ID of the resource associated with the environment, such as the ACK cluster ID or VPC ID.
        self.bind_resource_id = bind_resource_id
        # The profile of the resource.
        self.bind_resource_profile = bind_resource_profile
        # The status of the resource.
        self.bind_resource_status = bind_resource_status
        # The retention period of the resource. Unit: days.
        self.bind_resource_store_duration = bind_resource_store_duration
        # The resource type.
        self.bind_resource_type = bind_resource_type
        # The VPC CIDR block.
        self.bind_vpc_cidr = bind_vpc_cidr
        # The status of the database that is bound to the Prometheus instance.
        # 
        # Valid values:
        # 
        # *   UNINSTALLING
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   INSTALLING
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   UNINSTALLED
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   RUNNING
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   MODIFYING
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.db_instance_status = db_instance_status
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The environment name.
        self.environment_name = environment_name
        # Environment subtypes:
        # - CS: Currently supports ACK.
        # - ECS: ECS is currently supported.
        # - Cloud: Currently supports Cloud.
        self.environment_sub_type = environment_sub_type
        # The type of the environment. Valid values:
        # 
        # *   CS: Container Service for Kubernetes (ACK)
        # *   ECS: Elastic Compute Service
        # *   Cloud: cloud service
        self.environment_type = environment_type
        # The payable resource plan. Valid values:
        # 
        # *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro.
        # *   Otherwise, leave the parameter empty.
        self.fee_package = fee_package
        # The name of the Grafana data source.
        self.grafa_data_source_name = grafa_data_source_name
        # The unique ID of the Grafana data source.
        self.grafana_datasource_uid = grafana_datasource_uid
        # The name of the Grafana directory.
        self.grafana_folder_title = grafana_folder_title
        # The unique ID of the Grafana directory.
        self.grafana_folder_uid = grafana_folder_uid
        # The URL of the Grafana directory.
        self.grafana_folder_url = grafana_folder_url
        # The ID of the Grafana workspace.
        self.grafana_workspace_id = grafana_workspace_id
        # managed type:
        # - none: unmanaged. The default value for ACK clusters.
        # - agent: managed agent (including KSM). The default values for ASK, ACS, and AckOne clusters.
        # - agent-exporter: managed agent and exporters. The default value for the cloud service type.
        self.managed_type = managed_type
        # The ID of the Prometheus instance.
        self.prometheus_instance_id = prometheus_instance_id
        # The name of the Prometheus instance.
        self.prometheus_instance_name = prometheus_instance_name
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The ID of the security group associated with the environment.
        self.security_group_id = security_group_id
        # The tags.
        self.tags = tags
        # The user ID.
        self.user_id = user_id
        # The VPC ID.
        self.vpc_id = vpc_id
        # The ID of the vSwitch associated with the environment.
        self.vswitch_id = vswitch_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.bind_resource_profile is not None:
            result['BindResourceProfile'] = self.bind_resource_profile
        if self.bind_resource_status is not None:
            result['BindResourceStatus'] = self.bind_resource_status
        if self.bind_resource_store_duration is not None:
            result['BindResourceStoreDuration'] = self.bind_resource_store_duration
        if self.bind_resource_type is not None:
            result['BindResourceType'] = self.bind_resource_type
        if self.bind_vpc_cidr is not None:
            result['BindVpcCidr'] = self.bind_vpc_cidr
        if self.db_instance_status is not None:
            result['DbInstanceStatus'] = self.db_instance_status
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.environment_sub_type is not None:
            result['EnvironmentSubType'] = self.environment_sub_type
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.grafa_data_source_name is not None:
            result['GrafaDataSourceName'] = self.grafa_data_source_name
        if self.grafana_datasource_uid is not None:
            result['GrafanaDatasourceUid'] = self.grafana_datasource_uid
        if self.grafana_folder_title is not None:
            result['GrafanaFolderTitle'] = self.grafana_folder_title
        if self.grafana_folder_uid is not None:
            result['GrafanaFolderUid'] = self.grafana_folder_uid
        if self.grafana_folder_url is not None:
            result['GrafanaFolderUrl'] = self.grafana_folder_url
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.prometheus_instance_id is not None:
            result['PrometheusInstanceId'] = self.prometheus_instance_id
        if self.prometheus_instance_name is not None:
            result['PrometheusInstanceName'] = self.prometheus_instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vswitch_id is not None:
            result['VswitchId'] = self.vswitch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('BindResourceProfile') is not None:
            self.bind_resource_profile = m.get('BindResourceProfile')
        if m.get('BindResourceStatus') is not None:
            self.bind_resource_status = m.get('BindResourceStatus')
        if m.get('BindResourceStoreDuration') is not None:
            self.bind_resource_store_duration = m.get('BindResourceStoreDuration')
        if m.get('BindResourceType') is not None:
            self.bind_resource_type = m.get('BindResourceType')
        if m.get('BindVpcCidr') is not None:
            self.bind_vpc_cidr = m.get('BindVpcCidr')
        if m.get('DbInstanceStatus') is not None:
            self.db_instance_status = m.get('DbInstanceStatus')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('EnvironmentSubType') is not None:
            self.environment_sub_type = m.get('EnvironmentSubType')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('GrafaDataSourceName') is not None:
            self.grafa_data_source_name = m.get('GrafaDataSourceName')
        if m.get('GrafanaDatasourceUid') is not None:
            self.grafana_datasource_uid = m.get('GrafanaDatasourceUid')
        if m.get('GrafanaFolderTitle') is not None:
            self.grafana_folder_title = m.get('GrafanaFolderTitle')
        if m.get('GrafanaFolderUid') is not None:
            self.grafana_folder_uid = m.get('GrafanaFolderUid')
        if m.get('GrafanaFolderUrl') is not None:
            self.grafana_folder_url = m.get('GrafanaFolderUrl')
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('PrometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('PrometheusInstanceId')
        if m.get('PrometheusInstanceName') is not None:
            self.prometheus_instance_name = m.get('PrometheusInstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeEnvironmentResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VswitchId') is not None:
            self.vswitch_id = m.get('VswitchId')
        return self


class DescribeEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvironmentResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvironmentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_id: str = None,
        feature_name: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: en and zh.
        self.aliyun_lang = aliyun_lang
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The name of the feature.
        # 
        # Valid values:
        # 
        # *   app-agent-pilot: App Pilot agent
        # *   arms-cmonitor: ARMS CMonitor agent
        # *   metric-agent: Prometheus agent
        # 
        # This parameter is required.
        self.feature_name = feature_name
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.feature_name is not None:
            result['FeatureName'] = self.feature_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('FeatureName') is not None:
            self.feature_name = m.get('FeatureName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEnvironmentFeatureResponseBodyDataFeature(TeaModel):
    def __init__(
        self,
        alias: str = None,
        config: Dict[str, str] = None,
        description: str = None,
        environment_id: str = None,
        icon: str = None,
        language: str = None,
        latest_version: str = None,
        managed: bool = None,
        name: str = None,
        status: str = None,
        version: str = None,
    ):
        # The alias of the feature.
        self.alias = alias
        # The configuration of the feature.
        self.config = config
        # The description of the feature.
        self.description = description
        # The environment ID.
        self.environment_id = environment_id
        # The URL of the icon.
        self.icon = icon
        # The language.
        self.language = language
        # The latest version number.
        self.latest_version = latest_version
        # Indicates whether the component is fully managed.
        self.managed = managed
        # The name of the feature.
        self.name = name
        # The installation status of the agent.
        # 
        # *   Installing: The agent is being installed.
        # *   Success: The agent is installed.
        # *   Failed: The agent failed to be installed.
        # *   UnInstall: The agent is uninstalled or has not been installed.
        # *   Uninstalling: The agent is being uninstalled.
        # *   UnInstallFailed: The agent failed to be uninstalled.
        self.status = status
        # The version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.config is not None:
            result['Config'] = self.config
        if self.description is not None:
            result['Description'] = self.description
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_version is not None:
            result['LatestVersion'] = self.latest_version
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestVersion') is not None:
            self.latest_version = m.get('LatestVersion')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers(TeaModel):
    def __init__(
        self,
        args: List[str] = None,
        image: str = None,
        name: str = None,
    ):
        # The container parameters.
        self.args = args
        # The container image.
        self.image = image
        # The container name.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['Args'] = self.args
        if self.image is not None:
            result['Image'] = self.image
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Args') is not None:
            self.args = m.get('Args')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeEnvironmentFeatureResponseBodyDataFeatureStatus(TeaModel):
    def __init__(
        self,
        bind_resource_id: str = None,
        feature_containers: List[DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers] = None,
        ips: List[str] = None,
        name: str = None,
        namespace: str = None,
        security_group_id: str = None,
        status: str = None,
        v_switch_id: str = None,
    ):
        # The ID of the resource.
        self.bind_resource_id = bind_resource_id
        # The containers of the feature.
        self.feature_containers = feature_containers
        # The IP address of the pod.
        self.ips = ips
        # The Kubernetes resource name of the feature.
        self.name = name
        # The namespace.
        self.namespace = namespace
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The status of the agent. Valid values:
        # 
        # *   Success: The agent is running.
        # *   Failed: The agent failed to run.
        # *   Not Found: The agent is not installed.
        self.status = status
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id

    def validate(self):
        if self.feature_containers:
            for k in self.feature_containers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        result['FeatureContainers'] = []
        if self.feature_containers is not None:
            for k in self.feature_containers:
                result['FeatureContainers'].append(k.to_map() if k else None)
        if self.ips is not None:
            result['Ips'] = self.ips
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        self.feature_containers = []
        if m.get('FeatureContainers') is not None:
            for k in m.get('FeatureContainers'):
                temp_model = DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers()
                self.feature_containers.append(temp_model.from_map(k))
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeEnvironmentFeatureResponseBodyData(TeaModel):
    def __init__(
        self,
        feature: DescribeEnvironmentFeatureResponseBodyDataFeature = None,
        feature_status: DescribeEnvironmentFeatureResponseBodyDataFeatureStatus = None,
    ):
        # The installation information about the feature.
        self.feature = feature
        # The status of the feature.
        self.feature_status = feature_status

    def validate(self):
        if self.feature:
            self.feature.validate()
        if self.feature_status:
            self.feature_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feature is not None:
            result['Feature'] = self.feature.to_map()
        if self.feature_status is not None:
            result['FeatureStatus'] = self.feature_status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Feature') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBodyDataFeature()
            self.feature = temp_model.from_map(m['Feature'])
        if m.get('FeatureStatus') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBodyDataFeatureStatus()
            self.feature_status = temp_model.from_map(m['FeatureStatus'])
        return self


class DescribeEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: DescribeEnvironmentFeatureResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeIMRobotsRequest(TeaModel):
    def __init__(
        self,
        page: int = None,
        robot_ids: str = None,
        robot_name: str = None,
        size: int = None,
    ):
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The chatbot IDs.
        self.robot_ids = robot_ids
        # The name of the IM chatbot.
        self.robot_name = robot_name
        # The number of IM chatbots to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page is not None:
            result['Page'] = self.page
        if self.robot_ids is not None:
            result['RobotIds'] = self.robot_ids
        if self.robot_name is not None:
            result['RobotName'] = self.robot_name
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('RobotIds') is not None:
            self.robot_ids = m.get('RobotIds')
        if m.get('RobotName') is not None:
            self.robot_name = m.get('RobotName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the notification policy.
        self.id = id
        # The name of the notification policy.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DescribeIMRobotsResponseBodyPageBeanAlertIMRobots(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        daily_noc: bool = None,
        daily_noc_time: str = None,
        ding_sign_key: str = None,
        dispatch_rules: List[DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules] = None,
        robot_addr: str = None,
        robot_id: float = None,
        robot_name: str = None,
        type: str = None,
    ):
        # The time when the IM chatbot was created.
        self.create_time = create_time
        # Indicates whether daily statistics are sent. Valid values:
        # 
        # *   `false` (default): Daily statistics are not sent.
        # *   `true`: Daily statistics are sent.
        self.daily_noc = daily_noc
        # The point in time at which the daily statistics are sent. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
        self.daily_noc_time = daily_noc_time
        # The signature key of DingTalk. If you specify a signature key, DingTalk authentication is performed by using the signature key. If you do not specify a signature key, a whitelist is used for authentication by default. The keyword of the whitelist is **Alert**.
        self.ding_sign_key = ding_sign_key
        # The notification policies.
        self.dispatch_rules = dispatch_rules
        # The webhook URL of the IM chatbot.
        self.robot_addr = robot_addr
        # The ID of the IM chatbot.
        self.robot_id = robot_id
        # The name of the IM chatbot.
        self.robot_name = robot_name
        # The type of the IM chatbot. Valid values:
        # 
        # *   `dingding`: DingTalk chatbot
        # *   `wechat`: WeCom chatbot
        self.type = type

    def validate(self):
        if self.dispatch_rules:
            for k in self.dispatch_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.daily_noc is not None:
            result['DailyNoc'] = self.daily_noc
        if self.daily_noc_time is not None:
            result['DailyNocTime'] = self.daily_noc_time
        if self.ding_sign_key is not None:
            result['DingSignKey'] = self.ding_sign_key
        result['DispatchRules'] = []
        if self.dispatch_rules is not None:
            for k in self.dispatch_rules:
                result['DispatchRules'].append(k.to_map() if k else None)
        if self.robot_addr is not None:
            result['RobotAddr'] = self.robot_addr
        if self.robot_id is not None:
            result['RobotId'] = self.robot_id
        if self.robot_name is not None:
            result['RobotName'] = self.robot_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DailyNoc') is not None:
            self.daily_noc = m.get('DailyNoc')
        if m.get('DailyNocTime') is not None:
            self.daily_noc_time = m.get('DailyNocTime')
        if m.get('DingSignKey') is not None:
            self.ding_sign_key = m.get('DingSignKey')
        self.dispatch_rules = []
        if m.get('DispatchRules') is not None:
            for k in m.get('DispatchRules'):
                temp_model = DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules()
                self.dispatch_rules.append(temp_model.from_map(k))
        if m.get('RobotAddr') is not None:
            self.robot_addr = m.get('RobotAddr')
        if m.get('RobotId') is not None:
            self.robot_id = m.get('RobotId')
        if m.get('RobotName') is not None:
            self.robot_name = m.get('RobotName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeIMRobotsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        alert_imrobots: List[DescribeIMRobotsResponseBodyPageBeanAlertIMRobots] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The queried IM chatbots.
        self.alert_imrobots = alert_imrobots
        # The page number of the returned page.
        self.page = page
        # The number of IM chatbots returned per page.
        self.size = size
        # The total number of queried IM chatbots.
        self.total = total

    def validate(self):
        if self.alert_imrobots:
            for k in self.alert_imrobots:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertIMRobots'] = []
        if self.alert_imrobots is not None:
            for k in self.alert_imrobots:
                result['AlertIMRobots'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_imrobots = []
        if m.get('AlertIMRobots') is not None:
            for k in m.get('AlertIMRobots'):
                temp_model = DescribeIMRobotsResponseBodyPageBeanAlertIMRobots()
                self.alert_imrobots.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeIMRobotsResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: DescribeIMRobotsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned objects.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = DescribeIMRobotsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeIMRobotsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeIMRobotsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeIMRobotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrometheusAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        cluster_id: str = None,
    ):
        # The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.
        # 
        # This parameter is required.
        self.alert_id = alert_id
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the annotation.
        self.name = name
        # The value of the annotation.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the tag.
        self.name = name
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_name: str = None,
        annotations: List[DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations] = None,
        cluster_id: str = None,
        dispatch_rule_id: int = None,
        duration: str = None,
        expression: str = None,
        labels: List[DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels] = None,
        message: str = None,
        notify_type: str = None,
        status: int = None,
        type: str = None,
    ):
        # The ID of the alert rule.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The annotations of the alert rule.
        self.annotations = annotations
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The ID of the notification policy. This parameter is returned if the **NotifyType** parameter is set to `DISPATCH_RULE`.
        self.dispatch_rule_id = dispatch_rule_id
        # The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
        self.duration = duration
        # The expression of the alert rule.
        self.expression = expression
        # The tags of the alert rule.
        self.labels = labels
        # The alert message. Tags can be referenced in the {{$labels.xxx}} format.
        self.message = message
        # The method of that is used to send alert notifications. Valid values:
        # 
        # *   `ALERT_MANAGER`: Alert notifications are sent by Operation Center.
        # *   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.
        self.notify_type = notify_type
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # *   `1`: The alert rule is enabled.
        # *   `0`: The alert rule is disabled.
        self.status = status
        # The type of the alert rule.
        self.type = type

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePrometheusAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        prometheus_alert_rule: DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.message = message
        # The returned struct.
        self.prometheus_alert_rule = prometheus_alert_rule
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.prometheus_alert_rule:
            self.prometheus_alert_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.prometheus_alert_rule is not None:
            result['PrometheusAlertRule'] = self.prometheus_alert_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PrometheusAlertRule') is not None:
            temp_model = DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule()
            self.prometheus_alert_rule = temp_model.from_map(m['PrometheusAlertRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribePrometheusAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePrometheusAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrometheusAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTraceLicenseKeyRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeTraceLicenseKeyResponseBody(TeaModel):
    def __init__(
        self,
        license_key: str = None,
        request_id: str = None,
    ):
        # The license key for the application.
        self.license_key = license_key
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.license_key is not None:
            result['LicenseKey'] = self.license_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LicenseKey') is not None:
            self.license_key = m.get('LicenseKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeTraceLicenseKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeTraceLicenseKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTraceLicenseKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeWebhookContactsRequest(TeaModel):
    def __init__(
        self,
        contact_ids: str = None,
        page: int = None,
        size: int = None,
        webhook_name: str = None,
    ):
        # The ID of the alert contact.
        self.contact_ids = contact_ids
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The number of alert contacts displayed on each page.
        # 
        # This parameter is required.
        self.size = size
        # The name of the webhook alert contact.
        self.webhook_name = webhook_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.webhook_name is not None:
            result['WebhookName'] = self.webhook_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('WebhookName') is not None:
            self.webhook_name = m.get('WebhookName')
        return self


class DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook(TeaModel):
    def __init__(
        self,
        biz_headers: Dict[str, Any] = None,
        biz_params: Dict[str, Any] = None,
        body: str = None,
        method: str = None,
        recover_body: str = None,
        url: str = None,
    ):
        # The header of the HTTP request.
        self.biz_headers = biz_headers
        # The parameters in the HTTP request.
        self.biz_params = biz_params
        # The alert notification template.
        self.body = body
        # The HTTP request method.
        # 
        # *   Get
        # *   Post
        self.method = method
        # The notification template for clearing alerts.
        self.recover_body = recover_body
        # The URL of the request method.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_headers is not None:
            result['BizHeaders'] = self.biz_headers
        if self.biz_params is not None:
            result['BizParams'] = self.biz_params
        if self.body is not None:
            result['Body'] = self.body
        if self.method is not None:
            result['Method'] = self.method
        if self.recover_body is not None:
            result['RecoverBody'] = self.recover_body
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizHeaders') is not None:
            self.biz_headers = m.get('BizHeaders')
        if m.get('BizParams') is not None:
            self.biz_params = m.get('BizParams')
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('RecoverBody') is not None:
            self.recover_body = m.get('RecoverBody')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeWebhookContactsResponseBodyPageBeanWebhookContacts(TeaModel):
    def __init__(
        self,
        webhook: DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook = None,
        webhook_id: float = None,
        webhook_name: str = None,
    ):
        # The details of the webhook alert contact.
        self.webhook = webhook
        # The ID of the webhook alert contact.
        self.webhook_id = webhook_id
        # The name of the webhook alert contact.
        self.webhook_name = webhook_name

    def validate(self):
        if self.webhook:
            self.webhook.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.webhook is not None:
            result['Webhook'] = self.webhook.to_map()
        if self.webhook_id is not None:
            result['WebhookId'] = self.webhook_id
        if self.webhook_name is not None:
            result['WebhookName'] = self.webhook_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Webhook') is not None:
            temp_model = DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook()
            self.webhook = temp_model.from_map(m['Webhook'])
        if m.get('WebhookId') is not None:
            self.webhook_id = m.get('WebhookId')
        if m.get('WebhookName') is not None:
            self.webhook_name = m.get('WebhookName')
        return self


class DescribeWebhookContactsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        page: int = None,
        size: int = None,
        total: int = None,
        webhook_contacts: List[DescribeWebhookContactsResponseBodyPageBeanWebhookContacts] = None,
    ):
        # The page number of the returned page.
        self.page = page
        # The number of alert contacts displayed on each page.
        self.size = size
        # The total number of alert contacts.
        self.total = total
        # The list of webhook alert contacts.
        self.webhook_contacts = webhook_contacts

    def validate(self):
        if self.webhook_contacts:
            for k in self.webhook_contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        result['WebhookContacts'] = []
        if self.webhook_contacts is not None:
            for k in self.webhook_contacts:
                result['WebhookContacts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        self.webhook_contacts = []
        if m.get('WebhookContacts') is not None:
            for k in m.get('WebhookContacts'):
                temp_model = DescribeWebhookContactsResponseBodyPageBeanWebhookContacts()
                self.webhook_contacts.append(temp_model.from_map(k))
        return self


class DescribeWebhookContactsResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: DescribeWebhookContactsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned objects.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = DescribeWebhookContactsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeWebhookContactsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeWebhookContactsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeWebhookContactsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DoInsightsActionRequest(TeaModel):
    def __init__(
        self,
        data: str = None,
        module: str = None,
        region_id: str = None,
    ):
        # The query parameters. Different module types correspond to different query parameters.
        # 
        # *   QueryTopo
        # 
        # <!---->
        # 
        #     {
        #         "regionId": string,  # The region ID.
        #         "startTime": string, # The beginning of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
        #         "endTime": string, # The end of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
        #         "edgeFilter": { # The edge filter condition.
        #             "includeTypes": [EdgeType], # The edge types to be included.
        #             "excludeTypes": [EdgeType], # The edge types to be excluded.
        #             "fromNodeFilter": { # The source node filter condition.
        #                 "includeEntityTypes": [EntityType] # The entity types to be included.
        #                 "excludeEntityTypes": [EntityType] # The entity types to be excluded.
        #             },
        #             "toNodeFilter": {  # The destination node filter condition.
        #                 "includeEntityTypes": [EntityType] # The entity types to be included.
        #                 "excludeEntityTypes": [EntityType] # The entity types to be excluded.
        #             }
        #         },
        #         "includeIsolatedNodes": bool, # Specifies whether to include isolated nodes.
        #         "isolatedNodeFilter": { # The isolated node filter condition.
        #             "includeEntityTypes": [EntityType] # The entity types to be included.
        #             "excludeEntityTypes": [EntityType] # The entity types to be excluded.
        #          },
        #         "queryMetrics": boolean, # Specifies whether to query related red metrics during the metric query.
        #         "timeoutSecs": int, # The timeout duration for querying metrics.
        #     	"redOption": { # A metric query option.
        #     		"skipRt": boolean,  # Specifies whether to skip querying the response time.
        #     		"skipCount": boolean, # Specifies whether to skip querying the number of requests.
        #     		"skipError": boolean # Specifies whether to skip querying the number of errors.
        #     	}
        #     }
        # 
        # *   QueryTopoRed
        # 
        # <!---->
        # 
        #     {
        #         "regionId": string,  # The region ID.
        #         "startTime": string, # The beginning of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
        #         "endTime": string,   # The end of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
        #         "edgeIds": [string]  # The IDs of the edges to query.
        #         "nodeIds": [string]  # The IDs of the nodes to query.
        #         "redOption": { # A metric query option.
        #             "skipRt": boolean,  # Specifies whether to skip querying the response time.
        #             "skipCount": boolean, # Specifies whether to skip querying the number of requests.
        #             "skipError": boolean # Specifies whether to skip querying the number of errors.
        #         }
        #     }
        # 
        # This parameter is required.
        self.data = data
        # The module type. Valid values:
        # 
        # *   QueryTopo: queries the topology.
        # *   QueryTopoRed: queries the red topology metrics, such as the number of requests, response time, and number of errors.
        # 
        # Notice: The preceding features are still in canary release and are disabled by default. If you need to enable these features, submit a ticket in the Application Real-Time Monitoring Service (ARMS) console.
        # 
        # *\
        # *\
        # 
        # This parameter is required.
        self.module = module
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.module is not None:
            result['Module'] = self.module
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Module') is not None:
            self.module = m.get('Module')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DoInsightsActionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # The response parameters vary with the value of module.
        # 
        # *   QueryTopo
        # 
        #         {
        #          "nodes": [Node] # The collection of nodes. For more information, see the "Node" section of this topic.
        #          "edges": [Edge] # The collection of edges. For more information, see the "Edge" section of this topic.
        #         }
        # 
        # *   QueryTopoRed
        # 
        #         {
        #           "nodeRed": {
        #           	"nodeId": {
        #           		"count": double, # The total number of requests in the specified time range.
        #           		"error": double, # The total number of errors in the specified time range.
        #           		"rt": double, # The average response time in the specified time range. Unit: milliseconds.
        #           	}
        #           },
        #           "edgeRed": {
        #           	"edgeId": {
        #           	    "count": double, # The total number of requests in the specified time range.
        #           		"error": double, # The total number of errors in the specified time range.
        #           		"rt": double, # The average response time in the specified time range. Unit: milliseconds.
        #           	}
        #           }
        # 
        # }
        # 
        # ```
        # ```
        self.data = data
        # Information returned when the call fails.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Whether the query is successful:
        # 
        # - true
        # - false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DoInsightsActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DoInsightsActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DoInsightsActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableMetricRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        drop_metric: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The metric name.
        self.drop_metric = drop_metric
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.drop_metric is not None:
            result['DropMetric'] = self.drop_metric
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DropMetric') is not None:
            self.drop_metric = m.get('DropMetric')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class EnableMetricResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAgentDownloadUrlRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetAgentDownloadUrlResponseBody(TeaModel):
    def __init__(
        self,
        arms_agent_download_url: str = None,
        request_id: str = None,
    ):
        # The download URL of the ARMS agent.
        self.arms_agent_download_url = arms_agent_download_url
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arms_agent_download_url is not None:
            result['ArmsAgentDownloadUrl'] = self.arms_agent_download_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArmsAgentDownloadUrl') is not None:
            self.arms_agent_download_url = m.get('ArmsAgentDownloadUrl')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAgentDownloadUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAgentDownloadUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAgentDownloadUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAgentDownloadUrlV2Request(TeaModel):
    def __init__(
        self,
        agent_type: str = None,
        arch_type: str = None,
        os_type: str = None,
    ):
        # The agent type.\\
        # **Valid values:**\
        # 
        # *   **JavaAgent**\
        # *   **Instgo**\
        # 
        # This parameter is required.
        self.agent_type = agent_type
        # The architecture type of the environment where the agent is installed.\\
        # This parameter is required and valid only when **AgentType** is set to **Instgo**.\\
        # **Valid values:**\
        # 
        # *   **amd64**\
        # *   **arm64**\
        self.arch_type = arch_type
        # The operating system of the environment where the agent is installed.\\
        # This parameter is required and valid only when **AgentType** is set to **Instgo**.\\
        # **Valid values:**\
        # 
        # *   **linux**\
        # *   **darwin**\
        # *   **windows**\
        self.os_type = os_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_type is not None:
            result['AgentType'] = self.agent_type
        if self.arch_type is not None:
            result['ArchType'] = self.arch_type
        if self.os_type is not None:
            result['OsType'] = self.os_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentType') is not None:
            self.agent_type = m.get('AgentType')
        if m.get('ArchType') is not None:
            self.arch_type = m.get('ArchType')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        return self


class GetAgentDownloadUrlV2ResponseBodyData(TeaModel):
    def __init__(
        self,
        url: str = None,
        version: str = None,
    ):
        # The download URL of the agent.
        self.url = url
        # The version number of the agent.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['Url'] = self.url
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetAgentDownloadUrlV2ResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetAgentDownloadUrlV2ResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code.\\
        # **Valid values:**\
        # 
        # *   2xx: The request was successful.
        # *   3xx: The request was redirected.
        # *   4xx: The request was invalid.
        # *   5xx: A server error occurred.
        self.code = code
        # The version number and download URL of the agent.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.\\
        # **Valid values:**\
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAgentDownloadUrlV2ResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAgentDownloadUrlV2Response(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAgentDownloadUrlV2ResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAgentDownloadUrlV2ResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAlertRulesRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_ids: str = None,
        alert_names: str = None,
        alert_status: str = None,
        alert_type: str = None,
        cluster_id: str = None,
        page: int = None,
        product_code: str = None,
        region_id: str = None,
        size: int = None,
        tags: List[GetAlertRulesRequestTags] = None,
    ):
        # The unique IDs of alert rules.
        # 
        # *   If you do not specify this parameter, the API operation does not filter alert rules based on their IDs.
        # *   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.
        # 
        # > When you call the GetAlertRules operation, you can specify other request parameters to obtain the AlertIds parameter from the response. Then, you can specify the AlertIds parameter to query the specified alert rules.
        self.alert_ids = alert_ids
        # The names of alert rules. When you create alert rules of the new version, you cannot specify duplicate names. However, existing alert rules may have duplicate names. Therefore, the **AlertName** parameter does not uniquely identify an alert rule.
        # 
        # *   If you do not specify this parameter, the API operation does not filter alert rules based on their names.
        # *   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.
        self.alert_names = alert_names
        # The status of the alert rule. Valid values:
        # 
        # *   RUNNING
        # *   STOPPED
        # *   PAUSED
        # 
        # >  The PAUSED state indicates that the alert rule is abnormal and has been suspended. This may be because the specified threshold value is excessively large, or the associated cluster has been deleted.
        self.alert_status = alert_status
        # The type of the alert rule. This parameter is required for the new version of Alert Management.
        # 
        # *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
        # *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
        # *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Managed Service for Prometheus
        self.alert_type = alert_type
        # The ID of the monitored cluster.
        self.cluster_id = cluster_id
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # You do not need to configure this parameter.
        self.product_code = product_code
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The number of alert rules to return on each page.
        # 
        # This parameter is required.
        self.size = size
        # The list of tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_ids is not None:
            result['AlertIds'] = self.alert_ids
        if self.alert_names is not None:
            result['AlertNames'] = self.alert_names
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.page is not None:
            result['Page'] = self.page
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.size is not None:
            result['Size'] = self.size
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertIds') is not None:
            self.alert_ids = m.get('AlertIds')
        if m.get('AlertNames') is not None:
            self.alert_names = m.get('AlertNames')
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetAlertRulesRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems(TeaModel):
    def __init__(
        self,
        aggregate: str = None,
        metric_key: str = None,
        n: int = None,
        operator: str = None,
        value: str = None,
    ):
        # The aggregation method of the alert condition. Valid values:
        # 
        # *   AVG: calculates the average value
        # *   SUM: calculates the total value
        # *   MAX: selects the maximum value
        # *   MIN: selects the minimum value
        self.aggregate = aggregate
        # The metric of the alert condition.
        self.metric_key = metric_key
        # The last N minutes.
        self.n = n
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   CURRENT_GTE: greater than or equal to
        # *   CURRENT_LTE: less than or equal to
        # *   PREVIOUS_UP: increase in percentage compared with the previous period
        # *   PREVIOUS_DOWN: decrease in percentage compared with the previous period
        # *   HOH_UP: increase in percentage compared with the same period in the previous hour
        # *   HOH_DOWN: decrease in percentage compared with the same period in the previous hour
        # *   DOD_UP: increase in percentage compared with the same period in the previous day
        # *   DOD_DOWN: decrease in percentage compared with the same period in the previous day
        self.operator = operator
        # The threshold of the alert condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['Aggregate'] = self.aggregate
        if self.metric_key is not None:
            result['MetricKey'] = self.metric_key
        if self.n is not None:
            result['N'] = self.n
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Aggregate') is not None:
            self.aggregate = m.get('Aggregate')
        if m.get('MetricKey') is not None:
            self.metric_key = m.get('MetricKey')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent(TeaModel):
    def __init__(
        self,
        alert_rule_items: List[GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems] = None,
        condition: str = None,
    ):
        # The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.
        self.alert_rule_items = alert_rule_items
        # The relationship between multiple alert conditions specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:
        # 
        # *   OR: The alert rule is triggered if one of the conditions is met.
        # *   AND: The alert rule is triggered if all the conditions are met.
        self.condition = condition

    def validate(self):
        if self.alert_rule_items:
            for k in self.alert_rule_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertRuleItems'] = []
        if self.alert_rule_items is not None:
            for k in self.alert_rule_items:
                result['AlertRuleItems'].append(k.to_map() if k else None)
        if self.condition is not None:
            result['Condition'] = self.condition
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_rule_items = []
        if m.get('AlertRuleItems') is not None:
            for k in m.get('AlertRuleItems'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems()
                self.alert_rule_items.append(temp_model.from_map(k))
        if m.get('Condition') is not None:
            self.condition = m.get('Condition')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The key of the annotation.
        self.name = name
        # The value of the annotation.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        opt: str = None,
        show: bool = None,
        t: str = None,
        value: str = None,
    ):
        # The key of the filter condition.
        self.key = key
        # The logical operator of the filter condition. Valid values:
        # 
        # *   \\=: equal to
        # *   not: not equal to
        self.opt = opt
        # Indicates whether this filter condition is displayed on the frontend.
        self.show = show
        # The log type of Browser Monitoring. This field is not included in other filter conditions.
        self.t = t
        # The value of the filter condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.opt is not None:
            result['Opt'] = self.opt
        if self.show is not None:
            result['Show'] = self.show
        if self.t is not None:
            result['T'] = self.t
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Opt') is not None:
            self.opt = m.get('Opt')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        if m.get('T') is not None:
            self.t = m.get('T')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters(TeaModel):
    def __init__(
        self,
        filter_key: str = None,
        filter_opt: str = None,
        filter_values: List[str] = None,
    ):
        # The key of the filter condition.
        self.filter_key = filter_key
        # The logical operator of the filter condition.
        self.filter_opt = filter_opt
        # The details of the filter condition.
        self.filter_values = filter_values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_key is not None:
            result['FilterKey'] = self.filter_key
        if self.filter_opt is not None:
            result['FilterOpt'] = self.filter_opt
        if self.filter_values is not None:
            result['FilterValues'] = self.filter_values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FilterKey') is not None:
            self.filter_key = m.get('FilterKey')
        if m.get('FilterOpt') is not None:
            self.filter_opt = m.get('FilterOpt')
        if m.get('FilterValues') is not None:
            self.filter_values = m.get('FilterValues')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesFilters(TeaModel):
    def __init__(
        self,
        custom_slsfilters: List[GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters] = None,
        custom_slsgroup_by_dimensions: List[str] = None,
        custom_slswheres: List[str] = None,
        dim_filters: List[GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters] = None,
    ):
        # The custom filter condition of the Browser Monitoring alert rule.
        self.custom_slsfilters = custom_slsfilters
        # The information about the aggregation dimension.
        self.custom_slsgroup_by_dimensions = custom_slsgroup_by_dimensions
        # The details of the custom filter condition.
        self.custom_slswheres = custom_slswheres
        # The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.
        self.dim_filters = dim_filters

    def validate(self):
        if self.custom_slsfilters:
            for k in self.custom_slsfilters:
                if k:
                    k.validate()
        if self.dim_filters:
            for k in self.dim_filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomSLSFilters'] = []
        if self.custom_slsfilters is not None:
            for k in self.custom_slsfilters:
                result['CustomSLSFilters'].append(k.to_map() if k else None)
        if self.custom_slsgroup_by_dimensions is not None:
            result['CustomSLSGroupByDimensions'] = self.custom_slsgroup_by_dimensions
        if self.custom_slswheres is not None:
            result['CustomSLSWheres'] = self.custom_slswheres
        result['DimFilters'] = []
        if self.dim_filters is not None:
            for k in self.dim_filters:
                result['DimFilters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_slsfilters = []
        if m.get('CustomSLSFilters') is not None:
            for k in m.get('CustomSLSFilters'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters()
                self.custom_slsfilters.append(temp_model.from_map(k))
        if m.get('CustomSLSGroupByDimensions') is not None:
            self.custom_slsgroup_by_dimensions = m.get('CustomSLSGroupByDimensions')
        if m.get('CustomSLSWheres') is not None:
            self.custom_slswheres = m.get('CustomSLSWheres')
        self.dim_filters = []
        if m.get('DimFilters') is not None:
            for k in m.get('DimFilters'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters()
                self.dim_filters.append(temp_model.from_map(k))
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The tag key.
        self.name = name
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRulesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetAlertRulesResponseBodyPageBeanAlertRules(TeaModel):
    def __init__(
        self,
        alert_check_type: str = None,
        alert_group: int = None,
        alert_id: int = None,
        alert_name: str = None,
        alert_rule_content: GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent = None,
        alert_status: str = None,
        alert_type: str = None,
        annotations: List[GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations] = None,
        auto_add_new_application: bool = None,
        cluster_id: str = None,
        created_time: int = None,
        duration: str = None,
        extend: str = None,
        filters: GetAlertRulesResponseBodyPageBeanAlertRulesFilters = None,
        labels: List[GetAlertRulesResponseBodyPageBeanAlertRulesLabels] = None,
        level: str = None,
        message: str = None,
        metrics_type: str = None,
        notify_strategy: str = None,
        pids: List[str] = None,
        prom_ql: str = None,
        region_id: str = None,
        tags: List[GetAlertRulesResponseBodyPageBeanAlertRulesTags] = None,
        updated_time: int = None,
        user_id: str = None,
    ):
        # The alert check type of the Prometheus alert rule.
        # 
        # *   STATIC: static threshold
        # *   CUSTOM: custom PromQL
        self.alert_check_type = alert_check_type
        # The alert contact group ID of the Prometheus alert rule.
        # 
        # *   \\-1: custom PromQL
        # *   1: Kubernetes load
        # *   15: Kubernetes node
        self.alert_group = alert_group
        # The alert rule ID.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The content of the Application Monitoring or Browser Monitoring alert rule.
        self.alert_rule_content = alert_rule_content
        # The status of the alert rule. Valid values:
        # 
        # *   RUNNING
        # *   STOPPED
        # *   PAUSED
        # 
        # >  The PAUSED state indicates that the alert rule is abnormal and has been suspended. This may be because the specified threshold value is excessively large, or the associated cluster has been deleted.
        self.alert_status = alert_status
        # The type of the alert rule. Valid values:
        # 
        # *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
        # *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
        # *   PROMETHEUS_MONITORING_ALERT_RULE: Prometheus alert rule
        self.alert_type = alert_type
        # The annotations of the Prometheus alert rule.
        self.annotations = annotations
        # Indicates whether the alert rule is applied to new applications that are created in Application Monitoring or Browser Monitoring. Valid values:
        # 
        # *   `true`: yes
        # *   `false`: no
        self.auto_add_new_application = auto_add_new_application
        # The cluster ID of the Prometheus alert rule.
        self.cluster_id = cluster_id
        # The time when the alert rule was created. The value is a timestamp. Unit: milliseconds.
        self.created_time = created_time
        # The duration of the Prometheus alert rule.
        self.duration = duration
        # The extended fields.
        # 
        # >  For existing Application Monitoring alert rules, the fields contain information such as contacts, alert template, and notification content.
        self.extend = extend
        # The filter conditions of the Application Monitoring or Browser Monitoring alert rule.
        self.filters = filters
        # The tags of the Prometheus alert rule.
        self.labels = labels
        # The severity level of the Prometheus alert rule.
        # 
        # *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
        # *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
        # *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
        # *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
        # *   Default: Alert notifications are sent regardless of alert levels.
        self.level = level
        # The alert message of the Prometheus alert rule.
        self.message = message
        # The metric type of the Application Monitoring or Browser Monitoring alert rule.
        self.metrics_type = metrics_type
        # The name of the notification policy.
        self.notify_strategy = notify_strategy
        # The process ID (PID) of the application to which the Application Monitoring or Browser Monitoring alert rule is applied.
        self.pids = pids
        # The PromQL statement of the Prometheus alert rule.
        self.prom_ql = prom_ql
        # The region ID.
        self.region_id = region_id
        # The tags of the alert rule.
        self.tags = tags
        # The time when the alert rule was updated. The value is a timestamp. Unit: milliseconds.
        self.updated_time = updated_time
        # The ID of the Alibaba Cloud account.
        self.user_id = user_id

    def validate(self):
        if self.alert_rule_content:
            self.alert_rule_content.validate()
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.filters:
            self.filters.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_check_type is not None:
            result['AlertCheckType'] = self.alert_check_type
        if self.alert_group is not None:
            result['AlertGroup'] = self.alert_group
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.alert_rule_content is not None:
            result['AlertRuleContent'] = self.alert_rule_content.to_map()
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.auto_add_new_application is not None:
            result['AutoAddNewApplication'] = self.auto_add_new_application
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.extend is not None:
            result['Extend'] = self.extend
        if self.filters is not None:
            result['Filters'] = self.filters.to_map()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.metrics_type is not None:
            result['MetricsType'] = self.metrics_type
        if self.notify_strategy is not None:
            result['NotifyStrategy'] = self.notify_strategy
        if self.pids is not None:
            result['Pids'] = self.pids
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.updated_time is not None:
            result['UpdatedTime'] = self.updated_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertCheckType') is not None:
            self.alert_check_type = m.get('AlertCheckType')
        if m.get('AlertGroup') is not None:
            self.alert_group = m.get('AlertGroup')
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('AlertRuleContent') is not None:
            temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent()
            self.alert_rule_content = temp_model.from_map(m['AlertRuleContent'])
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('AutoAddNewApplication') is not None:
            self.auto_add_new_application = m.get('AutoAddNewApplication')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Extend') is not None:
            self.extend = m.get('Extend')
        if m.get('Filters') is not None:
            temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesFilters()
            self.filters = temp_model.from_map(m['Filters'])
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MetricsType') is not None:
            self.metrics_type = m.get('MetricsType')
        if m.get('NotifyStrategy') is not None:
            self.notify_strategy = m.get('NotifyStrategy')
        if m.get('Pids') is not None:
            self.pids = m.get('Pids')
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRulesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UpdatedTime') is not None:
            self.updated_time = m.get('UpdatedTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetAlertRulesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        alert_rules: List[GetAlertRulesResponseBodyPageBeanAlertRules] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The alert rules.
        self.alert_rules = alert_rules
        # The number of pages returned.
        self.page = page
        # The number of alert rules returned per page.
        self.size = size
        # The total number of queried alert rules.
        self.total = total

    def validate(self):
        if self.alert_rules:
            for k in self.alert_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertRules'] = []
        if self.alert_rules is not None:
            for k in self.alert_rules:
                result['AlertRules'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_rules = []
        if m.get('AlertRules') is not None:
            for k in m.get('AlertRules'):
                temp_model = GetAlertRulesResponseBodyPageBeanAlertRules()
                self.alert_rules.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: GetAlertRulesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned pages.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = GetAlertRulesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAppApiByPageRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time: int = None,
        interval_mills: int = None,
        pid: str = None,
        page_size: int = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The end of the time range to query. Unit: milliseconds.
        self.end_time = end_time
        # The time interval between the data shards to be queried. Unit: milliseconds. Minimum value: 60000. Maximum value: 2147483647.
        self.interval_mills = interval_mills
        # The process identifier (PID) of the application. For information about how to obtain a PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
        # 
        # This parameter is required.
        self.pid = pid
        # The number of entries to return on each page. This parameter is no longer supported. The number of entries to return on each page. Default value: 10.
        self.page_size = page_size
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The beginning of the time range to query. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval_mills is not None:
            result['IntervalMills'] = self.interval_mills
        if self.pid is not None:
            result['PId'] = self.pid
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IntervalMills') is not None:
            self.interval_mills = m.get('IntervalMills')
        if m.get('PId') is not None:
            self.pid = m.get('PId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetAppApiByPageResponseBodyData(TeaModel):
    def __init__(
        self,
        completed: bool = None,
        items: List[Dict[str, Any]] = None,
        page: int = None,
        page_size: int = None,
        total: str = None,
    ):
        # Is completed.
        self.completed = completed
        # The data entries.
        self.items = items
        # The page number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed is not None:
            result['Completed'] = self.completed
        if self.items is not None:
            result['Items'] = self.items
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Completed') is not None:
            self.completed = m.get('Completed')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetAppApiByPageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetAppApiByPageResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   2XX: The request was successful.
        # *   3XX: A redirection message was returned.
        # *   4XX: The request was invalid.
        # *   5XX: A server error occurred.
        self.code = code
        # The struct returned.
        self.data = data
        # The message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetAppApiByPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAppApiByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAppApiByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAppApiByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAppJVMConfigRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        pid: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The end of the time range to query. Unit: milliseconds.
        self.end_time = end_time
        # The IDof the application.
        #  
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Application Monitoring** > **Applications**. On the **Applications** page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The start of the time range to query. Unit: milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetAppJVMConfigResponseBodyJvmInfoList(TeaModel):
    def __init__(
        self,
        agent_version: str = None,
        host_name: str = None,
        ip: str = None,
        pid: str = None,
        proc_id: str = None,
        vm_args: str = None,
    ):
        # The version of the agent.
        self.agent_version = agent_version
        # The hostname.
        self.host_name = host_name
        # The IP address.
        self.ip = ip
        # The application ID.
        self.pid = pid
        # The process ID.
        self.proc_id = proc_id
        # The VM parameters.
        self.vm_args = vm_args

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_version is not None:
            result['AgentVersion'] = self.agent_version
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.proc_id is not None:
            result['ProcId'] = self.proc_id
        if self.vm_args is not None:
            result['VmArgs'] = self.vm_args
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentVersion') is not None:
            self.agent_version = m.get('AgentVersion')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('ProcId') is not None:
            self.proc_id = m.get('ProcId')
        if m.get('VmArgs') is not None:
            self.vm_args = m.get('VmArgs')
        return self


class GetAppJVMConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        jvm_info_list: List[GetAppJVMConfigResponseBodyJvmInfoList] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response code. Valid values: 2XX: The request is successful. 3XX: A redirection message is returned. 4XX: The request is invalid. 5XX: A server error occurs.
        self.code = code
        # The list of JVM information.
        self.jvm_info_list = jvm_info_list
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.jvm_info_list:
            for k in self.jvm_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['JvmInfoList'] = []
        if self.jvm_info_list is not None:
            for k in self.jvm_info_list:
                result['JvmInfoList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.jvm_info_list = []
        if m.get('JvmInfoList') is not None:
            for k in m.get('JvmInfoList'):
                temp_model = GetAppJVMConfigResponseBodyJvmInfoList()
                self.jvm_info_list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAppJVMConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAppJVMConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAppJVMConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuthTokenRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the ACK cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetAuthTokenResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # The returned authentication token.
        self.data = data
        # Additional Information.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Whether the query was successful:
        # - true: Success
        # - false: Failure
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetAuthTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAuthTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuthTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCloudClusterAllUrlRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the CloudMonitor instance.
        self.cluster_id = cluster_id
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetCloudClusterAllUrlResponseBodyDataRemoteUrl(TeaModel):
    def __init__(
        self,
        auth_token: bool = None,
        grafana_url: str = None,
        internet_grafana_url: str = None,
        internet_push_gateway_url: str = None,
        internet_remote_read_url: str = None,
        internet_remote_write_url: str = None,
        push_gateway_url: str = None,
        remote_read_url: str = None,
        remote_write_url: str = None,
        token: str = None,
    ):
        # Indicates whether authentication is enabled.
        self.auth_token = auth_token
        # The internal URL for Grafana.
        self.grafana_url = grafana_url
        # The public URL for Grafana.
        self.internet_grafana_url = internet_grafana_url
        # The public URL for Pushgateway.
        self.internet_push_gateway_url = internet_push_gateway_url
        # The public URL for remote read.
        self.internet_remote_read_url = internet_remote_read_url
        # The public URL for remote write.
        self.internet_remote_write_url = internet_remote_write_url
        # The internal URL for Pushgateway.
        self.push_gateway_url = push_gateway_url
        # The internal URL for remote read.
        self.remote_read_url = remote_read_url
        # The internal URL for remote write.
        self.remote_write_url = remote_write_url
        # The token value used for authentication.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.grafana_url is not None:
            result['GrafanaUrl'] = self.grafana_url
        if self.internet_grafana_url is not None:
            result['InternetGrafanaUrl'] = self.internet_grafana_url
        if self.internet_push_gateway_url is not None:
            result['InternetPushGatewayUrl'] = self.internet_push_gateway_url
        if self.internet_remote_read_url is not None:
            result['InternetRemoteReadUrl'] = self.internet_remote_read_url
        if self.internet_remote_write_url is not None:
            result['InternetRemoteWriteUrl'] = self.internet_remote_write_url
        if self.push_gateway_url is not None:
            result['PushGatewayUrl'] = self.push_gateway_url
        if self.remote_read_url is not None:
            result['RemoteReadUrl'] = self.remote_read_url
        if self.remote_write_url is not None:
            result['RemoteWriteUrl'] = self.remote_write_url
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('GrafanaUrl') is not None:
            self.grafana_url = m.get('GrafanaUrl')
        if m.get('InternetGrafanaUrl') is not None:
            self.internet_grafana_url = m.get('InternetGrafanaUrl')
        if m.get('InternetPushGatewayUrl') is not None:
            self.internet_push_gateway_url = m.get('InternetPushGatewayUrl')
        if m.get('InternetRemoteReadUrl') is not None:
            self.internet_remote_read_url = m.get('InternetRemoteReadUrl')
        if m.get('InternetRemoteWriteUrl') is not None:
            self.internet_remote_write_url = m.get('InternetRemoteWriteUrl')
        if m.get('PushGatewayUrl') is not None:
            self.push_gateway_url = m.get('PushGatewayUrl')
        if m.get('RemoteReadUrl') is not None:
            self.remote_read_url = m.get('RemoteReadUrl')
        if m.get('RemoteWriteUrl') is not None:
            self.remote_write_url = m.get('RemoteWriteUrl')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetCloudClusterAllUrlResponseBodyData(TeaModel):
    def __init__(
        self,
        product_code: str = None,
        region: str = None,
        remote_url: GetCloudClusterAllUrlResponseBodyDataRemoteUrl = None,
    ):
        # The identifier of the cloud service.
        self.product_code = product_code
        # The region ID.
        self.region = region
        # The URLs for remote read and write. The value is a JSON string.
        self.remote_url = remote_url

    def validate(self):
        if self.remote_url:
            self.remote_url.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.region is not None:
            result['Region'] = self.region
        if self.remote_url is not None:
            result['RemoteUrl'] = self.remote_url.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RemoteUrl') is not None:
            temp_model = GetCloudClusterAllUrlResponseBodyDataRemoteUrl()
            self.remote_url = temp_model.from_map(m['RemoteUrl'])
        return self


class GetCloudClusterAllUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[GetCloudClusterAllUrlResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # An array object.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetCloudClusterAllUrlResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetCloudClusterAllUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCloudClusterAllUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCloudClusterAllUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClusterAllUrlRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetClusterAllUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # The response parameters in the JSON format.
        self.data = data
        # The prompt information of the returned result.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Whether the query is successful:
        # - true: success
        # - false: failure
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetClusterAllUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetClusterAllUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClusterAllUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCommercialStatusRequest(TeaModel):
    def __init__(
        self,
        commodity_code: str = None,
        region_id: str = None,
    ):
        # The product code.
        # 
        # *   arms_app_post
        # *   arms_web_post
        # *   arms_promethues_public_cn
        # *   prometheus_pay_public_cn
        # *   xtrace
        # *   arms_serverless_public_cn
        # *   arms_rumserverless_public_cn
        # *   prometheus_serverless_public_cn
        # *   xtrace_serverless_public_cn
        # 
        # This parameter is required.
        self.commodity_code = commodity_code
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetCommercialStatusResponseBodyUserAndCommodityStatus(TeaModel):
    def __init__(
        self,
        basic: bool = None,
        charge_type: str = None,
        enable: bool = None,
        extra_info: Dict[str, Any] = None,
        free_days: int = None,
        lable: str = None,
        status: str = None,
    ):
        # Indicates whether you are using the Basic Edition.
        self.basic = basic
        # The billing method.
        self.charge_type = charge_type
        # Indicates whether the service is activated.
        self.enable = enable
        # The additional information.
        self.extra_info = extra_info
        # The number of days during which the service is free of charge.
        self.free_days = free_days
        # The tags.
        self.lable = lable
        # The commercialization status.
        # 
        # Valid values:
        # 
        # *   Normal: The service is activated.
        # *   Abnormal: An exception occurs during activation.
        # *   Free: The service is not activated.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.basic is not None:
            result['Basic'] = self.basic
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.free_days is not None:
            result['FreeDays'] = self.free_days
        if self.lable is not None:
            result['Lable'] = self.lable
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Basic') is not None:
            self.basic = m.get('Basic')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('FreeDays') is not None:
            self.free_days = m.get('FreeDays')
        if m.get('Lable') is not None:
            self.lable = m.get('Lable')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetCommercialStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_and_commodity_status: GetCommercialStatusResponseBodyUserAndCommodityStatus = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The commercialization status of the service.
        self.user_and_commodity_status = user_and_commodity_status

    def validate(self):
        if self.user_and_commodity_status:
            self.user_and_commodity_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_and_commodity_status is not None:
            result['UserAndCommodityStatus'] = self.user_and_commodity_status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserAndCommodityStatus') is not None:
            temp_model = GetCommercialStatusResponseBodyUserAndCommodityStatus()
            self.user_and_commodity_status = temp_model.from_map(m['UserAndCommodityStatus'])
        return self


class GetCommercialStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCommercialStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCommercialStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetExploreUrlRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        expression: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The query statement that corresponds to the data source.
        self.expression = expression
        # The region ID.
        self.region_id = region_id
        # The type of the Grafana data source.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetExploreUrlResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # Response parameters
        self.data = data
        # The prompt information of the returned result.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Whether the operation was successful:
        # - true: the operation was successful
        # - false: the operation failed
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetExploreUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetExploreUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetExploreUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGrafanaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        grafana_workspace_id: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The ID of the workspace.
        # 
        # This parameter is required.
        self.grafana_workspace_id = grafana_workspace_id
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetGrafanaWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GrafanaWorkspace = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   `2XX`: The request is successful.
        # *   `3XX`: A redirection message is returned.
        # *   `4XX`: The request is invalid.
        # *   `5XX`: A server error occurs.
        self.code = code
        # The information about the Grafana workspace.
        self.data = data
        # The error message returned when the request parameters are invalid.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GrafanaWorkspace()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class GetGrafanaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetGrafanaWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetGrafanaWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetIntegrationStateRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        integration: str = None,
        region_id: str = None,
    ):
        # The ID of the Container Service for Kubernetes (ACK) cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The abbreviation of the software that is supported by ARMS. Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
        # 
        # This parameter is required.
        self.integration = integration
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.integration is not None:
            result['Integration'] = self.integration
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Integration') is not None:
            self.integration = m.get('Integration')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetIntegrationStateResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        state: bool = None,
    ):
        # Status code. 200 means success, other status codes are exceptions.
        self.code = code
        # The prompt information of the returned result.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # The integration state of Prometheus dashboards and collection rules. Valid values:
        # 
        # *   `true`: The Prometheus dashboards and collection rules that monitor the software are integrated.
        # *   `false`: The Prometheus dashboards and collection rules that monitor the software are not integrated.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class GetIntegrationStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetIntegrationStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetIntegrationStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetManagedPrometheusStatusRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        vpc_id: str = None,
    ):
        # The cluster ID. This parameter is required if the ClusterType parameter is set to ask.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The type of the cluster. Valid values: ask and ecs.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource group id of the Prometheus instance.
        self.resource_group_id = resource_group_id
        # The ID of the virtual private cloud (VPC). This parameter is required if the ClusterType parameter is set to ecs.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetManagedPrometheusStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code.
        self.code = code
        # The installation status of the Prometheus agent.
        # 
        # *   Installing: The Prometheus agent is installed and no registration information is available.
        # *   Succeed: The Prometheus agent is installed and registered.
        # *   Failure: The Prometheus agent failed to be installed or registered.
        # *   Unknown: The installation status of the Prometheus agent is unknown.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetManagedPrometheusStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetManagedPrometheusStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetManagedPrometheusStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMultipleTraceRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        region_id: str = None,
        start_time: int = None,
        trace_ids: List[str] = None,
    ):
        # The time when the trace ends. The value is a timestamp. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The start time of the trace. The value is a timestamp. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The trace IDs.
        # 
        # This parameter is required.
        self.trace_ids = trace_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.trace_ids is not None:
            result['TraceIDs'] = self.trace_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TraceIDs') is not None:
            self.trace_ids = m.get('TraceIDs')
        return self


class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList(TeaModel):
    def __init__(
        self,
        tag_entry_list: List[GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList] = None,
        timestamp: int = None,
    ):
        # The tags of the trace.
        self.tag_entry_list = tag_entry_list
        # The time when the log was generated. The value is a timestamp.
        self.timestamp = timestamp

    def validate(self):
        if self.tag_entry_list:
            for k in self.tag_entry_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagEntryList'] = []
        if self.tag_entry_list is not None:
            for k in self.tag_entry_list:
                result['TagEntryList'].append(k.to_map() if k else None)
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag_entry_list = []
        if m.get('TagEntryList') is not None:
            for k in m.get('TagEntryList'):
                temp_model = GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList()
                self.tag_entry_list.append(temp_model.from_map(k))
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetMultipleTraceResponseBodyMultiCallChainInfosSpans(TeaModel):
    def __init__(
        self,
        duration: int = None,
        have_stack: bool = None,
        log_event_list: List[GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList] = None,
        operation_name: str = None,
        parent_span_id: str = None,
        result_code: str = None,
        rpc_id: str = None,
        rpc_type: int = None,
        service_ip: str = None,
        service_name: str = None,
        span_id: str = None,
        tag_entry_list: List[GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList] = None,
        timestamp: int = None,
        trace_id: str = None,
    ):
        # The amount of time consumed by the trace. Unit: milliseconds.
        self.duration = duration
        # Indicates whether a method stack was provided.
        # 
        # *   `true`: A method stack was provided.
        # *   `false`: No method stack was provided.
        self.have_stack = have_stack
        # The log events in the trace.
        self.log_event_list = log_event_list
        # The name of the traced span.
        self.operation_name = operation_name
        # The ID of the parent span.
        self.parent_span_id = parent_span_id
        # The status code returned.
        self.result_code = result_code
        # RPC ID
        self.rpc_id = rpc_id
        # The type of the remote procedure call (RPC) mode.
        # 
        # *   0: HTTP entry
        # *   25: HTTP call
        # *   1: High-speed Service Framework (HSF) call
        # *   2: HSF provision
        # *   40: on-premises API call
        # *   60: MySQL call
        # *   62: Oracle call
        # *   63: PostgreSQL call
        # *   70: Redis call
        # *   4: Taobao Distributed Data Layer (TDDL) call
        # *   5: Tair call
        # *   13: MetaQ message sending
        # *   252: MetaQ message receiving
        # *   3: notification sending
        # *   254: notification receiving
        # *   7: Apache Dubbo call
        # *   8: Apache Dubbo provision
        # *   19: SOFARPC call
        # *   18: SOFARPC provision
        # *   11: Distributed Service Framework (DSF) call
        # *   12: DSF provision
        # *   \\-1: unknown call
        self.rpc_type = rpc_type
        # The IP address of the host where the application resides.
        self.service_ip = service_ip
        # The name of the application.
        self.service_name = service_name
        # The span ID.
        self.span_id = span_id
        # The tags of the trace.
        self.tag_entry_list = tag_entry_list
        # The timestamp.
        self.timestamp = timestamp
        # The trace ID.
        self.trace_id = trace_id

    def validate(self):
        if self.log_event_list:
            for k in self.log_event_list:
                if k:
                    k.validate()
        if self.tag_entry_list:
            for k in self.tag_entry_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.have_stack is not None:
            result['HaveStack'] = self.have_stack
        result['LogEventList'] = []
        if self.log_event_list is not None:
            for k in self.log_event_list:
                result['LogEventList'].append(k.to_map() if k else None)
        if self.operation_name is not None:
            result['OperationName'] = self.operation_name
        if self.parent_span_id is not None:
            result['ParentSpanId'] = self.parent_span_id
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.rpc_id is not None:
            result['RpcId'] = self.rpc_id
        if self.rpc_type is not None:
            result['RpcType'] = self.rpc_type
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.span_id is not None:
            result['SpanId'] = self.span_id
        result['TagEntryList'] = []
        if self.tag_entry_list is not None:
            for k in self.tag_entry_list:
                result['TagEntryList'].append(k.to_map() if k else None)
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('HaveStack') is not None:
            self.have_stack = m.get('HaveStack')
        self.log_event_list = []
        if m.get('LogEventList') is not None:
            for k in m.get('LogEventList'):
                temp_model = GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList()
                self.log_event_list.append(temp_model.from_map(k))
        if m.get('OperationName') is not None:
            self.operation_name = m.get('OperationName')
        if m.get('ParentSpanId') is not None:
            self.parent_span_id = m.get('ParentSpanId')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('RpcId') is not None:
            self.rpc_id = m.get('RpcId')
        if m.get('RpcType') is not None:
            self.rpc_type = m.get('RpcType')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('SpanId') is not None:
            self.span_id = m.get('SpanId')
        self.tag_entry_list = []
        if m.get('TagEntryList') is not None:
            for k in m.get('TagEntryList'):
                temp_model = GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList()
                self.tag_entry_list.append(temp_model.from_map(k))
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class GetMultipleTraceResponseBodyMultiCallChainInfos(TeaModel):
    def __init__(
        self,
        spans: List[GetMultipleTraceResponseBodyMultiCallChainInfosSpans] = None,
        trace_id: str = None,
    ):
        # The details of the trace.
        self.spans = spans
        # The trace ID.
        self.trace_id = trace_id

    def validate(self):
        if self.spans:
            for k in self.spans:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Spans'] = []
        if self.spans is not None:
            for k in self.spans:
                result['Spans'].append(k.to_map() if k else None)
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.spans = []
        if m.get('Spans') is not None:
            for k in m.get('Spans'):
                temp_model = GetMultipleTraceResponseBodyMultiCallChainInfosSpans()
                self.spans.append(temp_model.from_map(k))
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class GetMultipleTraceResponseBody(TeaModel):
    def __init__(
        self,
        multi_call_chain_infos: List[GetMultipleTraceResponseBodyMultiCallChainInfos] = None,
        request_id: str = None,
    ):
        # The details of traces.
        self.multi_call_chain_infos = multi_call_chain_infos
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.multi_call_chain_infos:
            for k in self.multi_call_chain_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MultiCallChainInfos'] = []
        if self.multi_call_chain_infos is not None:
            for k in self.multi_call_chain_infos:
                result['MultiCallChainInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.multi_call_chain_infos = []
        if m.get('MultiCallChainInfos') is not None:
            for k in m.get('MultiCallChainInfos'):
                temp_model = GetMultipleTraceResponseBodyMultiCallChainInfos()
                self.multi_call_chain_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMultipleTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMultipleTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMultipleTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOnCallSchedulesDetailRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        id: int = None,
        start_time: str = None,
    ):
        # The date on which the shift ends. Format: `yyyy-MM-dd`.
        self.end_time = end_time
        # The ID of the scheduling policy.
        # 
        # This parameter is required.
        self.id = id
        # The date from which the shift starts. Format: `yyyy-MM-dd`.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.id is not None:
            result['Id'] = self.id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the user on duty.
        self.id = id
        # The name of the user on duty.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries(TeaModel):
    def __init__(
        self,
        end: str = None,
        simple_contact: GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact = None,
        start: str = None,
    ):
        # The date on which the user completed shift work.
        self.end = end
        # The information about the user on duty.
        self.simple_contact = simple_contact
        # The date from which the user started shift work.
        self.start = start

    def validate(self):
        if self.simple_contact:
            self.simple_contact.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.simple_contact is not None:
            result['SimpleContact'] = self.simple_contact.to_map()
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('SimpleContact') is not None:
            temp_model = GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact()
            self.simple_contact = temp_model.from_map(m['SimpleContact'])
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the scheduled user.
        self.id = id
        # The name of the scheduled user.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries(TeaModel):
    def __init__(
        self,
        start: str = None,
        end: str = None,
        simple_contact: GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact = None,
    ):
        # The date from which the scheduled user was supposed to start shift work.
        self.start = start
        # The date on which the scheduled user was supposed to complete shift work.
        self.end = end
        # The information about the scheduled user.
        self.simple_contact = simple_contact

    def validate(self):
        if self.simple_contact:
            self.simple_contact.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.start is not None:
            result['Start'] = self.start
        if self.end is not None:
            result['End'] = self.end
        if self.simple_contact is not None:
            result['SimpleContact'] = self.simple_contact.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Start') is not None:
            self.start = m.get('Start')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('SimpleContact') is not None:
            temp_model = GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact()
            self.simple_contact = temp_model.from_map(m['SimpleContact'])
        return self


class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the substitute.
        self.id = id
        # The name of the substitute.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries(TeaModel):
    def __init__(
        self,
        end: str = None,
        simple_contact: GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact = None,
        start: str = None,
    ):
        # The date on which the substitute was supposed to complete shift work.
        self.end = end
        # The information about the substitute.
        self.simple_contact = simple_contact
        # The date from which the substitute was supposed to start shift work.
        self.start = start

    def validate(self):
        if self.simple_contact:
            self.simple_contact.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.simple_contact is not None:
            result['SimpleContact'] = self.simple_contact.to_map()
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('SimpleContact') is not None:
            temp_model = GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact()
            self.simple_contact = temp_model.from_map(m['SimpleContact'])
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions(TeaModel):
    def __init__(
        self,
        end_time_of_day: str = None,
        restriction_type: str = None,
        start_time_of_day: str = None,
    ):
        # The end time of the shift per day.
        self.end_time_of_day = end_time_of_day
        # The type of the limit. Valid values:
        # 
        # *   daily_restriction
        # *   weekly_restriction
        self.restriction_type = restriction_type
        # The start time of the shift per day.
        self.start_time_of_day = start_time_of_day

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time_of_day is not None:
            result['EndTimeOfDay'] = self.end_time_of_day
        if self.restriction_type is not None:
            result['RestrictionType'] = self.restriction_type
        if self.start_time_of_day is not None:
            result['StartTimeOfDay'] = self.start_time_of_day
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTimeOfDay') is not None:
            self.end_time_of_day = m.get('EndTimeOfDay')
        if m.get('RestrictionType') is not None:
            self.restriction_type = m.get('RestrictionType')
        if m.get('StartTimeOfDay') is not None:
            self.start_time_of_day = m.get('StartTimeOfDay')
        return self


class GetOnCallSchedulesDetailResponseBodyDataScheduleLayers(TeaModel):
    def __init__(
        self,
        contact_ids: List[int] = None,
        restrictions: List[GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions] = None,
        rotation_type: str = None,
        shift_length: int = None,
        start_time: str = None,
    ):
        # The ID list of users on duty.
        self.contact_ids = contact_ids
        # The limit on the time of the shift.
        self.restrictions = restrictions
        # The type of the shift. Valid values:
        # 
        # *   DAY
        # *   WEEK
        # *   CUSTOM
        self.rotation_type = rotation_type
        # The shift cycle. Unit: hours.
        self.shift_length = shift_length
        # The date on which the shift change took effect.
        self.start_time = start_time

    def validate(self):
        if self.restrictions:
            for k in self.restrictions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        result['Restrictions'] = []
        if self.restrictions is not None:
            for k in self.restrictions:
                result['Restrictions'].append(k.to_map() if k else None)
        if self.rotation_type is not None:
            result['RotationType'] = self.rotation_type
        if self.shift_length is not None:
            result['ShiftLength'] = self.shift_length
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        self.restrictions = []
        if m.get('Restrictions') is not None:
            for k in m.get('Restrictions'):
                temp_model = GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions()
                self.restrictions.append(temp_model.from_map(k))
        if m.get('RotationType') is not None:
            self.rotation_type = m.get('RotationType')
        if m.get('ShiftLength') is not None:
            self.shift_length = m.get('ShiftLength')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetOnCallSchedulesDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        alert_robot_id: int = None,
        description: str = None,
        id: int = None,
        name: str = None,
        rendered_finnal_entries: List[GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries] = None,
        rendered_layer_entries: List[List[GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries]] = None,
        rendered_substitude_entries: List[GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries] = None,
        schedule_layers: List[GetOnCallSchedulesDetailResponseBodyDataScheduleLayers] = None,
    ):
        # The URL of the DingTalk chatbot, which is used to receive notifications about shift changes.
        self.alert_robot_id = alert_robot_id
        # The description of the scheduling policy.
        self.description = description
        # The ID of the scheduling policy.
        self.id = id
        # The name of the scheduling policy.
        self.name = name
        # The information about the final user on duty.
        self.rendered_finnal_entries = rendered_finnal_entries
        # The scheduled users on duty within a time range.
        self.rendered_layer_entries = rendered_layer_entries
        # The information about the substitutes within a time range.
        self.rendered_substitude_entries = rendered_substitude_entries
        # The information about the shift.
        self.schedule_layers = schedule_layers

    def validate(self):
        if self.rendered_finnal_entries:
            for k in self.rendered_finnal_entries:
                if k:
                    k.validate()
        if self.rendered_layer_entries:
            for k in self.rendered_layer_entries:
                for k1 in k:
                    if k1:
                        k1.validate()
        if self.rendered_substitude_entries:
            for k in self.rendered_substitude_entries:
                if k:
                    k.validate()
        if self.schedule_layers:
            for k in self.schedule_layers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_robot_id is not None:
            result['AlertRobotId'] = self.alert_robot_id
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['RenderedFinnalEntries'] = []
        if self.rendered_finnal_entries is not None:
            for k in self.rendered_finnal_entries:
                result['RenderedFinnalEntries'].append(k.to_map() if k else None)
        result['RenderedLayerEntries'] = []
        if self.rendered_layer_entries is not None:
            for k in self.rendered_layer_entries:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['RenderedLayerEntries'].append(l1)
        result['RenderedSubstitudeEntries'] = []
        if self.rendered_substitude_entries is not None:
            for k in self.rendered_substitude_entries:
                result['RenderedSubstitudeEntries'].append(k.to_map() if k else None)
        result['ScheduleLayers'] = []
        if self.schedule_layers is not None:
            for k in self.schedule_layers:
                result['ScheduleLayers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertRobotId') is not None:
            self.alert_robot_id = m.get('AlertRobotId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.rendered_finnal_entries = []
        if m.get('RenderedFinnalEntries') is not None:
            for k in m.get('RenderedFinnalEntries'):
                temp_model = GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries()
                self.rendered_finnal_entries.append(temp_model.from_map(k))
        self.rendered_layer_entries = []
        if m.get('RenderedLayerEntries') is not None:
            for k in m.get('RenderedLayerEntries'):
                l1 = []
                for k1 in k:
                    temp_model = GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries()
                    l1.append(temp_model.from_map(k1))
                self.rendered_layer_entries.append(l1)
        self.rendered_substitude_entries = []
        if m.get('RenderedSubstitudeEntries') is not None:
            for k in m.get('RenderedSubstitudeEntries'):
                temp_model = GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries()
                self.rendered_substitude_entries.append(temp_model.from_map(k))
        self.schedule_layers = []
        if m.get('ScheduleLayers') is not None:
            for k in m.get('ScheduleLayers'):
                temp_model = GetOnCallSchedulesDetailResponseBodyDataScheduleLayers()
                self.schedule_layers.append(temp_model.from_map(k))
        return self


class GetOnCallSchedulesDetailResponseBody(TeaModel):
    def __init__(
        self,
        data: GetOnCallSchedulesDetailResponseBodyData = None,
        request_id: str = None,
    ):
        # The information about the scheduling policy.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetOnCallSchedulesDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetOnCallSchedulesDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOnCallSchedulesDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOnCallSchedulesDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusApiTokenRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetPrometheusApiTokenResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        token: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The token required for integrating Prometheus Service.
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.token is not None:
            result['Token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        return self


class GetPrometheusApiTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusApiTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusApiTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        global_view_cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the global aggregation instance.
        # 
        # This parameter is required.
        self.global_view_cluster_id = global_view_cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The struct returned.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetPrometheusInstanceResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The tag key.
        self.tag_key = tag_key
        # The tag value.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class GetPrometheusInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        access_type: str = None,
        archive_duration: int = None,
        auth_free_read_policy: str = None,
        auth_free_write_policy: str = None,
        auth_token: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        db_instance_status: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_free_write: bool = None,
        enable_auth_token: str = None,
        extra_info: Dict[str, str] = None,
        grafana_instance_id: str = None,
        http_api_inter_url: str = None,
        http_api_intra_url: str = None,
        payment_type: str = None,
        payment_type_update_time: str = None,
        product: str = None,
        push_gateway_inter_url: str = None,
        push_gateway_intra_url: str = None,
        region_id: str = None,
        remote_read_inter_url: str = None,
        remote_read_intra_url: str = None,
        remote_write_inter_url: str = None,
        remote_write_intra_url: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        security_group_id: str = None,
        storage_duration: int = None,
        sub_clusters_json: str = None,
        support_auth_types: List[str] = None,
        tags: List[GetPrometheusInstanceResponseBodyDataTags] = None,
        user_id: str = None,
        v_switch_id: str = None,
        version: str = None,
        vpc_id: str = None,
    ):
        # The permission type. Valid values: readWrite, readOnly, and httpReadOnly
        self.access_type = access_type
        # The number of days for which data is automatically archived after the storage duration expires. Valid values: 60, 90, 180, and 365. 0 indicates that the data is not archived.
        self.archive_duration = archive_duration
        # The whitelist of IP addresses for which password-free read is enabled.
        self.auth_free_read_policy = auth_free_read_policy
        # The whitelist of IP addresses for which password-free write is enabled.
        self.auth_free_write_policy = auth_free_write_policy
        # The authorization token.
        self.auth_token = auth_token
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The name of the monitoring object.
        self.cluster_name = cluster_name
        # *   remote-write: general-purpose Prometheus instance
        # *   ecs: Prometheus instances for ECS
        # *   cloud-monitor: Prometheus instance for Alibaba Cloud services in the Chinese mainland
        # *   cloud-product: Prometheus instance for Alibaba Cloud services outside the Chinese mainland
        # *   global-view: global aggregation instance
        # *   aliyun-cs: Prometheus instance for Container Service
        self.cluster_type = cluster_type
        # The data storage status at the backend.
        self.db_instance_status = db_instance_status
        # Indicates whether password-free read is enabled.
        self.enable_auth_free_read = enable_auth_free_read
        # Indicates whether password-free write is enabled.
        self.enable_auth_free_write = enable_auth_free_write
        # Indicates whether access token authentication is enabled.
        self.enable_auth_token = enable_auth_token
        # The extra information.
        self.extra_info = extra_info
        # The ID of the Grafana workspace.
        self.grafana_instance_id = grafana_instance_id
        # The public URL for the HTTP API.
        self.http_api_inter_url = http_api_inter_url
        # The internal URL for the HTTP API.
        self.http_api_intra_url = http_api_intra_url
        # The billing method. Valid values:
        # 
        # *   PREPAY: subscription
        # *   POSTPAY: pay-as-you-go
        self.payment_type = payment_type
        # The time when the billing method was modified.
        self.payment_type_update_time = payment_type_update_time
        # The product to which the Prometheus instance belongs. Valid values: arms and cms.
        self.product = product
        # The public URL for Pushgateway.
        self.push_gateway_inter_url = push_gateway_inter_url
        # The internal URL for Pushgateway.
        self.push_gateway_intra_url = push_gateway_intra_url
        # The region ID.
        self.region_id = region_id
        # The public URL for remote read.
        self.remote_read_inter_url = remote_read_inter_url
        # The internal URL for remote read.
        self.remote_read_intra_url = remote_read_intra_url
        # The public URL for remote write.
        self.remote_write_inter_url = remote_write_inter_url
        # The internal URL for remote write.
        self.remote_write_intra_url = remote_write_intra_url
        # The ID of the resource group to which the instance belongs.
        self.resource_group_id = resource_group_id
        # The type of the resource. Set the value to PROMETHEUS.
        self.resource_type = resource_type
        # The ID of the security group. This parameter is returned only for Prometheus instances for ECS.
        self.security_group_id = security_group_id
        # The data storage duration. Unit: days.
        self.storage_duration = storage_duration
        # The child instances of the Prometheus instance for GlobalView. The value is a JSON string.
        self.sub_clusters_json = sub_clusters_json
        # The supported authentication types.
        self.support_auth_types = support_auth_types
        # The tags of the instance.
        self.tags = tags
        # The user ID.
        self.user_id = user_id
        # The vSwitch ID. This parameter is returned only for Prometheus instances for ECS.
        self.v_switch_id = v_switch_id
        self.version = version
        # The VPC ID. This parameter is returned only for Prometheus instances for ECS.
        self.vpc_id = vpc_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_type is not None:
            result['AccessType'] = self.access_type
        if self.archive_duration is not None:
            result['ArchiveDuration'] = self.archive_duration
        if self.auth_free_read_policy is not None:
            result['AuthFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_free_write_policy is not None:
            result['AuthFreeWritePolicy'] = self.auth_free_write_policy
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.db_instance_status is not None:
            result['DbInstanceStatus'] = self.db_instance_status
        if self.enable_auth_free_read is not None:
            result['EnableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_free_write is not None:
            result['EnableAuthFreeWrite'] = self.enable_auth_free_write
        if self.enable_auth_token is not None:
            result['EnableAuthToken'] = self.enable_auth_token
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.grafana_instance_id is not None:
            result['GrafanaInstanceId'] = self.grafana_instance_id
        if self.http_api_inter_url is not None:
            result['HttpApiInterUrl'] = self.http_api_inter_url
        if self.http_api_intra_url is not None:
            result['HttpApiIntraUrl'] = self.http_api_intra_url
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.payment_type_update_time is not None:
            result['PaymentTypeUpdateTime'] = self.payment_type_update_time
        if self.product is not None:
            result['Product'] = self.product
        if self.push_gateway_inter_url is not None:
            result['PushGatewayInterUrl'] = self.push_gateway_inter_url
        if self.push_gateway_intra_url is not None:
            result['PushGatewayIntraUrl'] = self.push_gateway_intra_url
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remote_read_inter_url is not None:
            result['RemoteReadInterUrl'] = self.remote_read_inter_url
        if self.remote_read_intra_url is not None:
            result['RemoteReadIntraUrl'] = self.remote_read_intra_url
        if self.remote_write_inter_url is not None:
            result['RemoteWriteInterUrl'] = self.remote_write_inter_url
        if self.remote_write_intra_url is not None:
            result['RemoteWriteIntraUrl'] = self.remote_write_intra_url
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.storage_duration is not None:
            result['StorageDuration'] = self.storage_duration
        if self.sub_clusters_json is not None:
            result['SubClustersJson'] = self.sub_clusters_json
        if self.support_auth_types is not None:
            result['SupportAuthTypes'] = self.support_auth_types
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.version is not None:
            result['Version'] = self.version
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessType') is not None:
            self.access_type = m.get('AccessType')
        if m.get('ArchiveDuration') is not None:
            self.archive_duration = m.get('ArchiveDuration')
        if m.get('AuthFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('AuthFreeReadPolicy')
        if m.get('AuthFreeWritePolicy') is not None:
            self.auth_free_write_policy = m.get('AuthFreeWritePolicy')
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DbInstanceStatus') is not None:
            self.db_instance_status = m.get('DbInstanceStatus')
        if m.get('EnableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('EnableAuthFreeRead')
        if m.get('EnableAuthFreeWrite') is not None:
            self.enable_auth_free_write = m.get('EnableAuthFreeWrite')
        if m.get('EnableAuthToken') is not None:
            self.enable_auth_token = m.get('EnableAuthToken')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('GrafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('GrafanaInstanceId')
        if m.get('HttpApiInterUrl') is not None:
            self.http_api_inter_url = m.get('HttpApiInterUrl')
        if m.get('HttpApiIntraUrl') is not None:
            self.http_api_intra_url = m.get('HttpApiIntraUrl')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('PaymentTypeUpdateTime') is not None:
            self.payment_type_update_time = m.get('PaymentTypeUpdateTime')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('PushGatewayInterUrl') is not None:
            self.push_gateway_inter_url = m.get('PushGatewayInterUrl')
        if m.get('PushGatewayIntraUrl') is not None:
            self.push_gateway_intra_url = m.get('PushGatewayIntraUrl')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoteReadInterUrl') is not None:
            self.remote_read_inter_url = m.get('RemoteReadInterUrl')
        if m.get('RemoteReadIntraUrl') is not None:
            self.remote_read_intra_url = m.get('RemoteReadIntraUrl')
        if m.get('RemoteWriteInterUrl') is not None:
            self.remote_write_inter_url = m.get('RemoteWriteInterUrl')
        if m.get('RemoteWriteIntraUrl') is not None:
            self.remote_write_intra_url = m.get('RemoteWriteIntraUrl')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('StorageDuration') is not None:
            self.storage_duration = m.get('StorageDuration')
        if m.get('SubClustersJson') is not None:
            self.sub_clusters_json = m.get('SubClustersJson')
        if m.get('SupportAuthTypes') is not None:
            self.support_auth_types = m.get('SupportAuthTypes')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetPrometheusInstanceResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetPrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetPrometheusInstanceResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # The response parameters.
        self.data = data
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetPrometheusInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        instance_id: int = None,
        integration_type: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance. Valid values: aliyun-cs and ecs.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the exporter.
        # 
        # This parameter is required.
        self.instance_id = instance_id
        # The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
        # 
        # This parameter is required.
        self.integration_type = integration_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetPrometheusIntegrationResponseBodyData(TeaModel):
    def __init__(
        self,
        can_delete: bool = None,
        can_editor: bool = None,
        cluster_id: str = None,
        container_name: str = None,
        describe: str = None,
        exporter_type: str = None,
        instance_id: int = None,
        instance_name: str = None,
        integration_type: str = None,
        namespace: str = None,
        need_upgrade: bool = None,
        param: str = None,
        show_describe: bool = None,
        show_log: str = None,
        status: str = None,
        target: str = None,
        version: str = None,
    ):
        # Indicates whether the exporter can be deleted.
        self.can_delete = can_delete
        # Indicates whether the exporter can be modified.
        self.can_editor = can_editor
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The container name.
        self.container_name = container_name
        # The description of the exporter.
        self.describe = describe
        # The type of the exporter.
        self.exporter_type = exporter_type
        # The ID of the exporter.
        self.instance_id = instance_id
        # The name of the exporter.
        self.instance_name = instance_name
        # The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
        self.integration_type = integration_type
        # The namespace.
        self.namespace = namespace
        # Indicates whether an upgrade is required.
        self.need_upgrade = need_upgrade
        # The parameters of the exporter. Format: JSON string.
        self.param = param
        # Indicates whether the description is displayed.
        self.show_describe = show_describe
        # Indicates whether the exporter logs are displayed.
        self.show_log = show_log
        # The status of the exporter.
        self.status = status
        # The monitored IP address.
        self.target = target
        # The version information.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_delete is not None:
            result['CanDelete'] = self.can_delete
        if self.can_editor is not None:
            result['CanEditor'] = self.can_editor
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.exporter_type is not None:
            result['ExporterType'] = self.exporter_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.need_upgrade is not None:
            result['NeedUpgrade'] = self.need_upgrade
        if self.param is not None:
            result['Param'] = self.param
        if self.show_describe is not None:
            result['ShowDescribe'] = self.show_describe
        if self.show_log is not None:
            result['ShowLog'] = self.show_log
        if self.status is not None:
            result['Status'] = self.status
        if self.target is not None:
            result['Target'] = self.target
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanDelete') is not None:
            self.can_delete = m.get('CanDelete')
        if m.get('CanEditor') is not None:
            self.can_editor = m.get('CanEditor')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('ExporterType') is not None:
            self.exporter_type = m.get('ExporterType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NeedUpgrade') is not None:
            self.need_upgrade = m.get('NeedUpgrade')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('ShowDescribe') is not None:
            self.show_describe = m.get('ShowDescribe')
        if m.get('ShowLog') is not None:
            self.show_log = m.get('ShowLog')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetPrometheusIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetPrometheusIntegrationResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # The returned struct.
        self.data = data
        # The message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetPrometheusIntegrationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPrometheusIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPrometheusMonitoringRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        monitoring_name: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the monitoring configuration.
        # 
        # This parameter is required.
        self.monitoring_name = monitoring_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the monitoring configuration. 
        # Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
        # Valid values for a Prometheus instance for ECS: customJob and probe.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.monitoring_name is not None:
            result['MonitoringName'] = self.monitoring_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MonitoringName') is not None:
            self.monitoring_name = m.get('MonitoringName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPrometheusMonitoringResponseBodyData(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        config_yaml: str = None,
        monitoring_name: str = None,
        status: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The monitoring configuration. The value is a YAML string.
        self.config_yaml = config_yaml
        # The name of the monitoring configuration.
        self.monitoring_name = monitoring_name
        # The status of the monitoring configuration. Valid values: run and stop.
        self.status = status
        # The type of the monitoring configuration. Valid values: serviceMonitor, podMonitor, customJob, and probe.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.monitoring_name is not None:
            result['MonitoringName'] = self.monitoring_name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('MonitoringName') is not None:
            self.monitoring_name = m.get('MonitoringName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPrometheusMonitoringResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetPrometheusMonitoringResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetPrometheusMonitoringResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPrometheusMonitoringResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPrometheusMonitoringResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPrometheusMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRecordingRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetRecordingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The recording rule.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetRecordingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRecordingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRecordingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRetcodeAppByPidRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetRetcodeAppByPidRequest(TeaModel):
    def __init__(
        self,
        pid: str = None,
        region_id: str = None,
        tags: List[GetRetcodeAppByPidRequestTags] = None,
    ):
        # The PID of the application. To obtain the PID of the application, perform the following steps: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of the application. The URL in the address bar contains the PID of the application. The PID is in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with the at sign (@) to obtain xxx@74xxx.
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region.
        self.region_id = region_id
        # The list of tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetRetcodeAppByPidRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetRetcodeAppByPidResponseBodyRetcodeAppTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetRetcodeAppByPidResponseBodyRetcodeApp(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        pid: str = None,
        resource_group_id: str = None,
        retcode_app_type: str = None,
        tags: List[GetRetcodeAppByPidResponseBodyRetcodeAppTags] = None,
    ):
        # The ID of the application. The parameter is an auto-increment parameter.
        self.app_id = app_id
        # The name of the application that is monitored by Browser Monitoring.
        self.app_name = app_name
        # The process identifier (PID) of the application.
        self.pid = pid
        # The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
        self.resource_group_id = resource_group_id
        # The type of the application that is monitored by Browser Monitoring. Valid values:
        # 
        # *   `web`: web application
        # *   `weex`: Weex mobile app
        # *   `mini_dd`: DingTalk mini program
        # *   `mini_alipay`: Alipay mini program
        # *   `mini_wx`: WeChat mini program
        # *   `mini_common`: mini program on other platforms
        self.retcode_app_type = retcode_app_type
        # The tags that are attached to the instance.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retcode_app_type is not None:
            result['RetcodeAppType'] = self.retcode_app_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetcodeAppType') is not None:
            self.retcode_app_type = m.get('RetcodeAppType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetRetcodeAppByPidResponseBodyRetcodeAppTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetRetcodeAppByPidResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        retcode_app: GetRetcodeAppByPidResponseBodyRetcodeApp = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The returned application data.
        self.retcode_app = retcode_app

    def validate(self):
        if self.retcode_app:
            self.retcode_app.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.retcode_app is not None:
            result['RetcodeApp'] = self.retcode_app.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RetcodeApp') is not None:
            temp_model = GetRetcodeAppByPidResponseBodyRetcodeApp()
            self.retcode_app = temp_model.from_map(m['RetcodeApp'])
        return self


class GetRetcodeAppByPidResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRetcodeAppByPidResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRetcodeAppByPidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRetcodeDataByQueryRequest(TeaModel):
    def __init__(
        self,
        from_: int = None,
        pid: str = None,
        query: str = None,
        region_id: str = None,
        to: int = None,
    ):
        # The beginning of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        # 
        # This parameter is required.
        self.from_ = from_
        # The ID of the application.
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
        # 
        # This parameter is required.
        self.pid = pid
        # The query statement that conforms to the query syntax of a Log Service Logstore.
        # 
        # This parameter is required.
        self.query = query
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The end of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        # 
        # This parameter is required.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['From'] = self.from_
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.query is not None:
            result['Query'] = self.query
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class GetRetcodeDataByQueryResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   2XX: The request was successful.
        # *   3XX: A redirection message was returned.
        # *   4XX: The request was invalid.
        # *   5XX: A server error occurred.
        self.code = code
        # The Browser Monitoring data returned.
        self.data = data
        # The error message returned if the call fails.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRetcodeDataByQueryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRetcodeDataByQueryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRetcodeDataByQueryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRetcodeLogstoreRequest(TeaModel):
    def __init__(
        self,
        pid: str = None,
        region_id: str = None,
    ):
        # The process identifier (PID) of the application. To obtain the PID of the application, perform the following steps: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of the application. The URL in the address bar contains the PID of the application. The PID is in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with the at sign (@) to obtain xxx@74xxx.
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig(TeaModel):
    def __init__(
        self,
        logstore: str = None,
        project: str = None,
        region_id: str = None,
    ):
        # The Log Service Logstore.
        self.logstore = logstore
        # The Log Service project.
        self.project = project
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.logstore is not None:
            result['Logstore'] = self.logstore
        if self.project is not None:
            result['Project'] = self.project
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Logstore') is not None:
            self.logstore = m.get('Logstore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetRetcodeLogstoreResponseBodyData(TeaModel):
    def __init__(
        self,
        message: str = None,
        retcode_slsconfig: GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig = None,
        status: str = None,
    ):
        # The content of the log.
        self.message = message
        # The information about Log Service.
        self.retcode_slsconfig = retcode_slsconfig
        # The status of the request.
        self.status = status

    def validate(self):
        if self.retcode_slsconfig:
            self.retcode_slsconfig.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.retcode_slsconfig is not None:
            result['RetcodeSLSConfig'] = self.retcode_slsconfig.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RetcodeSLSConfig') is not None:
            temp_model = GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig()
            self.retcode_slsconfig = temp_model.from_map(m['RetcodeSLSConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetRetcodeLogstoreResponseBody(TeaModel):
    def __init__(
        self,
        data: GetRetcodeLogstoreResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = GetRetcodeLogstoreResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetRetcodeLogstoreResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRetcodeLogstoreResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRetcodeLogstoreResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRetcodeShareUrlRequest(TeaModel):
    def __init__(
        self,
        pid: str = None,
    ):
        # The process identifier (PID) of the application. 
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the `pid=xxx` format. The PID is usually percent encoded as `xxx%40xxx`. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `eb4zdose6v%409781be0f44d****`, you must replace `%40` with @ to obtain `eb4zdose6v@9781be0f44d****`.
        # 
        # This parameter is required.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class GetRetcodeShareUrlResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        url: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The logon-free URL of the application.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetRetcodeShareUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRetcodeShareUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRetcodeShareUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumAppInfoRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        pid: str = None,
        region_id: str = None,
    ):
        # The group to which the application belongs.
        self.app_group = app_group
        # The process ID (PID) of the application.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig(TeaModel):
    def __init__(
        self,
        default_config: Dict[str, DataBonreeSDKConfigModuleConfigDefaultConfigValue] = None,
        enable: bool = None,
        version_configs: Dict[str, DataBonreeSDKConfigModuleConfigVersionConfigsValue] = None,
    ):
        # The default configuration of the application.
        self.default_config = default_config
        # Indicates whether the configuration is enabled.
        self.enable = enable
        # The version configurations of the application.
        self.version_configs = version_configs

    def validate(self):
        if self.default_config:
            for v in self.default_config.values():
                if v:
                    v.validate()
        if self.version_configs:
            for v in self.version_configs.values():
                if v:
                    v.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['defaultConfig'] = {}
        if self.default_config is not None:
            for k, v in self.default_config.items():
                result['defaultConfig'][k] = v.to_map()
        if self.enable is not None:
            result['enable'] = self.enable
        result['versionConfigs'] = {}
        if self.version_configs is not None:
            for k, v in self.version_configs.items():
                result['versionConfigs'][k] = v.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.default_config = {}
        if m.get('defaultConfig') is not None:
            for k, v in m.get('defaultConfig').items():
                temp_model = DataBonreeSDKConfigModuleConfigDefaultConfigValue()
                self.default_config[k] = temp_model.from_map(v)
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        self.version_configs = {}
        if m.get('versionConfigs') is not None:
            for k, v in m.get('versionConfigs').items():
                temp_model = DataBonreeSDKConfigModuleConfigVersionConfigsValue()
                self.version_configs[k] = temp_model.from_map(v)
        return self


class GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig(TeaModel):
    def __init__(
        self,
        sampling_rate: int = None,
        sampling_type: int = None,
    ):
        self.sampling_rate = sampling_rate
        self.sampling_type = sampling_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sampling_rate is not None:
            result['samplingRate'] = self.sampling_rate
        if self.sampling_type is not None:
            result['samplingType'] = self.sampling_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('samplingRate') is not None:
            self.sampling_rate = m.get('samplingRate')
        if m.get('samplingType') is not None:
            self.sampling_type = m.get('samplingType')
        return self


class GetRumAppInfoResponseBodyDataBonreeSDKConfig(TeaModel):
    def __init__(
        self,
        module_config: GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig = None,
        sampling_config: GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig = None,
    ):
        # The module configuration.
        self.module_config = module_config
        self.sampling_config = sampling_config

    def validate(self):
        if self.module_config:
            self.module_config.validate()
        if self.sampling_config:
            self.sampling_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.module_config is not None:
            result['moduleConfig'] = self.module_config.to_map()
        if self.sampling_config is not None:
            result['samplingConfig'] = self.sampling_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('moduleConfig') is not None:
            temp_model = GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig()
            self.module_config = temp_model.from_map(m['moduleConfig'])
        if m.get('samplingConfig') is not None:
            temp_model = GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig()
            self.sampling_config = temp_model.from_map(m['samplingConfig'])
        return self


class GetRumAppInfoResponseBodyDataServiceDomainConfigs(TeaModel):
    def __init__(
        self,
        description: str = None,
        domain: str = None,
        propagator_types: List[str] = None,
        sampling_rate: int = None,
        tracing: bool = None,
    ):
        # The description.
        self.description = description
        # The domain name or IP address.
        self.domain = domain
        # The trace propagation protocols. This parameter is required if the tracing analysis feature is enabled.
        self.propagator_types = propagator_types
        self.sampling_rate = sampling_rate
        # Indicates whether the tracing analysis feature is enabled. To enable the tracing analysis feature, you must activate Managed Service for OpenTelemetry. Valid values:
        # 
        # *   `true`: enables the tracing analysis feature. If you enable the tracing analysis feature, related headers are inserted into requests for the domain name.
        # *   `false`: disables the tracing analysis feature.
        self.tracing = tracing

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.propagator_types is not None:
            result['PropagatorTypes'] = self.propagator_types
        if self.sampling_rate is not None:
            result['SamplingRate'] = self.sampling_rate
        if self.tracing is not None:
            result['Tracing'] = self.tracing
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('PropagatorTypes') is not None:
            self.propagator_types = m.get('PropagatorTypes')
        if m.get('SamplingRate') is not None:
            self.sampling_rate = m.get('SamplingRate')
        if m.get('Tracing') is not None:
            self.tracing = m.get('Tracing')
        return self


class GetRumAppInfoResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetRumAppInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        app_type: str = None,
        backend_service_trace_region: str = None,
        bonree_sdkconfig: GetRumAppInfoResponseBodyDataBonreeSDKConfig = None,
        cdn_domain: str = None,
        create_time: str = None,
        description: str = None,
        endpoint: str = None,
        is_subscription: str = None,
        name: str = None,
        nick_name: str = None,
        package_name: str = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        service_domain_configs: List[GetRumAppInfoResponseBodyDataServiceDomainConfigs] = None,
        sls_logstore: str = None,
        sls_project: str = None,
        status: str = None,
        tags: List[GetRumAppInfoResponseBodyDataTags] = None,
        type: str = None,
    ):
        # The group to which the application belongs.
        self.app_group = app_group
        # The application type. Valid values: web, miniapp, ios, and android.
        self.app_type = app_type
        # The region where the backend is deployed.
        self.backend_service_trace_region = backend_service_trace_region
        # The collection configurations.
        self.bonree_sdkconfig = bonree_sdkconfig
        # The domain name of the SDK.
        self.cdn_domain = cdn_domain
        # The time when the application was created. The value is a timestamp. Unit: milliseconds.
        self.create_time = create_time
        # The description of the application.
        self.description = description
        # The endpoint that is used to report application data.
        self.endpoint = endpoint
        # Indicates whether the application is subscribed. Valid values: true and false.
        self.is_subscription = is_subscription
        # The application name.
        self.name = name
        # The alias of the application.
        self.nick_name = nick_name
        # The name of the application package.
        self.package_name = package_name
        # The application ID.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The list of service domain configurations. Only mobile applications are supported.
        self.service_domain_configs = service_domain_configs
        # The name of the Simple Log Service Logstore that stores application data.
        self.sls_logstore = sls_logstore
        # The name of the Simple Log Service project that stores application data.
        self.sls_project = sls_project
        # The status of the application. Valid values: created, running, and stopped.
        self.status = status
        # The tags.
        self.tags = tags
        # The type of the application. Valid value: RUM.
        self.type = type

    def validate(self):
        if self.bonree_sdkconfig:
            self.bonree_sdkconfig.validate()
        if self.service_domain_configs:
            for k in self.service_domain_configs:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.backend_service_trace_region is not None:
            result['BackendServiceTraceRegion'] = self.backend_service_trace_region
        if self.bonree_sdkconfig is not None:
            result['BonreeSDKConfig'] = self.bonree_sdkconfig.to_map()
        if self.cdn_domain is not None:
            result['CdnDomain'] = self.cdn_domain
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.is_subscription is not None:
            result['IsSubscription'] = self.is_subscription
        if self.name is not None:
            result['Name'] = self.name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.package_name is not None:
            result['PackageName'] = self.package_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['ServiceDomainConfigs'] = []
        if self.service_domain_configs is not None:
            for k in self.service_domain_configs:
                result['ServiceDomainConfigs'].append(k.to_map() if k else None)
        if self.sls_logstore is not None:
            result['SlsLogstore'] = self.sls_logstore
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('BackendServiceTraceRegion') is not None:
            self.backend_service_trace_region = m.get('BackendServiceTraceRegion')
        if m.get('BonreeSDKConfig') is not None:
            temp_model = GetRumAppInfoResponseBodyDataBonreeSDKConfig()
            self.bonree_sdkconfig = temp_model.from_map(m['BonreeSDKConfig'])
        if m.get('CdnDomain') is not None:
            self.cdn_domain = m.get('CdnDomain')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('IsSubscription') is not None:
            self.is_subscription = m.get('IsSubscription')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('PackageName') is not None:
            self.package_name = m.get('PackageName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.service_domain_configs = []
        if m.get('ServiceDomainConfigs') is not None:
            for k in m.get('ServiceDomainConfigs'):
                temp_model = GetRumAppInfoResponseBodyDataServiceDomainConfigs()
                self.service_domain_configs.append(temp_model.from_map(k))
        if m.get('SlsLogstore') is not None:
            self.sls_logstore = m.get('SlsLogstore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetRumAppInfoResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetRumAppInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetRumAppInfoResponseBodyData = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The details of the application.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetRumAppInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRumAppInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumAppInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumAppInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumAppsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetRumAppsRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        app_id: str = None,
        app_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[GetRumAppsRequestTags] = None,
    ):
        # The group to which the application belongs.
        self.app_group = app_group
        # The application ID.
        self.app_id = app_id
        # The name of the application. You can specify only one application name in each request.
        self.app_name = app_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetRumAppsRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetRumAppsShrinkRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        app_id: str = None,
        app_name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags_shrink: str = None,
    ):
        # The group to which the application belongs.
        self.app_group = app_group
        # The application ID.
        self.app_id = app_id
        # The name of the application. You can specify only one application name in each request.
        self.app_name = app_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class GetRumAppsResponseBodyAppListServiceDomainConfigs(TeaModel):
    def __init__(
        self,
        description: str = None,
        domain: str = None,
        propagator_types: List[str] = None,
        tracing: str = None,
    ):
        # The description.
        self.description = description
        # The domain name or IP address.
        self.domain = domain
        # The trace propagation protocols. This parameter is required if the tracing analysis feature is enabled.
        self.propagator_types = propagator_types
        # Indicates whether the tracing analysis feature is enabled. To enable the tracing analysis feature, you must activate Managed Service for OpenTelemetry. Valid values:
        # 
        # *   `true`: enables the tracing analysis feature. If you enable the tracing analysis feature, related headers are inserted into requests for the domain name.
        # *   `false`: disables the tracing analysis feature.
        self.tracing = tracing

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.propagator_types is not None:
            result['PropagatorTypes'] = self.propagator_types
        if self.tracing is not None:
            result['Tracing'] = self.tracing
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('PropagatorTypes') is not None:
            self.propagator_types = m.get('PropagatorTypes')
        if m.get('Tracing') is not None:
            self.tracing = m.get('Tracing')
        return self


class GetRumAppsResponseBodyAppListTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key. The tag key can be up to 128 characters in length. It cannot start with aliyun or acs: and cannot contain http:// or https://.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetRumAppsResponseBodyAppList(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        create_time: Any = None,
        description: str = None,
        endpoint: str = None,
        is_subscription: bool = None,
        name: str = None,
        nick_name: str = None,
        package_name: str = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        service_domain_configs: List[GetRumAppsResponseBodyAppListServiceDomainConfigs] = None,
        sls_logstore: str = None,
        sls_project: str = None,
        status: str = None,
        tags: List[GetRumAppsResponseBodyAppListTags] = None,
        type: str = None,
    ):
        # The application type. Valid values: web, miniapp, ios, and android.
        self.app_type = app_type
        # The time when the application was created. The value is a timestamp.
        self.create_time = create_time
        # The description of the application.
        self.description = description
        # The endpoint that is used to report application data.
        self.endpoint = endpoint
        # Indicates whether the application is subscribed. Valid values: true and false.
        self.is_subscription = is_subscription
        # The application name.
        self.name = name
        # The alias of the application.
        self.nick_name = nick_name
        # The package name of the Android application.
        self.package_name = package_name
        # The application ID.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The list of service domain configurations. Only mobile applications are supported.
        self.service_domain_configs = service_domain_configs
        # The name of the Simple Log Service Logstore that stores application data.
        self.sls_logstore = sls_logstore
        # The name of the Simple Log Service project that stores application data.
        self.sls_project = sls_project
        # The status of the application. Valid values: created, running, and stopped.
        self.status = status
        # The tags.
        self.tags = tags
        # The type of the application. Valid value: RUM.
        self.type = type

    def validate(self):
        if self.service_domain_configs:
            for k in self.service_domain_configs:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.is_subscription is not None:
            result['IsSubscription'] = self.is_subscription
        if self.name is not None:
            result['Name'] = self.name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.package_name is not None:
            result['PackageName'] = self.package_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['ServiceDomainConfigs'] = []
        if self.service_domain_configs is not None:
            for k in self.service_domain_configs:
                result['ServiceDomainConfigs'].append(k.to_map() if k else None)
        if self.sls_logstore is not None:
            result['SlsLogstore'] = self.sls_logstore
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('IsSubscription') is not None:
            self.is_subscription = m.get('IsSubscription')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('PackageName') is not None:
            self.package_name = m.get('PackageName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.service_domain_configs = []
        if m.get('ServiceDomainConfigs') is not None:
            for k in m.get('ServiceDomainConfigs'):
                temp_model = GetRumAppsResponseBodyAppListServiceDomainConfigs()
                self.service_domain_configs.append(temp_model.from_map(k))
        if m.get('SlsLogstore') is not None:
            self.sls_logstore = m.get('SlsLogstore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetRumAppsResponseBodyAppListTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetRumAppsResponseBody(TeaModel):
    def __init__(
        self,
        app_list: List[GetRumAppsResponseBodyAppList] = None,
        code: int = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The queried applications.
        self.app_list = app_list
        # The response code. The status code 200 indicates that the request was successful.
        self.code = code
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.app_list:
            for k in self.app_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppList'] = []
        if self.app_list is not None:
            for k in self.app_list:
                result['AppList'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_list = []
        if m.get('AppList') is not None:
            for k in m.get('AppList'):
                temp_model = GetRumAppsResponseBodyAppList()
                self.app_list.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRumAppsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumAppsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumAppsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumDataForPageRequest(TeaModel):
    def __init__(
        self,
        app_group: str = None,
        current_page: int = None,
        end_time: int = None,
        page_size: int = None,
        pid: str = None,
        query: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The group to which the application belongs.
        self.app_group = app_group
        # The page number.
        self.current_page = current_page
        # The beginning of the time range to query. The time is accurate to seconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The number of entries per page.
        self.page_size = page_size
        # The application ID.
        self.pid = pid
        # A query statement that complies with the query syntax of Simple Log Service Logstore. For more information, see the parameters corresponding to this operation on the console page.
        # 
        # This parameter is required.
        self.query = query
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The beginning of the time range to query. The time is accurate to seconds.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group is not None:
            result['AppGroup'] = self.app_group
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.query is not None:
            result['Query'] = self.query
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroup') is not None:
            self.app_group = m.get('AppGroup')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Query') is not None:
            self.query = m.get('Query')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetRumDataForPageResponseBodyData(TeaModel):
    def __init__(
        self,
        authentication: str = None,
        completion: str = None,
        items: List[Dict[str, Any]] = None,
        page: str = None,
        page_size: str = None,
        preference: str = None,
        total: str = None,
    ):
        # A reserved parameter. Ignore this parameter.
        self.authentication = authentication
        # Indicates whether the query ends. Valid values: true and false.
        self.completion = completion
        # The queried data.
        self.items = items
        # The page number.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # A reserved parameter. Ignore this parameter.
        self.preference = preference
        # The total number of entries returned.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authentication is not None:
            result['Authentication'] = self.authentication
        if self.completion is not None:
            result['Completion'] = self.completion
        if self.items is not None:
            result['Items'] = self.items
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.preference is not None:
            result['Preference'] = self.preference
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Authentication') is not None:
            self.authentication = m.get('Authentication')
        if m.get('Completion') is not None:
            self.completion = m.get('Completion')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Preference') is not None:
            self.preference = m.get('Preference')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetRumDataForPageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetRumDataForPageResponseBodyData = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The responses code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetRumDataForPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRumDataForPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumDataForPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumDataForPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumExceptionStackRequest(TeaModel):
    def __init__(
        self,
        exception_binary_images: str = None,
        exception_stack: str = None,
        exception_thread_id: str = None,
        extra_info: str = None,
        pid: str = None,
        region_id: str = None,
        sourcemap_type: str = None,
    ):
        # The binary images, which represent all executable files loaded into the process address space when a crash occurs.
        self.exception_binary_images = exception_binary_images
        # The exception stack information. Set the value to a JSON string. call_stack.info represents the stack information, call_stack.thread.name represents the thread name, and call_stack.thread.id represents the thread ID. This parameter is exactly the same as the exception.stack parameter in the logstore-rum Logstore of Simple Log Service.
        self.exception_stack = exception_stack
        # The ID of the exception thread.
        self.exception_thread_id = exception_thread_id
        self.extra_info = extra_info
        # The application ID.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The file type. Valid values:
        # 
        # - source-map: SourceMap files
        # - mapping: symbol table files for Android
        # - dsym: dSYM files for iOS
        self.sourcemap_type = sourcemap_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exception_binary_images is not None:
            result['ExceptionBinaryImages'] = self.exception_binary_images
        if self.exception_stack is not None:
            result['ExceptionStack'] = self.exception_stack
        if self.exception_thread_id is not None:
            result['ExceptionThreadId'] = self.exception_thread_id
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sourcemap_type is not None:
            result['SourcemapType'] = self.sourcemap_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ExceptionBinaryImages') is not None:
            self.exception_binary_images = m.get('ExceptionBinaryImages')
        if m.get('ExceptionStack') is not None:
            self.exception_stack = m.get('ExceptionStack')
        if m.get('ExceptionThreadId') is not None:
            self.exception_thread_id = m.get('ExceptionThreadId')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SourcemapType') is not None:
            self.sourcemap_type = m.get('SourcemapType')
        return self


class GetRumExceptionStackResponseBodyDataThreadInfoList(TeaModel):
    def __init__(
        self,
        thread_detail: str = None,
        thread_tag: str = None,
    ):
        self.thread_detail = thread_detail
        self.thread_tag = thread_tag

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.thread_detail is not None:
            result['ThreadDetail'] = self.thread_detail
        if self.thread_tag is not None:
            result['ThreadTag'] = self.thread_tag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ThreadDetail') is not None:
            self.thread_detail = m.get('ThreadDetail')
        if m.get('ThreadTag') is not None:
            self.thread_tag = m.get('ThreadTag')
        return self


class GetRumExceptionStackResponseBodyData(TeaModel):
    def __init__(
        self,
        binary_images: str = None,
        crash_address: str = None,
        crash_reason: str = None,
        lines: List[str] = None,
        module_name: str = None,
        thread_id: str = None,
        thread_info_list: List[GetRumExceptionStackResponseBodyDataThreadInfoList] = None,
        uuid: str = None,
    ):
        self.binary_images = binary_images
        self.crash_address = crash_address
        self.crash_reason = crash_reason
        # The list of stacks.
        self.lines = lines
        self.module_name = module_name
        # The thread ID.
        self.thread_id = thread_id
        self.thread_info_list = thread_info_list
        self.uuid = uuid

    def validate(self):
        if self.thread_info_list:
            for k in self.thread_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.binary_images is not None:
            result['BinaryImages'] = self.binary_images
        if self.crash_address is not None:
            result['CrashAddress'] = self.crash_address
        if self.crash_reason is not None:
            result['CrashReason'] = self.crash_reason
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.thread_id is not None:
            result['ThreadId'] = self.thread_id
        result['ThreadInfoList'] = []
        if self.thread_info_list is not None:
            for k in self.thread_info_list:
                result['ThreadInfoList'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BinaryImages') is not None:
            self.binary_images = m.get('BinaryImages')
        if m.get('CrashAddress') is not None:
            self.crash_address = m.get('CrashAddress')
        if m.get('CrashReason') is not None:
            self.crash_reason = m.get('CrashReason')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ThreadId') is not None:
            self.thread_id = m.get('ThreadId')
        self.thread_info_list = []
        if m.get('ThreadInfoList') is not None:
            for k in m.get('ThreadInfoList'):
                temp_model = GetRumExceptionStackResponseBodyDataThreadInfoList()
                self.thread_info_list.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetRumExceptionStackResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetRumExceptionStackResponseBodyData = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The responses code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message returned if the request failed.
        self.message = message
        # Id of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetRumExceptionStackResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRumExceptionStackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumExceptionStackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumExceptionStackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumOcuStatisticDataRequestFilter(TeaModel):
    def __init__(
        self,
        key: str = None,
        op_type: str = None,
        value: Any = None,
    ):
        # The key of the filter condition. Three types of filter conditions are provided:
        # 
        # *   Application name: pid (Note that the application name is displayed, but the application ID is actually specified)
        # *   Application type: siteType
        # *   Data type: dataType
        self.key = key
        # The type of the operator. Valid value: in.
        self.op_type = op_type
        # The value of the filter condition. The value is a JSON array of strings.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetRumOcuStatisticDataRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        filter: List[GetRumOcuStatisticDataRequestFilter] = None,
        group: List[str] = None,
        page: int = None,
        page_size: int = None,
        query_type: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter condition. Three types of filter conditions are provided:
        # 
        # *   Application name: pid (Note that the application name is displayed, but the application ID is actually specified)
        # *   Application type: siteType
        # *   Data type: dataType
        self.filter = filter
        # The grouping fields. Valid values:
        # 
        # *   siteType: The total number of OCUs is grouped by application type.
        # *   dataType: The total number of OCUs is grouped by data type.
        # *   pid: The total number of OCUs is grouped by application ID.
        # *   appName: The total number of OCUs is grouped by application name.
        # *   startTime: The total number of OCUs is grouped by start time.
        self.group = group
        # The page number.
        # 
        # This parameter is required.
        self.page = page
        # The number of entries per page.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The type of the query. To query non-time series data, set the value to INSTANT. To query time series data, set the value to TIME_SERIES.
        self.query_type = query_type
        # The region ID.
        self.region_id = region_id
        # The beginning of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.group is not None:
            result['Group'] = self.group
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = GetRumOcuStatisticDataRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetRumOcuStatisticDataShrinkRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        filter_shrink: str = None,
        group_shrink: str = None,
        page: int = None,
        page_size: int = None,
        query_type: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter condition. Three types of filter conditions are provided:
        # 
        # *   Application name: pid (Note that the application name is displayed, but the application ID is actually specified)
        # *   Application type: siteType
        # *   Data type: dataType
        self.filter_shrink = filter_shrink
        # The grouping fields. Valid values:
        # 
        # *   siteType: The total number of OCUs is grouped by application type.
        # *   dataType: The total number of OCUs is grouped by data type.
        # *   pid: The total number of OCUs is grouped by application ID.
        # *   appName: The total number of OCUs is grouped by application name.
        # *   startTime: The total number of OCUs is grouped by start time.
        self.group_shrink = group_shrink
        # The page number.
        # 
        # This parameter is required.
        self.page = page
        # The number of entries per page.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The type of the query. To query non-time series data, set the value to INSTANT. To query time series data, set the value to TIME_SERIES.
        self.query_type = query_type
        # The region ID.
        self.region_id = region_id
        # The beginning of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter_shrink is not None:
            result['Filter'] = self.filter_shrink
        if self.group_shrink is not None:
            result['Group'] = self.group_shrink
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Filter') is not None:
            self.filter_shrink = m.get('Filter')
        if m.get('Group') is not None:
            self.group_shrink = m.get('Group')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetRumOcuStatisticDataResponseBodyData(TeaModel):
    def __init__(
        self,
        complete: bool = None,
        items: List[Dict[str, Any]] = None,
        page: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # Indicates whether the next page exists.
        self.complete = complete
        # The queried data.
        self.items = items
        # The page number.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete is not None:
            result['Complete'] = self.complete
        if self.items is not None:
            result['Items'] = self.items
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Complete') is not None:
            self.complete = m.get('Complete')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetRumOcuStatisticDataResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetRumOcuStatisticDataResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetRumOcuStatisticDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetRumOcuStatisticDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumOcuStatisticDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumOcuStatisticDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRumUploadFilesRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        pid: str = None,
        region_id: str = None,
        version_id: str = None,
    ):
        # The file type. Valid values: source-map: SourceMap files. mapping: symbol table files for Android. dsym: dSYM files for iOS.
        self.app_type = app_type
        # The process ID (PID) of the application.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The version number of the files. If you do not specify this parameter, all versions of the files are returned by default.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetRumUploadFilesResponseBodyData(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        last_modified_time: Any = None,
        size: str = None,
        uuid: str = None,
        version_id: str = None,
    ):
        # The file name.
        self.file_name = file_name
        # The time when the file was last modified. The value is a timestamp.
        self.last_modified_time = last_modified_time
        # The size of the file. Unit: bytes.
        self.size = size
        # The file ID.
        self.uuid = uuid
        # The version number of the file.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.last_modified_time is not None:
            result['LastModifiedTime'] = self.last_modified_time
        if self.size is not None:
            result['Size'] = self.size
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('LastModifiedTime') is not None:
            self.last_modified_time = m.get('LastModifiedTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class GetRumUploadFilesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[GetRumUploadFilesResponseBodyData] = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The queried files.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetRumUploadFilesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRumUploadFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRumUploadFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRumUploadFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSourceMapInfoRequest(TeaModel):
    def __init__(
        self,
        ascending_sequence: bool = None,
        edition: str = None,
        id: str = None,
        keyword: str = None,
        order_field: str = None,
        region_id: str = None,
    ):
        # The order in which the files are sorted. Valid values:
        # 
        # *   true: ascending order
        # *   false: descending order
        self.ascending_sequence = ascending_sequence
        # The version of the SourceMap file.
        self.edition = edition
        # The ID of the SourceMap file.
        # 
        # This parameter is required.
        self.id = id
        # The keyword in the file name. The files are searched by keyword.
        self.keyword = keyword
        # The criterion by which the files are sorted. Valid values:
        # 
        # *   version: The files are sorted by version.
        # *   uploadTime: The files are sorted by upload time.
        self.order_field = order_field
        # The ID of the region.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ascending_sequence is not None:
            result['AscendingSequence'] = self.ascending_sequence
        if self.edition is not None:
            result['Edition'] = self.edition
        if self.id is not None:
            result['ID'] = self.id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.order_field is not None:
            result['OrderField'] = self.order_field
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AscendingSequence') is not None:
            self.ascending_sequence = m.get('AscendingSequence')
        if m.get('Edition') is not None:
            self.edition = m.get('Edition')
        if m.get('ID') is not None:
            self.id = m.get('ID')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('OrderField') is not None:
            self.order_field = m.get('OrderField')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetSourceMapInfoResponseBodySourceMapList(TeaModel):
    def __init__(
        self,
        fid: str = None,
        file_name: str = None,
        size: str = None,
        upload_time: str = None,
        version: str = None,
    ):
        # The ID of the SourceMap file.
        self.fid = fid
        # The name of the SourceMap file.
        self.file_name = file_name
        # The size of the file. Unit: KB.
        self.size = size
        # The timestamp that indicates when the file was uploaded.
        self.upload_time = upload_time
        # The version of the file.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fid is not None:
            result['Fid'] = self.fid
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.size is not None:
            result['Size'] = self.size
        if self.upload_time is not None:
            result['UploadTime'] = self.upload_time
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Fid') is not None:
            self.fid = m.get('Fid')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('UploadTime') is not None:
            self.upload_time = m.get('UploadTime')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetSourceMapInfoResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        source_map_list: List[GetSourceMapInfoResponseBodySourceMapList] = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # The details of the SourceMap file.
        self.source_map_list = source_map_list

    def validate(self):
        if self.source_map_list:
            for k in self.source_map_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SourceMapList'] = []
        if self.source_map_list is not None:
            for k in self.source_map_list:
                result['SourceMapList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.source_map_list = []
        if m.get('SourceMapList') is not None:
            for k in m.get('SourceMapList'):
                temp_model = GetSourceMapInfoResponseBodySourceMapList()
                self.source_map_list.append(temp_model.from_map(k))
        return self


class GetSourceMapInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSourceMapInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSourceMapInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStackRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        pid: str = None,
        region_id: str = None,
        rpc_id: str = None,
        span_id: str = None,
        start_time: int = None,
        trace_id: str = None,
    ):
        # The end time of the call method.
        self.end_time = end_time
        # The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the remote procedure call (RPC) mode. You can obtain the ID by calling the **GetTrace** operation.
        # 
        # This parameter is required.
        self.rpc_id = rpc_id
        self.span_id = span_id
        # The start time of the call method.
        self.start_time = start_time
        # The trace ID. You can log on to the Application Real-Time Monitoring Service (ARMS) console and obtain the trace ID on the **Trace Query** page.
        # 
        # This parameter is required.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rpc_id is not None:
            result['RpcID'] = self.rpc_id
        if self.span_id is not None:
            result['SpanID'] = self.span_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RpcID') is not None:
            self.rpc_id = m.get('RpcID')
        if m.get('SpanID') is not None:
            self.span_id = m.get('SpanID')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class GetStackResponseBodyStackInfoExtInfo(TeaModel):
    def __init__(
        self,
        info: str = None,
        type: str = None,
    ):
        # The content of the custom parameter.
        self.info = info
        # The type of the custom parameter.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetStackResponseBodyStackInfo(TeaModel):
    def __init__(
        self,
        api: str = None,
        call_count: str = None,
        duration: int = None,
        exception: str = None,
        ext_info: GetStackResponseBodyStackInfoExtInfo = None,
        line: str = None,
        rpc_id: str = None,
        service_name: str = None,
        start_time: int = None,
    ):
        # The name of the operation.
        self.api = api
        self.call_count = call_count
        # The duration. Unit: milliseconds.
        self.duration = duration
        # The error message.
        self.exception = exception
        # The information about the array object.
        self.ext_info = ext_info
        # The number of rows in the method stack information.
        self.line = line
        # The ID of the RPC mode.
        self.rpc_id = rpc_id
        # The name of the service.
        self.service_name = service_name
        # The start time of the call method.
        self.start_time = start_time

    def validate(self):
        if self.ext_info:
            self.ext_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api is not None:
            result['Api'] = self.api
        if self.call_count is not None:
            result['CallCount'] = self.call_count
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.exception is not None:
            result['Exception'] = self.exception
        if self.ext_info is not None:
            result['ExtInfo'] = self.ext_info.to_map()
        if self.line is not None:
            result['Line'] = self.line
        if self.rpc_id is not None:
            result['RpcId'] = self.rpc_id
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Api') is not None:
            self.api = m.get('Api')
        if m.get('CallCount') is not None:
            self.call_count = m.get('CallCount')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Exception') is not None:
            self.exception = m.get('Exception')
        if m.get('ExtInfo') is not None:
            temp_model = GetStackResponseBodyStackInfoExtInfo()
            self.ext_info = temp_model.from_map(m['ExtInfo'])
        if m.get('Line') is not None:
            self.line = m.get('Line')
        if m.get('RpcId') is not None:
            self.rpc_id = m.get('RpcId')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetStackResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stack_info: List[GetStackResponseBodyStackInfo] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information of the method stack.
        self.stack_info = stack_info

    def validate(self):
        if self.stack_info:
            for k in self.stack_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StackInfo'] = []
        if self.stack_info is not None:
            for k in self.stack_info:
                result['StackInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.stack_info = []
        if m.get('StackInfo') is not None:
            for k in m.get('StackInfo'):
                temp_model = GetStackResponseBodyStackInfo()
                self.stack_info.append(temp_model.from_map(k))
        return self


class GetStackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSyntheticMonitorsRequestFilter(TeaModel):
    def __init__(
        self,
        monitor_category: int = None,
        network: int = None,
        task_type: int = None,
    ):
        # The type of the monitoring point. Valid values: 1: PC. 2: mobile device.
        # 
        # This parameter is required.
        self.monitor_category = monitor_category
        # The network type. Valid values: 1: private network. 2: Internet.
        # 
        # This parameter is required.
        self.network = network
        # The type of the monitoring task. Valid values:
        # 
        # 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed. 6: file download.
        # 
        # This parameter is required.
        self.task_type = task_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_category is not None:
            result['MonitorCategory'] = self.monitor_category
        if self.network is not None:
            result['Network'] = self.network
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MonitorCategory') is not None:
            self.monitor_category = m.get('MonitorCategory')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GetSyntheticMonitorsRequest(TeaModel):
    def __init__(
        self,
        filter: GetSyntheticMonitorsRequestFilter = None,
        region_id: str = None,
    ):
        # The query conditions.
        # 
        # This parameter is required.
        self.filter = filter
        # The region ID.
        self.region_id = region_id

    def validate(self):
        if self.filter:
            self.filter.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['Filter'] = self.filter.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Filter') is not None:
            temp_model = GetSyntheticMonitorsRequestFilter()
            self.filter = temp_model.from_map(m['Filter'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetSyntheticMonitorsShrinkRequest(TeaModel):
    def __init__(
        self,
        filter_shrink: str = None,
        region_id: str = None,
    ):
        # The query conditions.
        # 
        # This parameter is required.
        self.filter_shrink = filter_shrink
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_shrink is not None:
            result['Filter'] = self.filter_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Filter') is not None:
            self.filter_shrink = m.get('Filter')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetSyntheticMonitorsResponseBodyData(TeaModel):
    def __init__(
        self,
        available: str = None,
        can_be_selected: bool = None,
        city: str = None,
        city_code: str = None,
        client_type: int = None,
        country: str = None,
        ipv_6: int = None,
        operator: str = None,
        operator_code: str = None,
        region: str = None,
    ):
        # Indicates whether the monitoring point is available. Valid values: true and false.
        self.available = available
        # Indicates whether the monitoring point is selected. Valid values: true and false.
        self.can_be_selected = can_be_selected
        # The city.
        self.city = city
        # The city code.
        self.city_code = city_code
        # The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
        self.client_type = client_type
        # The country.
        self.country = country
        # Indicates whether IPv6 is supported. Valid values: 0: IPv6 is not supported. 1: IPv6 is supported.
        self.ipv_6 = ipv_6
        # The carrier.
        self.operator = operator
        # The carrier code.
        self.operator_code = operator_code
        # The region.
        self.region = region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available is not None:
            result['Available'] = self.available
        if self.can_be_selected is not None:
            result['CanBeSelected'] = self.can_be_selected
        if self.city is not None:
            result['City'] = self.city
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.country is not None:
            result['Country'] = self.country
        if self.ipv_6 is not None:
            result['Ipv6'] = self.ipv_6
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.operator_code is not None:
            result['OperatorCode'] = self.operator_code
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Available') is not None:
            self.available = m.get('Available')
        if m.get('CanBeSelected') is not None:
            self.can_be_selected = m.get('CanBeSelected')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('Country') is not None:
            self.country = m.get('Country')
        if m.get('Ipv6') is not None:
            self.ipv_6 = m.get('Ipv6')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('OperatorCode') is not None:
            self.operator_code = m.get('OperatorCode')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class GetSyntheticMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[GetSyntheticMonitorsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The list of monitoring points.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetSyntheticMonitorsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetSyntheticMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSyntheticMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSyntheticMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSyntheticTaskDetailRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_id: str = None,
    ):
        # The region ID. Default value: cn-hangzhou.
        self.region_id = region_id
        # The ID of the synthetic monitoring task.
        # 
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList(TeaModel):
    def __init__(
        self,
        general_alert: str = None,
        is_critical: str = None,
        name: str = None,
        serious_alert: str = None,
        symbols: str = None,
    ):
        # The low-risk alert.
        self.general_alert = general_alert
        # Indicates whether the condition is essential.
        self.is_critical = is_critical
        # The alert name.
        self.name = name
        # The Critical-level alert.
        self.serious_alert = serious_alert
        # Greater than or less than.
        self.symbols = symbols

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.general_alert is not None:
            result['GeneralAlert'] = self.general_alert
        if self.is_critical is not None:
            result['IsCritical'] = self.is_critical
        if self.name is not None:
            result['Name'] = self.name
        if self.serious_alert is not None:
            result['SeriousAlert'] = self.serious_alert
        if self.symbols is not None:
            result['Symbols'] = self.symbols
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GeneralAlert') is not None:
            self.general_alert = m.get('GeneralAlert')
        if m.get('IsCritical') is not None:
            self.is_critical = m.get('IsCritical')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SeriousAlert') is not None:
            self.serious_alert = m.get('SeriousAlert')
        if m.get('Symbols') is not None:
            self.symbols = m.get('Symbols')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam(TeaModel):
    def __init__(
        self,
        alarm_flag: int = None,
        alert_list: List[GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList] = None,
        alert_notifier_id: str = None,
        alert_policy_id: str = None,
        monitor_samples: str = None,
        start_execution_time: str = None,
    ):
        # The identifier of the alert.
        self.alarm_flag = alarm_flag
        # The list of alerts.
        self.alert_list = alert_list
        # The ID of the alert identifier.
        self.alert_notifier_id = alert_notifier_id
        # The ID of the alert policy.
        self.alert_policy_id = alert_policy_id
        # The monitoring samples.
        self.monitor_samples = monitor_samples
        # The start time of the execution.
        self.start_execution_time = start_execution_time

    def validate(self):
        if self.alert_list:
            for k in self.alert_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_flag is not None:
            result['AlarmFlag'] = self.alarm_flag
        result['AlertList'] = []
        if self.alert_list is not None:
            for k in self.alert_list:
                result['AlertList'].append(k.to_map() if k else None)
        if self.alert_notifier_id is not None:
            result['AlertNotifierId'] = self.alert_notifier_id
        if self.alert_policy_id is not None:
            result['AlertPolicyId'] = self.alert_policy_id
        if self.monitor_samples is not None:
            result['MonitorSamples'] = self.monitor_samples
        if self.start_execution_time is not None:
            result['StartExecutionTime'] = self.start_execution_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmFlag') is not None:
            self.alarm_flag = m.get('AlarmFlag')
        self.alert_list = []
        if m.get('AlertList') is not None:
            for k in m.get('AlertList'):
                temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList()
                self.alert_list.append(temp_model.from_map(k))
        if m.get('AlertNotifierId') is not None:
            self.alert_notifier_id = m.get('AlertNotifierId')
        if m.get('AlertPolicyId') is not None:
            self.alert_policy_id = m.get('AlertPolicyId')
        if m.get('MonitorSamples') is not None:
            self.monitor_samples = m.get('MonitorSamples')
        if m.get('StartExecutionTime') is not None:
            self.start_execution_time = m.get('StartExecutionTime')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailDownload(TeaModel):
    def __init__(
        self,
        connection_timeout: int = None,
        download_custom_header_content: str = None,
        download_custom_host: int = None,
        download_custom_host_ip: str = None,
        download_kernel: int = None,
        download_redirect: int = None,
        download_transmission_size: int = None,
        monitor_timeout: int = None,
        quick_protocol: str = None,
        validate_keywords: str = None,
        verify_way: int = None,
        white_list: str = None,
    ):
        # The timeout period of the file download task.
        self.connection_timeout = connection_timeout
        # The items to be ignored in a certificate error. Multiple values are concatenated with vertical bars (|).
        self.download_custom_header_content = download_custom_header_content
        # The custom host. Valid values:
        # 
        # *   1: round robin
        # *   0: random
        self.download_custom_host = download_custom_host
        # The custom IP address of the host. Multiple IP addresses are separated with commas (,).
        self.download_custom_host_ip = download_custom_host_ip
        # The kernel type. Valid values:
        # 
        # *   1: curl
        # *   0: WinInet
        self.download_kernel = download_kernel
        # Indicates whether redirection is supported.
        self.download_redirect = download_redirect
        # The file size. Unit: KB.
        self.download_transmission_size = download_transmission_size
        # The monitoring duration.
        self.monitor_timeout = monitor_timeout
        # The QUIC protocol type. Valid values:
        # 
        # *   1: HTTP/1
        # *   2: HTTP/2
        # *   3: http3
        self.quick_protocol = quick_protocol
        # The keyword that is used in verification.
        self.validate_keywords = validate_keywords
        # The method that is used to verify the response content. Valid values:
        # 
        # *   0: no verification.
        # *   1: exact match with the verification string.
        # *   2: partial match with the verification string.
        # *   3: MD5 verification.
        self.verify_way = verify_way
        # The whitelisted objects that are used to avoid DNS hijacking. Format: `<domain name>:<objects>`.
        # 
        # >  WAP networks do not support hijacking.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_timeout is not None:
            result['ConnectionTimeout'] = self.connection_timeout
        if self.download_custom_header_content is not None:
            result['DownloadCustomHeaderContent'] = self.download_custom_header_content
        if self.download_custom_host is not None:
            result['DownloadCustomHost'] = self.download_custom_host
        if self.download_custom_host_ip is not None:
            result['DownloadCustomHostIp'] = self.download_custom_host_ip
        if self.download_kernel is not None:
            result['DownloadKernel'] = self.download_kernel
        if self.download_redirect is not None:
            result['DownloadRedirect'] = self.download_redirect
        if self.download_transmission_size is not None:
            result['DownloadTransmissionSize'] = self.download_transmission_size
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.quick_protocol is not None:
            result['QuickProtocol'] = self.quick_protocol
        if self.validate_keywords is not None:
            result['ValidateKeywords'] = self.validate_keywords
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionTimeout') is not None:
            self.connection_timeout = m.get('ConnectionTimeout')
        if m.get('DownloadCustomHeaderContent') is not None:
            self.download_custom_header_content = m.get('DownloadCustomHeaderContent')
        if m.get('DownloadCustomHost') is not None:
            self.download_custom_host = m.get('DownloadCustomHost')
        if m.get('DownloadCustomHostIp') is not None:
            self.download_custom_host_ip = m.get('DownloadCustomHostIp')
        if m.get('DownloadKernel') is not None:
            self.download_kernel = m.get('DownloadKernel')
        if m.get('DownloadRedirect') is not None:
            self.download_redirect = m.get('DownloadRedirect')
        if m.get('DownloadTransmissionSize') is not None:
            self.download_transmission_size = m.get('DownloadTransmissionSize')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('QuickProtocol') is not None:
            self.quick_protocol = m.get('QuickProtocol')
        if m.get('ValidateKeywords') is not None:
            self.validate_keywords = m.get('ValidateKeywords')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval(TeaModel):
    def __init__(
        self,
        days: List[int] = None,
        end_minute: int = None,
        end_time: str = None,
        endhour: int = None,
        start_hour: int = None,
        start_minute: int = None,
        start_time: str = None,
    ):
        # The day on which synthetic monitoring is performed. Valid values:
        # 
        # *   \\-1: every day
        # *   0: Sunday
        # *   1: Monday
        # *   2: Tuesday
        # *   3: Wednesday
        # *   4: Thursday
        # *   5: Friday
        # *   6: Saturday
        self.days = days
        # The minute at which synthetic monitoring ends.
        self.end_minute = end_minute
        # The time when synthetic monitoring ends. Format: `yyyy-MM-dd HH`.
        self.end_time = end_time
        # The hour at which synthetic monitoring ends.
        self.endhour = endhour
        # The hour at which synthetic monitoring starts.
        self.start_hour = start_hour
        # The minute at which synthetic monitoring starts.
        self.start_minute = start_minute
        # The time when synthetic monitoring starts. Format: yyyy-MM-dd HH.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['Days'] = self.days
        if self.end_minute is not None:
            result['EndMinute'] = self.end_minute
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.endhour is not None:
            result['Endhour'] = self.endhour
        if self.start_hour is not None:
            result['StartHour'] = self.start_hour
        if self.start_minute is not None:
            result['StartMinute'] = self.start_minute
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Days') is not None:
            self.days = m.get('Days')
        if m.get('EndMinute') is not None:
            self.end_minute = m.get('EndMinute')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Endhour') is not None:
            self.endhour = m.get('Endhour')
        if m.get('StartHour') is not None:
            self.start_hour = m.get('StartHour')
        if m.get('StartMinute') is not None:
            self.start_minute = m.get('StartMinute')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList(TeaModel):
    def __init__(
        self,
        city_code: int = None,
        monitor_type: int = None,
        net_service_id: int = None,
        send_count: int = None,
    ):
        # The city code.
        self.city_code = city_code
        # The type of the detection point.
        self.monitor_type = monitor_type
        # The ID of the network service.
        self.net_service_id = net_service_id
        # The number of times that the system sends detection requests.
        self.send_count = send_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.monitor_type is not None:
            result['MonitorType'] = self.monitor_type
        if self.net_service_id is not None:
            result['NetServiceId'] = self.net_service_id
        if self.send_count is not None:
            result['SendCount'] = self.send_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('MonitorType') is not None:
            self.monitor_type = m.get('MonitorType')
        if m.get('NetServiceId') is not None:
            self.net_service_id = m.get('NetServiceId')
        if m.get('SendCount') is not None:
            self.send_count = m.get('SendCount')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailNav(TeaModel):
    def __init__(
        self,
        dns_hijack_whitelist: str = None,
        element_blacklist: str = None,
        execute_active_x: int = None,
        execute_applet: int = None,
        execute_script: int = None,
        filter_invalid_ip: int = None,
        flow_hijack_jump_times: int = None,
        flow_hijack_logo: str = None,
        monitor_timeout: int = None,
        nav_automatic_scrolling: int = None,
        nav_custom_header: str = None,
        nav_custom_header_content: str = None,
        nav_custom_host: int = None,
        nav_custom_host_ip: str = None,
        nav_disable_cache: int = None,
        nav_disable_compression: int = None,
        nav_ignore_certificate_error: int = None,
        nav_redirect: int = None,
        nav_return_element: int = None,
        page_tampering: str = None,
        process_name: str = None,
        quic_domain: str = None,
        quic_version: int = None,
        request_header: int = None,
        slow_element_threshold: int = None,
        verify_string_blacklist: str = None,
        verify_string_whitelist: str = None,
        wait_completion_time: int = None,
    ):
        # The DNS whitelist.
        self.dns_hijack_whitelist = dns_hijack_whitelist
        # The element blacklist.
        self.element_blacklist = element_blacklist
        # Indicates whether ActiveX is executed. Valid values:
        # 
        # *   3: yes
        # *   0: no
        # 
        # >  Only IE elements support this parameter.
        self.execute_active_x = execute_active_x
        # Indicates whether the applet is executed. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.execute_applet = execute_applet
        # Indicates whether scripts are executed. Valid values:
        # 
        # *   1: yes
        # *   0: no
        # 
        # >  Only IE elements support this parameter.
        self.execute_script = execute_script
        # Indicates whether invalid IP addresses are excluded. Valid values:
        # 
        # *   1: no
        # *   0: yes
        self.filter_invalid_ip = filter_invalid_ip
        # The element that is used in DNS hijacking.
        self.flow_hijack_jump_times = flow_hijack_jump_times
        # The tag that is used in DNS hijacking.
        self.flow_hijack_logo = flow_hijack_logo
        # The monitoring timeout period.
        self.monitor_timeout = monitor_timeout
        # Indicates whether the screen is automatically scrolled up and down to load a page. Valid values:
        # 
        # *   1: yes
        # *   0: no
        self.nav_automatic_scrolling = nav_automatic_scrolling
        # Indicates whether a custom header is created. Valid values:
        # 
        # *   0: no
        # *   1: A custom header is created for the first packet.
        # *   2: A custom header is created for all packets.
        self.nav_custom_header = nav_custom_header
        # The format of the custom header. Multiple fields are separated with vertical bars (|).
        self.nav_custom_header_content = nav_custom_header_content
        # The custom host mode. Valid values:
        # 
        # *   1: round robin
        # *   0: random
        self.nav_custom_host = nav_custom_host
        # The custom IP address of the host. Multiple IP addresses are separated with commas (,).
        self.nav_custom_host_ip = nav_custom_host_ip
        # Indicates whether caching is disabled. Valid values:
        # 
        # *   1: Caching is disabled.
        # *   0: Caching is enabled.
        self.nav_disable_cache = nav_disable_cache
        # Indicates whether compression is disabled. Valid values:
        # 
        # *   0: Compression is enabled.
        # *   1: Compression is disabled.
        self.nav_disable_compression = nav_disable_compression
        # Indicates whether certificate errors are ignored during certificate verification in the SSL handshake. Valid values:
        # 
        # *   1: yes
        # *   0: no
        self.nav_ignore_certificate_error = nav_ignore_certificate_error
        # Indicates whether redirection is enabled. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.nav_redirect = nav_redirect
        # Indicates whether the elements on the page are returned.
        # 
        # *   1: no. The basic document data is returned.
        # *   2: yes. All document data is returned.
        self.nav_return_element = nav_return_element
        # The page tampering.
        self.page_tampering = page_tampering
        # The process ID.
        self.process_name = process_name
        # The domain name of the QUIC request element.
        self.quic_domain = quic_domain
        # The QUIC version. Default value: 0. Valid values:
        # 
        # *   35
        # *   39
        # *   43
        # *   44
        # 
        # >  Only Chrome elements support this parameter.
        self.quic_version = quic_version
        # Indicates whether request headers are returned. Valid values:
        # 
        # *   0: no
        # *   1: The headers of base documents are returned.
        # *   2: All headers are returned.
        self.request_header = request_header
        # The time threshold that is used to define a slow element. Unit: seconds.
        self.slow_element_threshold = slow_element_threshold
        # The blacklist for string verification.
        self.verify_string_blacklist = verify_string_blacklist
        # The whitelist for string verification.
        self.verify_string_whitelist = verify_string_whitelist
        # The timeout period of waiting for the monitoring to complete.
        self.wait_completion_time = wait_completion_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_hijack_whitelist is not None:
            result['DnsHijackWhitelist'] = self.dns_hijack_whitelist
        if self.element_blacklist is not None:
            result['ElementBlacklist'] = self.element_blacklist
        if self.execute_active_x is not None:
            result['ExecuteActiveX'] = self.execute_active_x
        if self.execute_applet is not None:
            result['ExecuteApplet'] = self.execute_applet
        if self.execute_script is not None:
            result['ExecuteScript'] = self.execute_script
        if self.filter_invalid_ip is not None:
            result['FilterInvalidIP'] = self.filter_invalid_ip
        if self.flow_hijack_jump_times is not None:
            result['FlowHijackJumpTimes'] = self.flow_hijack_jump_times
        if self.flow_hijack_logo is not None:
            result['FlowHijackLogo'] = self.flow_hijack_logo
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.nav_automatic_scrolling is not None:
            result['NavAutomaticScrolling'] = self.nav_automatic_scrolling
        if self.nav_custom_header is not None:
            result['NavCustomHeader'] = self.nav_custom_header
        if self.nav_custom_header_content is not None:
            result['NavCustomHeaderContent'] = self.nav_custom_header_content
        if self.nav_custom_host is not None:
            result['NavCustomHost'] = self.nav_custom_host
        if self.nav_custom_host_ip is not None:
            result['NavCustomHostIp'] = self.nav_custom_host_ip
        if self.nav_disable_cache is not None:
            result['NavDisableCache'] = self.nav_disable_cache
        if self.nav_disable_compression is not None:
            result['NavDisableCompression'] = self.nav_disable_compression
        if self.nav_ignore_certificate_error is not None:
            result['NavIgnoreCertificateError'] = self.nav_ignore_certificate_error
        if self.nav_redirect is not None:
            result['NavRedirect'] = self.nav_redirect
        if self.nav_return_element is not None:
            result['NavReturnElement'] = self.nav_return_element
        if self.page_tampering is not None:
            result['PageTampering'] = self.page_tampering
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.quic_domain is not None:
            result['QuicDomain'] = self.quic_domain
        if self.quic_version is not None:
            result['QuicVersion'] = self.quic_version
        if self.request_header is not None:
            result['RequestHeader'] = self.request_header
        if self.slow_element_threshold is not None:
            result['SlowElementThreshold'] = self.slow_element_threshold
        if self.verify_string_blacklist is not None:
            result['VerifyStringBlacklist'] = self.verify_string_blacklist
        if self.verify_string_whitelist is not None:
            result['VerifyStringWhitelist'] = self.verify_string_whitelist
        if self.wait_completion_time is not None:
            result['WaitCompletionTime'] = self.wait_completion_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsHijackWhitelist') is not None:
            self.dns_hijack_whitelist = m.get('DnsHijackWhitelist')
        if m.get('ElementBlacklist') is not None:
            self.element_blacklist = m.get('ElementBlacklist')
        if m.get('ExecuteActiveX') is not None:
            self.execute_active_x = m.get('ExecuteActiveX')
        if m.get('ExecuteApplet') is not None:
            self.execute_applet = m.get('ExecuteApplet')
        if m.get('ExecuteScript') is not None:
            self.execute_script = m.get('ExecuteScript')
        if m.get('FilterInvalidIP') is not None:
            self.filter_invalid_ip = m.get('FilterInvalidIP')
        if m.get('FlowHijackJumpTimes') is not None:
            self.flow_hijack_jump_times = m.get('FlowHijackJumpTimes')
        if m.get('FlowHijackLogo') is not None:
            self.flow_hijack_logo = m.get('FlowHijackLogo')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('NavAutomaticScrolling') is not None:
            self.nav_automatic_scrolling = m.get('NavAutomaticScrolling')
        if m.get('NavCustomHeader') is not None:
            self.nav_custom_header = m.get('NavCustomHeader')
        if m.get('NavCustomHeaderContent') is not None:
            self.nav_custom_header_content = m.get('NavCustomHeaderContent')
        if m.get('NavCustomHost') is not None:
            self.nav_custom_host = m.get('NavCustomHost')
        if m.get('NavCustomHostIp') is not None:
            self.nav_custom_host_ip = m.get('NavCustomHostIp')
        if m.get('NavDisableCache') is not None:
            self.nav_disable_cache = m.get('NavDisableCache')
        if m.get('NavDisableCompression') is not None:
            self.nav_disable_compression = m.get('NavDisableCompression')
        if m.get('NavIgnoreCertificateError') is not None:
            self.nav_ignore_certificate_error = m.get('NavIgnoreCertificateError')
        if m.get('NavRedirect') is not None:
            self.nav_redirect = m.get('NavRedirect')
        if m.get('NavReturnElement') is not None:
            self.nav_return_element = m.get('NavReturnElement')
        if m.get('PageTampering') is not None:
            self.page_tampering = m.get('PageTampering')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('QuicDomain') is not None:
            self.quic_domain = m.get('QuicDomain')
        if m.get('QuicVersion') is not None:
            self.quic_version = m.get('QuicVersion')
        if m.get('RequestHeader') is not None:
            self.request_header = m.get('RequestHeader')
        if m.get('SlowElementThreshold') is not None:
            self.slow_element_threshold = m.get('SlowElementThreshold')
        if m.get('VerifyStringBlacklist') is not None:
            self.verify_string_blacklist = m.get('VerifyStringBlacklist')
        if m.get('VerifyStringWhitelist') is not None:
            self.verify_string_whitelist = m.get('VerifyStringWhitelist')
        if m.get('WaitCompletionTime') is not None:
            self.wait_completion_time = m.get('WaitCompletionTime')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailNet(TeaModel):
    def __init__(
        self,
        net_dig_switch: int = None,
        net_dns_ns: str = None,
        net_dns_query_method: str = None,
        net_dns_server: int = None,
        net_dns_switch: int = None,
        net_dns_timeout: str = None,
        net_icmp_active: int = None,
        net_icmp_data_cut: int = None,
        net_icmp_interval: int = None,
        net_icmp_num: int = None,
        net_icmp_size: int = None,
        net_icmp_switch: int = None,
        net_icmp_timeout: int = None,
        net_trace_route_num: int = None,
        net_trace_route_switch: int = None,
        net_trace_route_timeout: int = None,
        white_list: str = None,
    ):
        # Indicates whether the data is displayed in the DIG format. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.net_dig_switch = net_dig_switch
        # The NS server.
        self.net_dns_ns = net_dns_ns
        # The DNS query method. Valid values:
        # 
        # *   1: recursive
        # *   2: iterative
        self.net_dns_query_method = net_dns_query_method
        # The type of the DNS server. Valid values:
        # 
        # *   0: ipv4
        # *   1: ipv6
        # *   2: A version is automatically selected.
        self.net_dns_server = net_dns_server
        # Indicates whether DNS test is enabled. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.net_dns_switch = net_dns_switch
        # The timeout period of DNS requests.
        self.net_dns_timeout = net_dns_timeout
        # The protocol type. Valid values:
        # 
        # *   0 : ICMP
        # *   1 : TCP
        self.net_icmp_active = net_icmp_active
        # Indicates whether packets are split. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.net_icmp_data_cut = net_icmp_data_cut
        # The interval at which the synthetic monitoring task is executed.
        self.net_icmp_interval = net_icmp_interval
        # The number of packets.
        self.net_icmp_num = net_icmp_num
        # The packet size.
        self.net_icmp_size = net_icmp_size
        # Indicates whether ICMP test is enabled. Valid values:
        # 
        # *   0: no.
        # *   1: yes. If you set this parameter to 1, you must also set the Icmp parameter.
        self.net_icmp_switch = net_icmp_switch
        # The monitoring timeout period.
        self.net_icmp_timeout = net_icmp_timeout
        # The maximum number of active detection points.
        self.net_trace_route_num = net_trace_route_num
        # Indicates whether Tracert test is enabled. Valid values:
        # 
        # *   0: no
        # *   1: yes. If you set this parameter to 1, you must also set the Tracert parameter.
        self.net_trace_route_switch = net_trace_route_switch
        # The monitoring timeout period. Valid values: 0 to 300. Unit: seconds.
        self.net_trace_route_timeout = net_trace_route_timeout
        # The whitelisted objects that are used to avoid DNS hijacking. Format: `<domain name>:<objects>`.
        # 
        # >  WAP networks do not support hijacking.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.net_dig_switch is not None:
            result['NetDigSwitch'] = self.net_dig_switch
        if self.net_dns_ns is not None:
            result['NetDnsNs'] = self.net_dns_ns
        if self.net_dns_query_method is not None:
            result['NetDnsQueryMethod'] = self.net_dns_query_method
        if self.net_dns_server is not None:
            result['NetDnsServer'] = self.net_dns_server
        if self.net_dns_switch is not None:
            result['NetDnsSwitch'] = self.net_dns_switch
        if self.net_dns_timeout is not None:
            result['NetDnsTimeout'] = self.net_dns_timeout
        if self.net_icmp_active is not None:
            result['NetIcmpActive'] = self.net_icmp_active
        if self.net_icmp_data_cut is not None:
            result['NetIcmpDataCut'] = self.net_icmp_data_cut
        if self.net_icmp_interval is not None:
            result['NetIcmpInterval'] = self.net_icmp_interval
        if self.net_icmp_num is not None:
            result['NetIcmpNum'] = self.net_icmp_num
        if self.net_icmp_size is not None:
            result['NetIcmpSize'] = self.net_icmp_size
        if self.net_icmp_switch is not None:
            result['NetIcmpSwitch'] = self.net_icmp_switch
        if self.net_icmp_timeout is not None:
            result['NetIcmpTimeout'] = self.net_icmp_timeout
        if self.net_trace_route_num is not None:
            result['NetTraceRouteNum'] = self.net_trace_route_num
        if self.net_trace_route_switch is not None:
            result['NetTraceRouteSwitch'] = self.net_trace_route_switch
        if self.net_trace_route_timeout is not None:
            result['NetTraceRouteTimeout'] = self.net_trace_route_timeout
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NetDigSwitch') is not None:
            self.net_dig_switch = m.get('NetDigSwitch')
        if m.get('NetDnsNs') is not None:
            self.net_dns_ns = m.get('NetDnsNs')
        if m.get('NetDnsQueryMethod') is not None:
            self.net_dns_query_method = m.get('NetDnsQueryMethod')
        if m.get('NetDnsServer') is not None:
            self.net_dns_server = m.get('NetDnsServer')
        if m.get('NetDnsSwitch') is not None:
            self.net_dns_switch = m.get('NetDnsSwitch')
        if m.get('NetDnsTimeout') is not None:
            self.net_dns_timeout = m.get('NetDnsTimeout')
        if m.get('NetIcmpActive') is not None:
            self.net_icmp_active = m.get('NetIcmpActive')
        if m.get('NetIcmpDataCut') is not None:
            self.net_icmp_data_cut = m.get('NetIcmpDataCut')
        if m.get('NetIcmpInterval') is not None:
            self.net_icmp_interval = m.get('NetIcmpInterval')
        if m.get('NetIcmpNum') is not None:
            self.net_icmp_num = m.get('NetIcmpNum')
        if m.get('NetIcmpSize') is not None:
            self.net_icmp_size = m.get('NetIcmpSize')
        if m.get('NetIcmpSwitch') is not None:
            self.net_icmp_switch = m.get('NetIcmpSwitch')
        if m.get('NetIcmpTimeout') is not None:
            self.net_icmp_timeout = m.get('NetIcmpTimeout')
        if m.get('NetTraceRouteNum') is not None:
            self.net_trace_route_num = m.get('NetTraceRouteNum')
        if m.get('NetTraceRouteSwitch') is not None:
            self.net_trace_route_switch = m.get('NetTraceRouteSwitch')
        if m.get('NetTraceRouteTimeout') is not None:
            self.net_trace_route_timeout = m.get('NetTraceRouteTimeout')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the **form-data**.
        self.key = key
        # The value of the form-data.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody(TeaModel):
    def __init__(
        self,
        formdata: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata = None,
        language: str = None,
        mode: str = None,
        raw: str = None,
        urlencoded: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded = None,
    ):
        # The data content. This parameter is returned when Mode is set to form-data.
        self.formdata = formdata
        # The language used when Mode is set to raw. Valid values:
        # 
        # *   json
        # *   xml
        # *   javascript
        # *   html
        # *   text
        self.language = language
        # The type of the content. Valid values:
        # 
        # *   form-data
        # *   x-www-form-urlencoded
        # *   raw
        self.mode = mode
        # The data content. This parameter is returned when **Mode** is set to **raw**.
        self.raw = raw
        # The URL of the body content.
        self.urlencoded = urlencoded

    def validate(self):
        if self.formdata:
            self.formdata.validate()
        if self.urlencoded:
            self.urlencoded.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.formdata is not None:
            result['Formdata'] = self.formdata.to_map()
        if self.language is not None:
            result['Language'] = self.language
        if self.mode is not None:
            result['Mode'] = self.mode
        if self.raw is not None:
            result['Raw'] = self.raw
        if self.urlencoded is not None:
            result['Urlencoded'] = self.urlencoded.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Formdata') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata()
            self.formdata = temp_model.from_map(m['Formdata'])
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        if m.get('Raw') is not None:
            self.raw = m.get('Raw')
        if m.get('Urlencoded') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded()
            self.urlencoded = temp_model.from_map(m['Urlencoded'])
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the header in the request parameters.
        self.key = key
        # The value of the header in the request parameters.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent(TeaModel):
    def __init__(
        self,
        body: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody = None,
        header: List[GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader] = None,
        method: str = None,
    ):
        # The content of the request body.
        self.body = body
        # The request header.
        self.header = header
        # The request method. Valid values:
        # 
        # *   POST
        # *   GET
        self.method = method

    def validate(self):
        if self.body:
            self.body.validate()
        if self.header:
            for k in self.header:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body.to_map()
        result['Header'] = []
        if self.header is not None:
            for k in self.header:
                result['Header'].append(k.to_map() if k else None)
        if self.method is not None:
            result['Method'] = self.method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody()
            self.body = temp_model.from_map(m['Body'])
        self.header = []
        if m.get('Header') is not None:
            for k in m.get('Header'):
                temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader()
                self.header.append(temp_model.from_map(k))
        if m.get('Method') is not None:
            self.method = m.get('Method')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetailProtocol(TeaModel):
    def __init__(
        self,
        character_encoding: int = None,
        custom_host: int = None,
        custom_host_ip: str = None,
        protocol_connection_timeout: int = None,
        protocol_monitor_timeout: int = None,
        received_data_size: int = None,
        request_content: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent = None,
        verify_content: str = None,
        verify_way: int = None,
    ):
        # The encoding format. Valid values:
        # 
        # *   0: UTF-8
        # *   1: GBK
        # *   2: GB2312
        # *   3: Unicode
        self.character_encoding = character_encoding
        # The custom host. Valid values:
        # 
        # *   1: round robin
        # *   0: random
        self.custom_host = custom_host
        # The custom IP address of the host. Multiple IP addresses are separated with commas (,).
        self.custom_host_ip = custom_host_ip
        # The timeout period.
        self.protocol_connection_timeout = protocol_connection_timeout
        # The timeout period of API performance monitoring. Unit: seconds.
        self.protocol_monitor_timeout = protocol_monitor_timeout
        # The size of the received data. This parameter is returned when **VerifyWay** is set to 2.
        self.received_data_size = received_data_size
        # The request content, including the header and body.
        self.request_content = request_content
        # The verification string.
        self.verify_content = verify_content
        # The method that is used to verify the response content. Valid values:
        # 
        # *   0: no verification.
        # *   1: exact match with the verification string.
        # *   2: partial match with the verification string.
        # *   3: MD5 verification.
        self.verify_way = verify_way

    def validate(self):
        if self.request_content:
            self.request_content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.character_encoding is not None:
            result['CharacterEncoding'] = self.character_encoding
        if self.custom_host is not None:
            result['CustomHost'] = self.custom_host
        if self.custom_host_ip is not None:
            result['CustomHostIp'] = self.custom_host_ip
        if self.protocol_connection_timeout is not None:
            result['ProtocolConnectionTimeout'] = self.protocol_connection_timeout
        if self.protocol_monitor_timeout is not None:
            result['ProtocolMonitorTimeout'] = self.protocol_monitor_timeout
        if self.received_data_size is not None:
            result['ReceivedDataSize'] = self.received_data_size
        if self.request_content is not None:
            result['RequestContent'] = self.request_content.to_map()
        if self.verify_content is not None:
            result['VerifyContent'] = self.verify_content
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CharacterEncoding') is not None:
            self.character_encoding = m.get('CharacterEncoding')
        if m.get('CustomHost') is not None:
            self.custom_host = m.get('CustomHost')
        if m.get('CustomHostIp') is not None:
            self.custom_host_ip = m.get('CustomHostIp')
        if m.get('ProtocolConnectionTimeout') is not None:
            self.protocol_connection_timeout = m.get('ProtocolConnectionTimeout')
        if m.get('ProtocolMonitorTimeout') is not None:
            self.protocol_monitor_timeout = m.get('ProtocolMonitorTimeout')
        if m.get('ReceivedDataSize') is not None:
            self.received_data_size = m.get('ReceivedDataSize')
        if m.get('RequestContent') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent()
            self.request_content = temp_model.from_map(m['RequestContent'])
        if m.get('VerifyContent') is not None:
            self.verify_content = m.get('VerifyContent')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        return self


class GetSyntheticTaskDetailResponseBodyTaskDetail(TeaModel):
    def __init__(
        self,
        common_param: GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam = None,
        download: GetSyntheticTaskDetailResponseBodyTaskDetailDownload = None,
        extend_interval: GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval = None,
        interval_time: int = None,
        interval_type: int = None,
        ip_type: int = None,
        monitor_list: List[GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList] = None,
        monitor_list_string: str = None,
        nav: GetSyntheticTaskDetailResponseBodyTaskDetailNav = None,
        net: GetSyntheticTaskDetailResponseBodyTaskDetailNet = None,
        protocol: GetSyntheticTaskDetailResponseBodyTaskDetailProtocol = None,
        task_id: int = None,
        task_name: str = None,
        task_type: int = None,
        url: str = None,
    ):
        # The list of common parameters.
        self.common_param = common_param
        # The file download task.
        self.download = download
        # The frequency.
        self.extend_interval = extend_interval
        # The interval at which synthetic monitoring is performed. Unit: minutes. Valid values:
        # 
        # *   1
        # *   5
        # *   10
        # *   15
        # *   20
        # *   30
        # *   60
        # *   120
        # *   180
        # *   240
        # *   360
        # *   480
        # *   720
        # *   1440
        self.interval_time = interval_time
        # The interval type. Valid values:
        # 
        # *   0: daily
        # *   1: custom frequency
        self.interval_type = interval_type
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4.
        # *   2: IPv6.
        self.ip_type = ip_type
        # The detection points.
        self.monitor_list = monitor_list
        # The detection points.
        self.monitor_list_string = monitor_list_string
        # The browser test task.
        self.nav = nav
        # The network synthetic monitoring task.
        self.net = net
        # The synthetic monitoring task of the API performance type.
        self.protocol = protocol
        # The ID of the synthetic monitoring task.
        self.task_id = task_id
        # The name of the task.
        self.task_name = task_name
        # The type of the task. Valid values:
        # 
        # 1.  3: web page performance - IE
        # 2.  34: web page performance - Chrome
        # 3.  0: network quality
        # 4.  40: file download
        # 5.  7: API performance
        self.task_type = task_type
        # The URL for synthetic monitoring.
        self.url = url

    def validate(self):
        if self.common_param:
            self.common_param.validate()
        if self.download:
            self.download.validate()
        if self.extend_interval:
            self.extend_interval.validate()
        if self.monitor_list:
            for k in self.monitor_list:
                if k:
                    k.validate()
        if self.nav:
            self.nav.validate()
        if self.net:
            self.net.validate()
        if self.protocol:
            self.protocol.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_param is not None:
            result['CommonParam'] = self.common_param.to_map()
        if self.download is not None:
            result['Download'] = self.download.to_map()
        if self.extend_interval is not None:
            result['ExtendInterval'] = self.extend_interval.to_map()
        if self.interval_time is not None:
            result['IntervalTime'] = self.interval_time
        if self.interval_type is not None:
            result['IntervalType'] = self.interval_type
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        result['MonitorList'] = []
        if self.monitor_list is not None:
            for k in self.monitor_list:
                result['MonitorList'].append(k.to_map() if k else None)
        if self.monitor_list_string is not None:
            result['MonitorListString'] = self.monitor_list_string
        if self.nav is not None:
            result['Nav'] = self.nav.to_map()
        if self.net is not None:
            result['Net'] = self.net.to_map()
        if self.protocol is not None:
            result['Protocol'] = self.protocol.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommonParam') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam()
            self.common_param = temp_model.from_map(m['CommonParam'])
        if m.get('Download') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailDownload()
            self.download = temp_model.from_map(m['Download'])
        if m.get('ExtendInterval') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval()
            self.extend_interval = temp_model.from_map(m['ExtendInterval'])
        if m.get('IntervalTime') is not None:
            self.interval_time = m.get('IntervalTime')
        if m.get('IntervalType') is not None:
            self.interval_type = m.get('IntervalType')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        self.monitor_list = []
        if m.get('MonitorList') is not None:
            for k in m.get('MonitorList'):
                temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList()
                self.monitor_list.append(temp_model.from_map(k))
        if m.get('MonitorListString') is not None:
            self.monitor_list_string = m.get('MonitorListString')
        if m.get('Nav') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailNav()
            self.nav = temp_model.from_map(m['Nav'])
        if m.get('Net') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailNet()
            self.net = temp_model.from_map(m['Net'])
        if m.get('Protocol') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetailProtocol()
            self.protocol = temp_model.from_map(m['Protocol'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetSyntheticTaskDetailResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_detail: GetSyntheticTaskDetailResponseBodyTaskDetail = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the task.
        self.task_detail = task_detail

    def validate(self):
        if self.task_detail:
            self.task_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_detail is not None:
            result['TaskDetail'] = self.task_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskDetail') is not None:
            temp_model = GetSyntheticTaskDetailResponseBodyTaskDetail()
            self.task_detail = temp_model.from_map(m['TaskDetail'])
        return self


class GetSyntheticTaskDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSyntheticTaskDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSyntheticTaskDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSyntheticTaskListRequest(TeaModel):
    def __init__(
        self,
        direction: str = None,
        order: str = None,
        page_num: int = None,
        page_size: int = None,
        region_id: str = None,
        task_name: str = None,
        task_status: str = None,
        task_type: str = None,
        url: str = None,
    ):
        # The order by which the queried tasks are sorted. Valid values:
        # 
        # *   **asc**: ascending
        # *   **desc**: descending
        self.direction = direction
        # The condition by which the queried tasks are sorted.
        self.order = order
        # The page number.
        self.page_num = page_num
        # The number of entries per page.
        self.page_size = page_size
        # The region ID. Default value: **cn-hangzhou**.
        self.region_id = region_id
        # The task name.
        self.task_name = task_name
        # The status of the task. Valid values:
        # 
        # *   **0**: The task is stopped.
        # *   **1**: The task is started.
        # *   **9**: The task is ended.
        self.task_status = task_status
        # The type of the task. Valid values:
        # 
        # 1.  3: web page performance - IE
        # 2.  34: web page performance - Chrome
        # 3.  0: network quality
        # 4.  40: file download
        # 5.  7: API performance
        self.task_type = task_type
        # The URL for synthetic monitoring.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.order is not None:
            result['Order'] = self.order
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetSyntheticTaskListResponseBodyPageInfoList(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        monitor_number: int = None,
        task_id: str = None,
        task_name: str = None,
        task_status: str = None,
        task_type: int = None,
        task_type_name: str = None,
        url: str = None,
        usable: float = None,
    ):
        # The time when the task was created.
        self.create_time = create_time
        # The number of detection points.
        self.monitor_number = monitor_number
        # The ID of the synthetic monitoring task.
        self.task_id = task_id
        # The task name.
        self.task_name = task_name
        # The status of the task. Valid values:
        # 
        # *   **0**: The task is stopped.
        # *   **1**: The task is started.
        # *   **9**: The task is ended.
        self.task_status = task_status
        # The type of the task. Valid values:
        # 
        # 1.  3: web page performance - IE
        # 2.  34: web page performance - Chrome
        # 3.  0: network quality
        # 4.  40: file download
        # 5.  7: API performance
        self.task_type = task_type
        # The name of the task type.
        self.task_type_name = task_type_name
        # The URL for synthetic monitoring.
        self.url = url
        # The availability. Only the data of the last day is counted. If no data is available for the last day, an empty value is returned.
        self.usable = usable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.monitor_number is not None:
            result['MonitorNumber'] = self.monitor_number
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.task_type_name is not None:
            result['TaskTypeName'] = self.task_type_name
        if self.url is not None:
            result['Url'] = self.url
        if self.usable is not None:
            result['Usable'] = self.usable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('MonitorNumber') is not None:
            self.monitor_number = m.get('MonitorNumber')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TaskTypeName') is not None:
            self.task_type_name = m.get('TaskTypeName')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Usable') is not None:
            self.usable = m.get('Usable')
        return self


class GetSyntheticTaskListResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        has_next_page: str = None,
        has_previous_page: bool = None,
        is_first_page: bool = None,
        is_last_page: bool = None,
        list: List[GetSyntheticTaskListResponseBodyPageInfoList] = None,
        navigate_first_page: str = None,
        navigate_last_page: str = None,
        navigate_page_nums: str = None,
        next_page: str = None,
        pages: str = None,
        prepage: str = None,
        size: int = None,
        total: int = None,
    ):
        # Indicates whether the current page is followed by a page.
        self.has_next_page = has_next_page
        # Indicates whether a previous page exists.
        self.has_previous_page = has_previous_page
        # Indicates whether the page is the first page.
        self.is_first_page = is_first_page
        # Indicates whether the page is the last page.
        self.is_last_page = is_last_page
        # The task information.
        self.list = list
        # The first page on the navigation bar.
        self.navigate_first_page = navigate_first_page
        # The last page on the navigation bar.
        self.navigate_last_page = navigate_last_page
        # All navigation page numbers.
        self.navigate_page_nums = navigate_page_nums
        # The next page.
        self.next_page = next_page
        # The total number of pages returned.
        self.pages = pages
        # The previous page.
        self.prepage = prepage
        # The number of entries per page.
        self.size = size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_next_page is not None:
            result['HasNextPage'] = self.has_next_page
        if self.has_previous_page is not None:
            result['HasPreviousPage'] = self.has_previous_page
        if self.is_first_page is not None:
            result['IsFirstPage'] = self.is_first_page
        if self.is_last_page is not None:
            result['IsLastPage'] = self.is_last_page
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.navigate_first_page is not None:
            result['NavigateFirstPage'] = self.navigate_first_page
        if self.navigate_last_page is not None:
            result['NavigateLastPage'] = self.navigate_last_page
        if self.navigate_page_nums is not None:
            result['NavigatePageNums'] = self.navigate_page_nums
        if self.next_page is not None:
            result['NextPage'] = self.next_page
        if self.pages is not None:
            result['Pages'] = self.pages
        if self.prepage is not None:
            result['Prepage'] = self.prepage
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('HasNextPage') is not None:
            self.has_next_page = m.get('HasNextPage')
        if m.get('HasPreviousPage') is not None:
            self.has_previous_page = m.get('HasPreviousPage')
        if m.get('IsFirstPage') is not None:
            self.is_first_page = m.get('IsFirstPage')
        if m.get('IsLastPage') is not None:
            self.is_last_page = m.get('IsLastPage')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = GetSyntheticTaskListResponseBodyPageInfoList()
                self.list.append(temp_model.from_map(k))
        if m.get('NavigateFirstPage') is not None:
            self.navigate_first_page = m.get('NavigateFirstPage')
        if m.get('NavigateLastPage') is not None:
            self.navigate_last_page = m.get('NavigateLastPage')
        if m.get('NavigatePageNums') is not None:
            self.navigate_page_nums = m.get('NavigatePageNums')
        if m.get('NextPage') is not None:
            self.next_page = m.get('NextPage')
        if m.get('Pages') is not None:
            self.pages = m.get('Pages')
        if m.get('Prepage') is not None:
            self.prepage = m.get('Prepage')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetSyntheticTaskListResponseBody(TeaModel):
    def __init__(
        self,
        page_info: GetSyntheticTaskListResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The query results.
        self.page_info = page_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = GetSyntheticTaskListResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetSyntheticTaskListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSyntheticTaskListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSyntheticTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSyntheticTaskMonitorsRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The ID of the region in which the application is located.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetSyntheticTaskMonitorsResponseBodyData(TeaModel):
    def __init__(
        self,
        busy: int = None,
        city: str = None,
        city_code: int = None,
        client_type: int = None,
        district: str = None,
        net_service_id: int = None,
        net_service_name: str = None,
    ):
        # The task status.
        # 
        # *   0: active
        # *   1: busy
        self.busy = busy
        # The name of the city to which the monitoring point belongs.
        self.city = city
        # The ID of the city to which the monitoring point belongs.
        self.city_code = city_code
        # The client type:
        # 
        # *   1: IDC
        # *   2: Last mile
        self.client_type = client_type
        # The region to which the monitoring point belongs.
        self.district = district
        # The ID of the carrier.
        self.net_service_id = net_service_id
        # The name of the carrier.
        self.net_service_name = net_service_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.busy is not None:
            result['Busy'] = self.busy
        if self.city is not None:
            result['City'] = self.city
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.district is not None:
            result['District'] = self.district
        if self.net_service_id is not None:
            result['NetServiceId'] = self.net_service_id
        if self.net_service_name is not None:
            result['NetServiceName'] = self.net_service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Busy') is not None:
            self.busy = m.get('Busy')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('District') is not None:
            self.district = m.get('District')
        if m.get('NetServiceId') is not None:
            self.net_service_id = m.get('NetServiceId')
        if m.get('NetServiceName') is not None:
            self.net_service_name = m.get('NetServiceName')
        return self


class GetSyntheticTaskMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GetSyntheticTaskMonitorsResponseBodyData] = None,
        msg: str = None,
        request_id: str = None,
    ):
        # The status code returned.
        # 
        # *   1001: The request was successful.
        # *   1002: The request failed.
        # *   1003: Parameter errors occurred.
        # *   1004: Authentication failed.
        # *   1006: The task does not exist.
        # *   1099: Internal errors occurred.
        self.code = code
        # The details of the monitoring point.
        self.data = data
        # The message that is returned when the request failed.
        self.msg = msg
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GetSyntheticTaskMonitorsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetSyntheticTaskMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSyntheticTaskMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSyntheticTaskMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTimingSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The ID of the synthetic monitoring task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetTimingSyntheticTaskResponseBodyDataAvailableAssertions(TeaModel):
    def __init__(
        self,
        expect: str = None,
        operator: str = None,
        target: str = None,
        type: str = None,
    ):
        # The expected value.
        self.expect = expect
        # The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
        self.operator = operator
        # The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
        self.target = target
        # The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect is not None:
            result['Expect'] = self.expect
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expect') is not None:
            self.expect = m.get('Expect')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts(TeaModel):
    def __init__(
        self,
        domain: str = None,
        ip_type: int = None,
        ips: List[str] = None,
    ):
        # The domain name.
        self.domain = domain
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4
        # *   2: IPv6
        self.ip_type = ip_type
        # The list of IP addresses.
        self.ips = ips

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.ips is not None:
            result['Ips'] = self.ips
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        return self


class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost(TeaModel):
    def __init__(
        self,
        hosts: List[GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts] = None,
        select_type: int = None,
    ):
        # The list of hosts.
        self.hosts = hosts
        # The selection mode. 0: Random. 1: Polling.
        self.select_type = select_type

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['Hosts'].append(k.to_map() if k else None)
        if self.select_type is not None:
            result['SelectType'] = self.select_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.hosts = []
        if m.get('Hosts') is not None:
            for k in m.get('Hosts'):
                temp_model = GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts()
                self.hosts.append(temp_model.from_map(k))
        if m.get('SelectType') is not None:
            self.select_type = m.get('SelectType')
        return self


class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting(TeaModel):
    def __init__(
        self,
        prometheus_cluster_id: str = None,
        prometheus_cluster_region: str = None,
        prometheus_labels: Dict[str, str] = None,
    ):
        # A reserved parameter.
        self.prometheus_cluster_id = prometheus_cluster_id
        # A reserved parameter.
        self.prometheus_cluster_region = prometheus_cluster_region
        # A reserved parameter.
        self.prometheus_labels = prometheus_labels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_cluster_id is not None:
            result['PrometheusClusterId'] = self.prometheus_cluster_id
        if self.prometheus_cluster_region is not None:
            result['PrometheusClusterRegion'] = self.prometheus_cluster_region
        if self.prometheus_labels is not None:
            result['PrometheusLabels'] = self.prometheus_labels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PrometheusClusterId') is not None:
            self.prometheus_cluster_id = m.get('PrometheusClusterId')
        if m.get('PrometheusClusterRegion') is not None:
            self.prometheus_cluster_region = m.get('PrometheusClusterRegion')
        if m.get('PrometheusLabels') is not None:
            self.prometheus_labels = m.get('PrometheusLabels')
        return self


class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        secure_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # Security group ID. This security group is where the dial-up client is located. The security group limits the inbound and outbound rules of the dial-up client in the VPC. You need to set the inbound rules of the security group where your VPC is located to allow the security group where the dial-up client is located to access. Otherwise, the dial-up client cannot smoothly access the resources in your VPC.
        self.secure_group_id = secure_group_id
        # The vSwitch ID.
        self.v_switch_id = v_switch_id
        # VPC ID.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.secure_group_id is not None:
            result['SecureGroupId'] = self.secure_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecureGroupId') is not None:
            self.secure_group_id = m.get('SecureGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class GetTimingSyntheticTaskResponseBodyDataCommonSetting(TeaModel):
    def __init__(
        self,
        custom_host: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost = None,
        custom_prometheus_setting: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting = None,
        custom_vpcsetting: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting = None,
        ip_type: int = None,
        is_open_trace: bool = None,
        monitor_samples: int = None,
        trace_client_type: int = None,
        xtrace_region: str = None,
    ):
        # The custom host.
        self.custom_host = custom_host
        # The reserved parameters.
        self.custom_prometheus_setting = custom_prometheus_setting
        # User VPC information. If the dial-up is to the Alibaba Cloud intranet address, you need to configure the VPC information.
        self.custom_vpcsetting = custom_vpcsetting
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4
        # *   2: IPv6
        self.ip_type = ip_type
        # Whether to enable tracing.
        self.is_open_trace = is_open_trace
        # Specifies whether to evenly distribute monitoring samples. Valid values:
        # 
        # *   0: No
        # *   1: Yes
        self.monitor_samples = monitor_samples
        # Tracing client type:
        # 
        # - 0: ARMS Agent
        # - 1: Open Telemetry
        # - 2: Jaeger
        self.trace_client_type = trace_client_type
        # Tracing data reporting region.
        self.xtrace_region = xtrace_region

    def validate(self):
        if self.custom_host:
            self.custom_host.validate()
        if self.custom_prometheus_setting:
            self.custom_prometheus_setting.validate()
        if self.custom_vpcsetting:
            self.custom_vpcsetting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_host is not None:
            result['CustomHost'] = self.custom_host.to_map()
        if self.custom_prometheus_setting is not None:
            result['CustomPrometheusSetting'] = self.custom_prometheus_setting.to_map()
        if self.custom_vpcsetting is not None:
            result['CustomVPCSetting'] = self.custom_vpcsetting.to_map()
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.is_open_trace is not None:
            result['IsOpenTrace'] = self.is_open_trace
        if self.monitor_samples is not None:
            result['MonitorSamples'] = self.monitor_samples
        if self.trace_client_type is not None:
            result['TraceClientType'] = self.trace_client_type
        if self.xtrace_region is not None:
            result['XtraceRegion'] = self.xtrace_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHost') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost()
            self.custom_host = temp_model.from_map(m['CustomHost'])
        if m.get('CustomPrometheusSetting') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting()
            self.custom_prometheus_setting = temp_model.from_map(m['CustomPrometheusSetting'])
        if m.get('CustomVPCSetting') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting()
            self.custom_vpcsetting = temp_model.from_map(m['CustomVPCSetting'])
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('IsOpenTrace') is not None:
            self.is_open_trace = m.get('IsOpenTrace')
        if m.get('MonitorSamples') is not None:
            self.monitor_samples = m.get('MonitorSamples')
        if m.get('TraceClientType') is not None:
            self.trace_client_type = m.get('TraceClientType')
        if m.get('XtraceRegion') is not None:
            self.xtrace_region = m.get('XtraceRegion')
        return self


class GetTimingSyntheticTaskResponseBodyDataCustomPeriod(TeaModel):
    def __init__(
        self,
        end_hour: int = None,
        start_hour: int = None,
    ):
        # The hour at which the test ends. Valid values: 0 to 24.
        self.end_hour = end_hour
        # The hour at which the test starts. Valid values: 0 to 24.
        self.start_hour = start_hour

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_hour is not None:
            result['EndHour'] = self.end_hour
        if self.start_hour is not None:
            result['StartHour'] = self.start_hour
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndHour') is not None:
            self.end_hour = m.get('EndHour')
        if m.get('StartHour') is not None:
            self.start_hour = m.get('StartHour')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        type: str = None,
    ):
        # The content of the request body. Format: JSON string. The parameter is required if the type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
        self.content = content
        # The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP(TeaModel):
    def __init__(
        self,
        check_cert: bool = None,
        connect_timeout: int = None,
        method: str = None,
        protocol_alpn_protocol: int = None,
        request_body: GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody = None,
        request_headers: Dict[str, str] = None,
        target_url: str = None,
        timeout: int = None,
    ):
        # Whether to verify the certificate. The default is no.
        self.check_cert = check_cert
        # The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
        self.connect_timeout = connect_timeout
        # The request method.
        # 
        # *   POST
        # *   GET
        self.method = method
        # The ALPN protocol version. You can configure this parameter when you perform an HTTPS synthetic test on a WAP mobile client. Valid values:
        # 
        # 0: default
        # 
        # 1: HTTP/1.1
        # 
        # 2: HTTP/2
        # 
        # 3: disables the ALPN protocol
        self.protocol_alpn_protocol = protocol_alpn_protocol
        # The HTTP request body.
        self.request_body = request_body
        # The HTTP request header.
        self.request_headers = request_headers
        # The URL for synthetic monitoring.
        self.target_url = target_url
        # The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
        self.timeout = timeout

    def validate(self):
        if self.request_body:
            self.request_body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_cert is not None:
            result['CheckCert'] = self.check_cert
        if self.connect_timeout is not None:
            result['ConnectTimeout'] = self.connect_timeout
        if self.method is not None:
            result['Method'] = self.method
        if self.protocol_alpn_protocol is not None:
            result['ProtocolAlpnProtocol'] = self.protocol_alpn_protocol
        if self.request_body is not None:
            result['RequestBody'] = self.request_body.to_map()
        if self.request_headers is not None:
            result['RequestHeaders'] = self.request_headers
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckCert') is not None:
            self.check_cert = m.get('CheckCert')
        if m.get('ConnectTimeout') is not None:
            self.connect_timeout = m.get('ConnectTimeout')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('ProtocolAlpnProtocol') is not None:
            self.protocol_alpn_protocol = m.get('ProtocolAlpnProtocol')
        if m.get('RequestBody') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody()
            self.request_body = temp_model.from_map(m['RequestBody'])
        if m.get('RequestHeaders') is not None:
            self.request_headers = m.get('RequestHeaders')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload(TeaModel):
    def __init__(
        self,
        connection_timeout: int = None,
        custom_header_content: Dict[str, str] = None,
        download_kernel: int = None,
        ignore_certificate_auth_error: int = None,
        ignore_certificate_canceled_error: int = None,
        ignore_certificate_out_of_date_error: int = None,
        ignore_certificate_status_error: int = None,
        ignore_certificate_untrustworthy_error: int = None,
        ignore_certificate_using_error: int = None,
        ignore_invalid_host_error: int = None,
        monitor_timeout: int = None,
        quick_protocol: int = None,
        redirection: int = None,
        target_url: str = None,
        transmission_size: int = None,
        validate_keywords: str = None,
        verify_way: int = None,
        white_list: str = None,
    ):
        # The connection timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
        self.connection_timeout = connection_timeout
        # The content of the custom request header.
        self.custom_header_content = custom_header_content
        # The kernel type.
        # 
        # *   1: curl
        # *   0: WinInet
        self.download_kernel = download_kernel
        # Specifies whether to ignore CA certificate authentication errors. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_auth_error = ignore_certificate_auth_error
        # Specifies whether to ignore certificate revocation errors. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_canceled_error = ignore_certificate_canceled_error
        # Specifies whether to ignore certificate invalidity. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_out_of_date_error = ignore_certificate_out_of_date_error
        # Specifies whether to ignore certificate status errors. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_status_error = ignore_certificate_status_error
        # Specifies whether to ignore certificate incredibility. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_untrustworthy_error = ignore_certificate_untrustworthy_error
        # Specifies whether to ignore certificate usage errors. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_using_error = ignore_certificate_using_error
        # Specifies whether to ignore host invalidity. 0: No. 1: Yes. Default value: 1.
        self.ignore_invalid_host_error = ignore_invalid_host_error
        # The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
        self.monitor_timeout = monitor_timeout
        # The QUIC protocol type.
        # 
        # *   1: http1
        # *   2: http2
        # *   3: http3
        self.quick_protocol = quick_protocol
        # Specifies whether to support redirection. 0: No. 1: Yes. Default value: 1.
        self.redirection = redirection
        # The file download URL.
        self.target_url = target_url
        # The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
        self.transmission_size = transmission_size
        # Verify keywords.
        self.validate_keywords = validate_keywords
        # Verification method.
        # 
        # - 0: No verification
        # - 1: Verification string
        # - 2: MD5 verification
        self.verify_way = verify_way
        # DNS hijacking whitelist. Matching rules support IP, IP wildcard, subnet mask and CNAME. You can fill in multiple matching rules, and multiple matching rules are separated by vertical bars (|). For example: `www.aliyun.com:203.0.3.55|203.3.44.67`, which means that all IPs except 203.0.3.55 and 203.3.44.67 under the www.aliyun.com domain name are hijacked.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_timeout is not None:
            result['ConnectionTimeout'] = self.connection_timeout
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.download_kernel is not None:
            result['DownloadKernel'] = self.download_kernel
        if self.ignore_certificate_auth_error is not None:
            result['IgnoreCertificateAuthError'] = self.ignore_certificate_auth_error
        if self.ignore_certificate_canceled_error is not None:
            result['IgnoreCertificateCanceledError'] = self.ignore_certificate_canceled_error
        if self.ignore_certificate_out_of_date_error is not None:
            result['IgnoreCertificateOutOfDateError'] = self.ignore_certificate_out_of_date_error
        if self.ignore_certificate_status_error is not None:
            result['IgnoreCertificateStatusError'] = self.ignore_certificate_status_error
        if self.ignore_certificate_untrustworthy_error is not None:
            result['IgnoreCertificateUntrustworthyError'] = self.ignore_certificate_untrustworthy_error
        if self.ignore_certificate_using_error is not None:
            result['IgnoreCertificateUsingError'] = self.ignore_certificate_using_error
        if self.ignore_invalid_host_error is not None:
            result['IgnoreInvalidHostError'] = self.ignore_invalid_host_error
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.quick_protocol is not None:
            result['QuickProtocol'] = self.quick_protocol
        if self.redirection is not None:
            result['Redirection'] = self.redirection
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.transmission_size is not None:
            result['TransmissionSize'] = self.transmission_size
        if self.validate_keywords is not None:
            result['ValidateKeywords'] = self.validate_keywords
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionTimeout') is not None:
            self.connection_timeout = m.get('ConnectionTimeout')
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('DownloadKernel') is not None:
            self.download_kernel = m.get('DownloadKernel')
        if m.get('IgnoreCertificateAuthError') is not None:
            self.ignore_certificate_auth_error = m.get('IgnoreCertificateAuthError')
        if m.get('IgnoreCertificateCanceledError') is not None:
            self.ignore_certificate_canceled_error = m.get('IgnoreCertificateCanceledError')
        if m.get('IgnoreCertificateOutOfDateError') is not None:
            self.ignore_certificate_out_of_date_error = m.get('IgnoreCertificateOutOfDateError')
        if m.get('IgnoreCertificateStatusError') is not None:
            self.ignore_certificate_status_error = m.get('IgnoreCertificateStatusError')
        if m.get('IgnoreCertificateUntrustworthyError') is not None:
            self.ignore_certificate_untrustworthy_error = m.get('IgnoreCertificateUntrustworthyError')
        if m.get('IgnoreCertificateUsingError') is not None:
            self.ignore_certificate_using_error = m.get('IgnoreCertificateUsingError')
        if m.get('IgnoreInvalidHostError') is not None:
            self.ignore_invalid_host_error = m.get('IgnoreInvalidHostError')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('QuickProtocol') is not None:
            self.quick_protocol = m.get('QuickProtocol')
        if m.get('Redirection') is not None:
            self.redirection = m.get('Redirection')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('TransmissionSize') is not None:
            self.transmission_size = m.get('TransmissionSize')
        if m.get('ValidateKeywords') is not None:
            self.validate_keywords = m.get('ValidateKeywords')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS(TeaModel):
    def __init__(
        self,
        dns_server_ip_type: int = None,
        ns_server: str = None,
        query_method: int = None,
        target_url: str = None,
        timeout: int = None,
    ):
        # The IP version of the DNS server. 0: IPv4. 1: IPv6. 2: A version is automatically selected. Default value: 0.
        self.dns_server_ip_type = dns_server_ip_type
        # The IP address of the DNS server. Default value: 114.114.114.114.
        self.ns_server = ns_server
        # The DNS query. 0: recursive, 1: iterative. Default value: 0.
        self.query_method = query_method
        # The destination domain name.
        self.target_url = target_url
        # The timeout period for the DNS synthetic test. Unit: milliseconds. The minimum value is 1000 and the maximum value is 45000. Default value: 5000.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dns_server_ip_type is not None:
            result['DnsServerIpType'] = self.dns_server_ip_type
        if self.ns_server is not None:
            result['NsServer'] = self.ns_server
        if self.query_method is not None:
            result['QueryMethod'] = self.query_method
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnsServerIpType') is not None:
            self.dns_server_ip_type = m.get('DnsServerIpType')
        if m.get('NsServer') is not None:
            self.ns_server = m.get('NsServer')
        if m.get('QueryMethod') is not None:
            self.query_method = m.get('QueryMethod')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP(TeaModel):
    def __init__(
        self,
        interval: int = None,
        package_num: int = None,
        package_size: int = None,
        split_package: bool = None,
        target_url: str = None,
        timeout: int = None,
        tracert_enable: bool = None,
        tracert_num_max: int = None,
        tracert_timeout: int = None,
    ):
        # The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 2000. Default value: 200.
        self.interval = interval
        # The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
        self.package_num = package_num
        # The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024.
        self.package_size = package_size
        # Specifies whether to split ICMP packets. Default value: true.
        self.split_package = split_package
        # The destination host IP address or domain name
        self.target_url = target_url
        # The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
        self.timeout = timeout
        # Specifies whether to enable the tracert command. Default value: true.
        self.tracert_enable = tracert_enable
        # The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 64.
        self.tracert_num_max = tracert_num_max
        # The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
        self.tracert_timeout = tracert_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.package_num is not None:
            result['PackageNum'] = self.package_num
        if self.package_size is not None:
            result['PackageSize'] = self.package_size
        if self.split_package is not None:
            result['SplitPackage'] = self.split_package
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.tracert_enable is not None:
            result['TracertEnable'] = self.tracert_enable
        if self.tracert_num_max is not None:
            result['TracertNumMax'] = self.tracert_num_max
        if self.tracert_timeout is not None:
            result['TracertTimeout'] = self.tracert_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PackageNum') is not None:
            self.package_num = m.get('PackageNum')
        if m.get('PackageSize') is not None:
            self.package_size = m.get('PackageSize')
        if m.get('SplitPackage') is not None:
            self.split_package = m.get('SplitPackage')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TracertEnable') is not None:
            self.tracert_enable = m.get('TracertEnable')
        if m.get('TracertNumMax') is not None:
            self.tracert_num_max = m.get('TracertNumMax')
        if m.get('TracertTimeout') is not None:
            self.tracert_timeout = m.get('TracertTimeout')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP(TeaModel):
    def __init__(
        self,
        connect_times: int = None,
        interval: int = None,
        target_url: str = None,
        timeout: int = None,
        tracert_enable: bool = None,
        tracert_num_max: int = None,
        tracert_timeout: int = None,
    ):
        # The number of TCP connections that are established in a test. Minimum value: 1. Maximum value: 16. Default value: 4.
        self.connect_times = connect_times
        # The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
        self.interval = interval
        # The destination host IP address.
        self.target_url = target_url
        # The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
        self.timeout = timeout
        # Specifies whether to enable the tracert command. Default value: true.
        self.tracert_enable = tracert_enable
        # The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 20.
        self.tracert_num_max = tracert_num_max
        # The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
        self.tracert_timeout = tracert_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_times is not None:
            result['ConnectTimes'] = self.connect_times
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.tracert_enable is not None:
            result['TracertEnable'] = self.tracert_enable
        if self.tracert_num_max is not None:
            result['TracertNumMax'] = self.tracert_num_max
        if self.tracert_timeout is not None:
            result['TracertTimeout'] = self.tracert_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectTimes') is not None:
            self.connect_times = m.get('ConnectTimes')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TracertEnable') is not None:
            self.tracert_enable = m.get('TracertEnable')
        if m.get('TracertNumMax') is not None:
            self.tracert_num_max = m.get('TracertNumMax')
        if m.get('TracertTimeout') is not None:
            self.tracert_timeout = m.get('TracertTimeout')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfStream(TeaModel):
    def __init__(
        self,
        custom_header_content: Dict[str, str] = None,
        player_type: int = None,
        stream_address_type: int = None,
        stream_monitor_timeout: int = None,
        stream_type: int = None,
        target_url: str = None,
        white_list: str = None,
    ):
        # Custom header, JSON Map format.
        self.custom_header_content = custom_header_content
        # Player, default is 12 if not specified.
        # 
        # - 12: VLC
        # - 2: Flash Player
        self.player_type = player_type
        # Resource address type:
        # 
        # - 1: Resource address.
        # - 0: Page address. If not passed, the default value is 0.
        self.stream_address_type = stream_address_type
        # Monitoring duration, in seconds, supports up to 60 seconds. If not specified, the default value is 60 seconds.
        self.stream_monitor_timeout = stream_monitor_timeout
        # Audio and video flag:
        # 
        # - 0: video
        # - 1: audio
        self.stream_type = stream_type
        # Streaming media resource address.
        self.target_url = target_url
        # DNS hijacking whitelist. Matching rules support IP, IP wildcard, subnet mask and CNAME. You can fill in multiple matching rules, and multiple matching rules are separated by vertical bars (|). For example: `www.aliyun.com:203.0.3.55|203.3.44.67`, which means that all IPs except 203.0.3.55 and 203.3.44.67 under the www.aliyun.com domain name are hijacked.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.player_type is not None:
            result['PlayerType'] = self.player_type
        if self.stream_address_type is not None:
            result['StreamAddressType'] = self.stream_address_type
        if self.stream_monitor_timeout is not None:
            result['StreamMonitorTimeout'] = self.stream_monitor_timeout
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('PlayerType') is not None:
            self.player_type = m.get('PlayerType')
        if m.get('StreamAddressType') is not None:
            self.stream_address_type = m.get('StreamAddressType')
        if m.get('StreamMonitorTimeout') is not None:
            self.stream_monitor_timeout = m.get('StreamMonitorTimeout')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite(TeaModel):
    def __init__(
        self,
        automatic_scrolling: int = None,
        custom_header: int = None,
        custom_header_content: Dict[str, str] = None,
        dnshijack_whitelist: str = None,
        disable_cache: int = None,
        disable_compression: int = None,
        element_blacklist: str = None,
        filter_invalid_ip: int = None,
        flow_hijack_jump_times: int = None,
        flow_hijack_logo: str = None,
        ignore_certificate_error: int = None,
        monitor_timeout: int = None,
        page_tamper: str = None,
        redirection: int = None,
        slow_element_threshold: int = None,
        target_url: str = None,
        verify_string_blacklist: str = None,
        verify_string_whitelist: str = None,
        wait_completion_time: int = None,
    ):
        # Specifies whether to automatically scroll up and down the screen to load a page. 0: No. 1: Yes. Default value: 0.
        self.automatic_scrolling = automatic_scrolling
        # Specifies whether to create a custom header. 0: No. 1: The first packet is modified. 2: All packets are modified. Default value: 0.
        self.custom_header = custom_header
        # The custom header. Format: JSON map.
        self.custom_header_content = custom_header_content
        # When resolving a domain name (such as www.aliyun.com), if the resolved IP address or CNAME is not in the DNS hijacking whitelist, the user will fail to access or return a non-Aliyun target IP; if the IP or CNAME in the resolution result is in the DNS whitelist, it will be deemed that no DNS hijacking has occurred.
        # 
        # Fill in the format: `domain name: matching rule`. Matching rules support IP, IP wildcard, subnet mask and CNAME. You can fill in multiple matching rules, and multiple matching rules are separated by vertical bars (|). 
        # 
        # For example: `www.aliyun.com:203.0.3.55|203.3.44.67`, which means that all IPs except 203.0.3.55 and 203.3.44.67 under the www.aliyun.com domain name are hijacked.
        self.dnshijack_whitelist = dnshijack_whitelist
        # Specifies whether to disable the cache. 0: No. 1: Yes. Default value: 1.
        self.disable_cache = disable_cache
        # Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. 0: No. 1: Yes. Default value: 0.
        self.disable_compression = disable_compression
        # If an element configured in the element blacklist appears during page loading, no request will be made to load the element.
        self.element_blacklist = element_blacklist
        # Specifies whether to exclude invalid IP addresses.
        # 
        # *   1: No
        # *   0: Yes
        self.filter_invalid_ip = filter_invalid_ip
        # Identify elements: Set the total number of elements to browse the page.
        self.flow_hijack_jump_times = flow_hijack_jump_times
        # Hijacking flag: Set the key information for matching. Fill in the hijacking judgment keyword or key element, and asterisks (*) are allowed.
        self.flow_hijack_logo = flow_hijack_logo
        # Specifies whether to ignore SSL certificate errors during browsing. 0: No. 1: Yes. Default value: 1.
        self.ignore_certificate_error = ignore_certificate_error
        # The monitoring timeout period. Unit: milliseconds. Default value: 20000. Minimum value: 5000. Maximum value: 300000.
        self.monitor_timeout = monitor_timeout
        # If any element other than the domain name setting appears on the monitoring page, it means that the page has been tampered. Common manifestations include pop-up ads, floating ads, jumps, etc.
        # 
        # Fill in the format: `domain name: element`. Elements support wildcards, and multiple elements can be filled in. Multiple elements are separated by vertical bars (|). For example: `www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg`, which means that all elements except the basic document, /cc/bb/a.gif and /vv/bb/cc.jpg under the www.aliyun.com domain name are considered to be tampered with.
        self.page_tamper = page_tamper
        # Specifies whether to continue browsing after redirection. 0: No, 1:Yes. Default value: 1.
        self.redirection = redirection
        # The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
        self.slow_element_threshold = slow_element_threshold
        # The destination URL.
        self.target_url = target_url
        # The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any string in the blacklist, an error 650 &quot;Verification string failed&quot; will be reported. Multiple strings are separated by vertical bars (|).
        self.verify_string_blacklist = verify_string_blacklist
        # The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist, otherwise an error 650 &quot;Verification string failed&quot; will be reported. Multiple strings are separated by a vertical bar (|).
        self.verify_string_whitelist = verify_string_whitelist
        # The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
        self.wait_completion_time = wait_completion_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.automatic_scrolling is not None:
            result['AutomaticScrolling'] = self.automatic_scrolling
        if self.custom_header is not None:
            result['CustomHeader'] = self.custom_header
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.dnshijack_whitelist is not None:
            result['DNSHijackWhitelist'] = self.dnshijack_whitelist
        if self.disable_cache is not None:
            result['DisableCache'] = self.disable_cache
        if self.disable_compression is not None:
            result['DisableCompression'] = self.disable_compression
        if self.element_blacklist is not None:
            result['ElementBlacklist'] = self.element_blacklist
        if self.filter_invalid_ip is not None:
            result['FilterInvalidIP'] = self.filter_invalid_ip
        if self.flow_hijack_jump_times is not None:
            result['FlowHijackJumpTimes'] = self.flow_hijack_jump_times
        if self.flow_hijack_logo is not None:
            result['FlowHijackLogo'] = self.flow_hijack_logo
        if self.ignore_certificate_error is not None:
            result['IgnoreCertificateError'] = self.ignore_certificate_error
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.page_tamper is not None:
            result['PageTamper'] = self.page_tamper
        if self.redirection is not None:
            result['Redirection'] = self.redirection
        if self.slow_element_threshold is not None:
            result['SlowElementThreshold'] = self.slow_element_threshold
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.verify_string_blacklist is not None:
            result['VerifyStringBlacklist'] = self.verify_string_blacklist
        if self.verify_string_whitelist is not None:
            result['VerifyStringWhitelist'] = self.verify_string_whitelist
        if self.wait_completion_time is not None:
            result['WaitCompletionTime'] = self.wait_completion_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutomaticScrolling') is not None:
            self.automatic_scrolling = m.get('AutomaticScrolling')
        if m.get('CustomHeader') is not None:
            self.custom_header = m.get('CustomHeader')
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('DNSHijackWhitelist') is not None:
            self.dnshijack_whitelist = m.get('DNSHijackWhitelist')
        if m.get('DisableCache') is not None:
            self.disable_cache = m.get('DisableCache')
        if m.get('DisableCompression') is not None:
            self.disable_compression = m.get('DisableCompression')
        if m.get('ElementBlacklist') is not None:
            self.element_blacklist = m.get('ElementBlacklist')
        if m.get('FilterInvalidIP') is not None:
            self.filter_invalid_ip = m.get('FilterInvalidIP')
        if m.get('FlowHijackJumpTimes') is not None:
            self.flow_hijack_jump_times = m.get('FlowHijackJumpTimes')
        if m.get('FlowHijackLogo') is not None:
            self.flow_hijack_logo = m.get('FlowHijackLogo')
        if m.get('IgnoreCertificateError') is not None:
            self.ignore_certificate_error = m.get('IgnoreCertificateError')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('PageTamper') is not None:
            self.page_tamper = m.get('PageTamper')
        if m.get('Redirection') is not None:
            self.redirection = m.get('Redirection')
        if m.get('SlowElementThreshold') is not None:
            self.slow_element_threshold = m.get('SlowElementThreshold')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('VerifyStringBlacklist') is not None:
            self.verify_string_blacklist = m.get('VerifyStringBlacklist')
        if m.get('VerifyStringWhitelist') is not None:
            self.verify_string_whitelist = m.get('VerifyStringWhitelist')
        if m.get('WaitCompletionTime') is not None:
            self.wait_completion_time = m.get('WaitCompletionTime')
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitorConf(TeaModel):
    def __init__(
        self,
        api_http: GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP = None,
        file_download: GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload = None,
        net_dns: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS = None,
        net_icmp: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP = None,
        net_tcp: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP = None,
        stream: GetTimingSyntheticTaskResponseBodyDataMonitorConfStream = None,
        website: GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite = None,
    ):
        # The parameters of the HTTP(S) synthetic test.
        self.api_http = api_http
        # The file download parameters.
        self.file_download = file_download
        # The DNS synthetic test parameters. This parameter is required if the TaskType parameter is set to 3.
        self.net_dns = net_dns
        # The ICMP synthetic test parameters. This parameter is required if the TaskType parameter is set to 1.
        self.net_icmp = net_icmp
        # The TCP synthetic tests parameters. This parameter is required if the TaskType parameter is set to 2.
        self.net_tcp = net_tcp
        # Streaming media dial test configuration.
        self.stream = stream
        # The website-speed measurement parameters.
        self.website = website

    def validate(self):
        if self.api_http:
            self.api_http.validate()
        if self.file_download:
            self.file_download.validate()
        if self.net_dns:
            self.net_dns.validate()
        if self.net_icmp:
            self.net_icmp.validate()
        if self.net_tcp:
            self.net_tcp.validate()
        if self.stream:
            self.stream.validate()
        if self.website:
            self.website.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_http is not None:
            result['ApiHTTP'] = self.api_http.to_map()
        if self.file_download is not None:
            result['FileDownload'] = self.file_download.to_map()
        if self.net_dns is not None:
            result['NetDNS'] = self.net_dns.to_map()
        if self.net_icmp is not None:
            result['NetICMP'] = self.net_icmp.to_map()
        if self.net_tcp is not None:
            result['NetTCP'] = self.net_tcp.to_map()
        if self.stream is not None:
            result['Stream'] = self.stream.to_map()
        if self.website is not None:
            result['Website'] = self.website.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiHTTP') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP()
            self.api_http = temp_model.from_map(m['ApiHTTP'])
        if m.get('FileDownload') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload()
            self.file_download = temp_model.from_map(m['FileDownload'])
        if m.get('NetDNS') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS()
            self.net_dns = temp_model.from_map(m['NetDNS'])
        if m.get('NetICMP') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP()
            self.net_icmp = temp_model.from_map(m['NetICMP'])
        if m.get('NetTCP') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP()
            self.net_tcp = temp_model.from_map(m['NetTCP'])
        if m.get('Stream') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfStream()
            self.stream = temp_model.from_map(m['Stream'])
        if m.get('Website') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite()
            self.website = temp_model.from_map(m['Website'])
        return self


class GetTimingSyntheticTaskResponseBodyDataMonitors(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        client_type: int = None,
        operator_code: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
        self.client_type = client_type
        # The carrier code.
        self.operator_code = operator_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.operator_code is not None:
            result['OperatorCode'] = self.operator_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('OperatorCode') is not None:
            self.operator_code = m.get('OperatorCode')
        return self


class GetTimingSyntheticTaskResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTimingSyntheticTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        available_assertions: List[GetTimingSyntheticTaskResponseBodyDataAvailableAssertions] = None,
        common_setting: GetTimingSyntheticTaskResponseBodyDataCommonSetting = None,
        custom_period: GetTimingSyntheticTaskResponseBodyDataCustomPeriod = None,
        frequency: str = None,
        monitor_category: int = None,
        monitor_conf: GetTimingSyntheticTaskResponseBodyDataMonitorConf = None,
        monitors: List[GetTimingSyntheticTaskResponseBodyDataMonitors] = None,
        name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        status: str = None,
        tags: List[GetTimingSyntheticTaskResponseBodyDataTags] = None,
        task_id: str = None,
        task_type: int = None,
    ):
        # The list of assertions.
        self.available_assertions = available_assertions
        # The general settings.
        self.common_setting = common_setting
        # The custom cycle.
        self.custom_period = custom_period
        # The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
        self.frequency = frequency
        # The detection point type. 1: PC. 2: mobile device.
        self.monitor_category = monitor_category
        # The monitoring configurations.
        self.monitor_conf = monitor_conf
        # The list of monitoring points.
        self.monitors = monitors
        # The name of the task.
        self.name = name
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota insufficiency. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: The task failed to be deleted.
        self.status = status
        # The tag.
        self.tags = tags
        # The ID of the synthetic monitoring task.
        self.task_id = task_id
        # The type of the task. Valid values:
        # 
        # ICMP TCP DNS HTTP Website speed measurement File download
        self.task_type = task_type

    def validate(self):
        if self.available_assertions:
            for k in self.available_assertions:
                if k:
                    k.validate()
        if self.common_setting:
            self.common_setting.validate()
        if self.custom_period:
            self.custom_period.validate()
        if self.monitor_conf:
            self.monitor_conf.validate()
        if self.monitors:
            for k in self.monitors:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableAssertions'] = []
        if self.available_assertions is not None:
            for k in self.available_assertions:
                result['AvailableAssertions'].append(k.to_map() if k else None)
        if self.common_setting is not None:
            result['CommonSetting'] = self.common_setting.to_map()
        if self.custom_period is not None:
            result['CustomPeriod'] = self.custom_period.to_map()
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.monitor_category is not None:
            result['MonitorCategory'] = self.monitor_category
        if self.monitor_conf is not None:
            result['MonitorConf'] = self.monitor_conf.to_map()
        result['Monitors'] = []
        if self.monitors is not None:
            for k in self.monitors:
                result['Monitors'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.available_assertions = []
        if m.get('AvailableAssertions') is not None:
            for k in m.get('AvailableAssertions'):
                temp_model = GetTimingSyntheticTaskResponseBodyDataAvailableAssertions()
                self.available_assertions.append(temp_model.from_map(k))
        if m.get('CommonSetting') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataCommonSetting()
            self.common_setting = temp_model.from_map(m['CommonSetting'])
        if m.get('CustomPeriod') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataCustomPeriod()
            self.custom_period = temp_model.from_map(m['CustomPeriod'])
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('MonitorCategory') is not None:
            self.monitor_category = m.get('MonitorCategory')
        if m.get('MonitorConf') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyDataMonitorConf()
            self.monitor_conf = temp_model.from_map(m['MonitorConf'])
        self.monitors = []
        if m.get('Monitors') is not None:
            for k in m.get('Monitors'):
                temp_model = GetTimingSyntheticTaskResponseBodyDataMonitors()
                self.monitors.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTimingSyntheticTaskResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class GetTimingSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetTimingSyntheticTaskResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code returned. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The message returned.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetTimingSyntheticTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTimingSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTimingSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTimingSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTraceRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        region_id: str = None,
        start_time: int = None,
        trace_id: str = None,
    ):
        # The end of the time range to query. Unit: milliseconds.
        # 
        # > If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.
        self.end_time = end_time
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The beginning of the time range to query. Unit: milliseconds.
        # 
        # > If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.
        self.start_time = start_time
        # The trace ID. You can log on to the ARMS console and obtain the trace ID on the **Trace Query** page or **Interface Snapshot** tab.
        # 
        # This parameter is required.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class GetTraceResponseBodySpansLogEventListTagEntryList(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTraceResponseBodySpansLogEventList(TeaModel):
    def __init__(
        self,
        tag_entry_list: List[GetTraceResponseBodySpansLogEventListTagEntryList] = None,
        timestamp: int = None,
    ):
        # The tags of the trace.
        self.tag_entry_list = tag_entry_list
        # The timestamp when the log event was generated.
        self.timestamp = timestamp

    def validate(self):
        if self.tag_entry_list:
            for k in self.tag_entry_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagEntryList'] = []
        if self.tag_entry_list is not None:
            for k in self.tag_entry_list:
                result['TagEntryList'].append(k.to_map() if k else None)
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tag_entry_list = []
        if m.get('TagEntryList') is not None:
            for k in m.get('TagEntryList'):
                temp_model = GetTraceResponseBodySpansLogEventListTagEntryList()
                self.tag_entry_list.append(temp_model.from_map(k))
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class GetTraceResponseBodySpansTagEntryList(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTraceResponseBodySpans(TeaModel):
    def __init__(
        self,
        children: List[Dict[str, Any]] = None,
        duration: int = None,
        have_stack: bool = None,
        log_event_list: List[GetTraceResponseBodySpansLogEventList] = None,
        operation_name: str = None,
        parent_span_id: str = None,
        result_code: str = None,
        rpc_id: str = None,
        rpc_type: int = None,
        service_ip: str = None,
        service_name: str = None,
        span_id: str = None,
        tag_entry_list: List[GetTraceResponseBodySpansTagEntryList] = None,
        timestamp: int = None,
        trace_id: str = None,
    ):
        # The child spans of the current span.
        self.children = children
        # The amount of time consumed by the trace. Unit: milliseconds.
        self.duration = duration
        # Indicates whether a method stack was provided.
        # 
        # *   `true`: A method stack was provided.
        # *   `false`: No method stack was provided.
        self.have_stack = have_stack
        # The log events in the trace.
        self.log_event_list = log_event_list
        # The name of the traced span.
        self.operation_name = operation_name
        # The ID of the parent span.
        self.parent_span_id = parent_span_id
        # The status code.
        self.result_code = result_code
        # The ID of the RPC mode.
        self.rpc_id = rpc_id
        # The type of the remote procedure call (RPC) mode.
        # 
        # *   0: HTTP entry
        # *   25: HTTP call
        # *   1: High-speed Service Framework (HSF) call
        # *   2: HSF provision
        # *   40: on-premises API call
        # *   60: MySQL call
        # *   62: Oracle call
        # *   63: PostgreSQL call
        # *   70: Redis call
        # *   4: Taobao Distributed Data Layer (TDDL) call
        # *   5: Tair call
        # *   13: MetaQ message sending
        # *   252: MetaQ message receiving
        # *   3: notification sending
        # *   254: notification receiving
        # *   7: Apache Dubbo call
        # *   8: Apache Dubbo provision
        # *   19: SOFARPC call
        # *   18: SOFARPC provision
        # *   11: Distributed Service Framework (DSF) call
        # *   12: DSF provision
        # *   \\-1: unknown call
        self.rpc_type = rpc_type
        # The IP address of the host where the application resides.
        self.service_ip = service_ip
        # The name of the application.
        self.service_name = service_name
        # The span ID.
        self.span_id = span_id
        # The tags of the trace.
        self.tag_entry_list = tag_entry_list
        # The timestamp generated when the span was generated.
        self.timestamp = timestamp
        # The trace ID.
        self.trace_id = trace_id

    def validate(self):
        if self.log_event_list:
            for k in self.log_event_list:
                if k:
                    k.validate()
        if self.tag_entry_list:
            for k in self.tag_entry_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.children is not None:
            result['Children'] = self.children
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.have_stack is not None:
            result['HaveStack'] = self.have_stack
        result['LogEventList'] = []
        if self.log_event_list is not None:
            for k in self.log_event_list:
                result['LogEventList'].append(k.to_map() if k else None)
        if self.operation_name is not None:
            result['OperationName'] = self.operation_name
        if self.parent_span_id is not None:
            result['ParentSpanId'] = self.parent_span_id
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.rpc_id is not None:
            result['RpcId'] = self.rpc_id
        if self.rpc_type is not None:
            result['RpcType'] = self.rpc_type
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.span_id is not None:
            result['SpanId'] = self.span_id
        result['TagEntryList'] = []
        if self.tag_entry_list is not None:
            for k in self.tag_entry_list:
                result['TagEntryList'].append(k.to_map() if k else None)
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Children') is not None:
            self.children = m.get('Children')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('HaveStack') is not None:
            self.have_stack = m.get('HaveStack')
        self.log_event_list = []
        if m.get('LogEventList') is not None:
            for k in m.get('LogEventList'):
                temp_model = GetTraceResponseBodySpansLogEventList()
                self.log_event_list.append(temp_model.from_map(k))
        if m.get('OperationName') is not None:
            self.operation_name = m.get('OperationName')
        if m.get('ParentSpanId') is not None:
            self.parent_span_id = m.get('ParentSpanId')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('RpcId') is not None:
            self.rpc_id = m.get('RpcId')
        if m.get('RpcType') is not None:
            self.rpc_type = m.get('RpcType')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('SpanId') is not None:
            self.span_id = m.get('SpanId')
        self.tag_entry_list = []
        if m.get('TagEntryList') is not None:
            for k in m.get('TagEntryList'):
                temp_model = GetTraceResponseBodySpansTagEntryList()
                self.tag_entry_list.append(temp_model.from_map(k))
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class GetTraceResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        spans: List[GetTraceResponseBodySpans] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the trace.
        self.spans = spans

    def validate(self):
        if self.spans:
            for k in self.spans:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Spans'] = []
        if self.spans is not None:
            for k in self.spans:
                result['Spans'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.spans = []
        if m.get('Spans') is not None:
            for k in m.get('Spans'):
                temp_model = GetTraceResponseBodySpans()
                self.spans.append(temp_model.from_map(k))
        return self


class GetTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTraceAppRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTraceAppRequest(TeaModel):
    def __init__(
        self,
        pid: str = None,
        region_id: str = None,
        tags: List[GetTraceAppRequestTags] = None,
    ):
        # The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # 
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTraceAppRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetTraceAppResponseBodyTraceAppTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetTraceAppResponseBodyTraceApp(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        app_name: str = None,
        cluster_id: str = None,
        create_time: int = None,
        labels: List[str] = None,
        language: str = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        show: bool = None,
        source: str = None,
        tags: List[GetTraceAppResponseBodyTraceAppTags] = None,
        type: str = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # Cluster ID, used only in K8s scenarios.
        self.cluster_id = cluster_id
        # The timestamp generated when the task was created.
        self.create_time = create_time
        # The aliases of the application.
        self.labels = labels
        # Coding Language.
        self.language = language
        # The process identifier (PID) of the application.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
        # 
        # *   `true`: yes
        # *   `false`: no
        self.show = show
        # The source of the application.
        self.source = source
        # A list of key-value pairs.
        self.tags = tags
        # The type of the monitoring task. Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: Browser Monitoring
        self.type = type
        # The timestamp generated when the task information was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.language is not None:
            result['Language'] = self.language
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.show is not None:
            result['Show'] = self.show
        if self.source is not None:
            result['Source'] = self.source
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = GetTraceAppResponseBodyTraceAppTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetTraceAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        trace_app: GetTraceAppResponseBodyTraceApp = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the array object.
        self.trace_app = trace_app

    def validate(self):
        if self.trace_app:
            self.trace_app.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trace_app is not None:
            result['TraceApp'] = self.trace_app.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TraceApp') is not None:
            temp_model = GetTraceAppResponseBodyTraceApp()
            self.trace_app = temp_model.from_map(m['TraceApp'])
        return self


class GetTraceAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTraceAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTraceAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTraceAppConfigRequest(TeaModel):
    def __init__(
        self,
        pid: str = None,
    ):
        # The process ID (PID) of the application.
        # 
        # You can use one of the following methods to obtain the PID:
        # 
        # *   API: Call the [ListTraceApps](https://help.aliyun.com/document_detail/2588008.html) operation
        # *   Console: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Application Monitoring** > **Application List**. On the Application List page, click the name of your application. The URL in the address bar contains the PID of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with an at sign (@) to obtain xxx@74xxx.
        # 
        # > 
        # 
        # *   To obtain the PID in the console, your application must be monitored by Application Monitoring rather than Managed Service for OpenTelemetry.
        # 
        # *   The GetTraceAppConfig operation can query only the custom settings of applications that are monitored by Application Monitoring.
        # 
        # This parameter is required.
        self.pid = pid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        return self


class GetTraceAppConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code.
        # 
        # Valid values:
        # 
        # *   2xx: The request was successful.
        # *   3xx: The request was redirected.
        # *   4xx: A request error occurred.
        # *   5xx: A server error occurred.
        self.code = code
        # The custom settings of the application, which is a JSON string. For more information, see **Additional description of response parameters**.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetTraceAppConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTraceAppConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTraceAppConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportAppAlertRulesRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ImportAppAlertRulesRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids: str = None,
        is_auto_start: bool = None,
        pids: str = None,
        region_id: str = None,
        tags: List[ImportAppAlertRulesRequestTags] = None,
        templage_alert_config: str = None,
        template_alert_id: str = None,
    ):
        # The IDs of the alert contact groups. The value must be a JSON array.
        self.contact_group_ids = contact_group_ids
        # Specifies whether to enable the alert rule after it is created. Default value: `false`.
        # 
        # *   `true`: enables the alert rule.
        # *   `false`: disables the alert rule.
        self.is_auto_start = is_auto_start
        # The process identifiers (PIDs) of the applications associated with the alert rule. The value must be a JSON array. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100#section-bkl-3j6-ezg~~).
        # 
        # This parameter is required.
        self.pids = pids
        # The ID of the region where the associated applications reside.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The list of tags.
        self.tags = tags
        # The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.
        self.templage_alert_config = templage_alert_config
        # The ID of the alert template. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails.
        self.template_alert_id = template_alert_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids is not None:
            result['ContactGroupIds'] = self.contact_group_ids
        if self.is_auto_start is not None:
            result['IsAutoStart'] = self.is_auto_start
        if self.pids is not None:
            result['Pids'] = self.pids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.templage_alert_config is not None:
            result['TemplageAlertConfig'] = self.templage_alert_config
        if self.template_alert_id is not None:
            result['TemplateAlertId'] = self.template_alert_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupIds') is not None:
            self.contact_group_ids = m.get('ContactGroupIds')
        if m.get('IsAutoStart') is not None:
            self.is_auto_start = m.get('IsAutoStart')
        if m.get('Pids') is not None:
            self.pids = m.get('Pids')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ImportAppAlertRulesRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TemplageAlertConfig') is not None:
            self.templage_alert_config = m.get('TemplageAlertConfig')
        if m.get('TemplateAlertId') is not None:
            self.template_alert_id = m.get('TemplateAlertId')
        return self


class ImportAppAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The ID of the alert rule.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportAppAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportAppAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportAppAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InitEnvironmentRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        create_auth_token: bool = None,
        environment_id: str = None,
        managed_type: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # Specifies whether to create a token to improve data security.
        self.create_auth_token = create_auth_token
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # Whether agents or exporters are managed. Valid values:
        # 
        # *   none: No. By default, no managed agents or exporters are provided for ACK clusters.
        # *   agent: Agents are managed. By default, managed agents are provided for ASK clusters, ACS clusters, and ACK One clusters.
        # *   agent-exproter: Agents and exporters are managed. By default, managed agents and exporters are provided for cloud services.
        self.managed_type = managed_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.create_auth_token is not None:
            result['CreateAuthToken'] = self.create_auth_token
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('CreateAuthToken') is not None:
            self.create_auth_token = m.get('CreateAuthToken')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class InitEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InitEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InitEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InitEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallAddonRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        aliyun_lang: str = None,
        dry_run: bool = None,
        environment_id: str = None,
        name: str = None,
        region_id: str = None,
        release_name: str = None,
        values: str = None,
    ):
        # The version of the add-on.
        # 
        # This parameter is required.
        self.addon_version = addon_version
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # Specifies whether to perform only a dry run, without performing the actual request. Default value: false.
        self.dry_run = dry_run
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The name of the add-on.
        # 
        # This parameter is required.
        self.name = name
        # The region ID.
        self.region_id = region_id
        # The name of the add-on after it is installed. If you do not specify this parameter, a default rule name is generated.
        self.release_name = release_name
        # The metadata.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class InstallAddonResponseBodyDataConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        # The first transition time.
        self.first_transition_time = first_transition_time
        # The last transition time.
        self.last_transition_time = last_transition_time
        # The returned message.
        self.message = message
        # The reason for the failure.
        self.reason = reason
        # The status of the phase.
        self.status = status
        # The type of the phase.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['FirstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['LastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['Message'] = self.message
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstTransitionTime') is not None:
            self.first_transition_time = m.get('FirstTransitionTime')
        if m.get('LastTransitionTime') is not None:
            self.last_transition_time = m.get('LastTransitionTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class InstallAddonResponseBodyData(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[InstallAddonResponseBodyDataConditions] = None,
        create_time: str = None,
        dashboard_count: int = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
    ):
        # The name of the add-on.
        self.addon_name = addon_name
        # The number of alert rules.
        self.alert_rule_count = alert_rule_count
        # The installation phase.
        self.conditions = conditions
        # The time when the add-on was created.
        self.create_time = create_time
        # The number of dashboards.
        self.dashboard_count = dashboard_count
        # The environment ID.
        self.environment_id = environment_id
        # The number of exporters.
        self.exporter_count = exporter_count
        # Indicates whether the configuration is available.
        self.have_config = have_config
        # The user ID.
        self.install_user_id = install_user_id
        # The language.
        self.language = language
        # Indicates whether the component is fully managed.
        self.managed = managed
        # The region ID.
        self.region_id = region_id
        # The release ID after installation.
        self.release_id = release_id
        # The name of the release.
        self.release_name = release_name
        # The scenario.
        self.scene = scene
        # The status.
        self.status = status
        # The time when the add-on was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id
        # The version of the add-on.
        self.version = version

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['AlertRuleCount'] = self.alert_rule_count
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dashboard_count is not None:
            result['DashboardCount'] = self.dashboard_count
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['ExporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['HaveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['InstallUserId'] = self.install_user_id
        if self.language is not None:
            result['Language'] = self.language
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_id is not None:
            result['ReleaseId'] = self.release_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AlertRuleCount') is not None:
            self.alert_rule_count = m.get('AlertRuleCount')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = InstallAddonResponseBodyDataConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DashboardCount') is not None:
            self.dashboard_count = m.get('DashboardCount')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('ExporterCount') is not None:
            self.exporter_count = m.get('ExporterCount')
        if m.get('HaveConfig') is not None:
            self.have_config = m.get('HaveConfig')
        if m.get('InstallUserId') is not None:
            self.install_user_id = m.get('InstallUserId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseId') is not None:
            self.release_id = m.get('ReleaseId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class InstallAddonResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: InstallAddonResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned data.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InstallAddonResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallAddonResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallAddonResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallAddonResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallCmsExporterRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cms_args: str = None,
        direct_args: str = None,
        enable_tag: bool = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The cloud services that you want to monitor. The CmsArgs parameter is the startup parameter of the cms-exporter collector. Separate multiple cloud services with number signs (`#`).
        self.cms_args = cms_args
        # The recently monitored cloud services. Separate multiple cloud services with number signs (`#`).
        self.direct_args = direct_args
        # Specifies whether to collect the aliyun tags attached to each cloud service. Default value: false.
        self.enable_tag = enable_tag
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cms_args is not None:
            result['CmsArgs'] = self.cms_args
        if self.direct_args is not None:
            result['DirectArgs'] = self.direct_args
        if self.enable_tag is not None:
            result['EnableTag'] = self.enable_tag
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CmsArgs') is not None:
            self.cms_args = m.get('CmsArgs')
        if m.get('DirectArgs') is not None:
            self.direct_args = m.get('DirectArgs')
        if m.get('EnableTag') is not None:
            self.enable_tag = m.get('EnableTag')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class InstallCmsExporterResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        self.data = data
        # The ID of the request. You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallCmsExporterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallCmsExporterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallCmsExporterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config: str = None,
        environment_id: str = None,
        feature_name: str = None,
        feature_version: str = None,
        region: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The metadata of the feature.
        self.config = config
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The name of the feature.
        # 
        # Valid values:
        # 
        # *   app-agent-pilot
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   metric-agent
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # This parameter is required.
        self.feature_name = feature_name
        # The version of the feature.
        # 
        # This parameter is required.
        self.feature_version = feature_version
        # The region ID of the feature.
        self.region = region
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config is not None:
            result['Config'] = self.config
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.feature_name is not None:
            result['FeatureName'] = self.feature_name
        if self.feature_version is not None:
            result['FeatureVersion'] = self.feature_version
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('FeatureName') is not None:
            self.feature_name = m.get('FeatureName')
        if m.get('FeatureVersion') is not None:
            self.feature_version = m.get('FeatureVersion')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class InstallEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The release ID.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallManagedPrometheusRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        grafana_instance_id: str = None,
        kube_config: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        security_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The ID of the ASK cluster.
        self.cluster_id = cluster_id
        # The name of the cluster. This parameter is required if the ClusterType parameter is set to ecs.
        self.cluster_name = cluster_name
        # The cluster type.
        # 
        # Valid values:
        # 
        # *   ecs: ECS
        # *   one: ACK One
        # *   ask: ASK
        # *   pro: Container Monitoring Pro
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The ID of the managed Grafana workspace that is associated with the cluster. If you set this parameter to free or leave this parameter empty, the cluster is associated with a shared Grafana workspace.
        self.grafana_instance_id = grafana_instance_id
        # This parameter is not supported.
        self.kube_config = kube_config
        # The region ID.
        self.region_id = region_id
        self.resource_group_id = resource_group_id
        # The ID of the security group to which the cluster belongs.
        # 
        # This parameter is required.
        self.security_group_id = security_group_id
        # The ID of the vSwitch that is used by the cluster.
        # 
        # This parameter is required.
        self.v_switch_id = v_switch_id
        # The virtual private cloud (VPC) where the cluster resides.
        # 
        # This parameter is required.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.grafana_instance_id is not None:
            result['GrafanaInstanceId'] = self.grafana_instance_id
        if self.kube_config is not None:
            result['KubeConfig'] = self.kube_config
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('GrafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('GrafanaInstanceId')
        if m.get('KubeConfig') is not None:
            self.kube_config = m.get('KubeConfig')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class InstallManagedPrometheusResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # The response content. In most cases, the installation status of the Prometheus agent is returned.
        self.data = data
        # The error message returned if the Prometheus agent failed to be installed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the Prometheus agent was installed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallManagedPrometheusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InstallManagedPrometheusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallManagedPrometheusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListActivatedAlertsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        filter: str = None,
        page_size: int = None,
        region_id: str = None,
    ):
        # The number of the page to return. Default value: `1`.
        # 
        # This parameter is required.
        self.current_page = current_page
        # The filter condition in the `{"key":"value"}`format. You must specify the `key` and `value` of the filter condition.
        self.filter = filter
        # The number of entries to return on each page. Default value: `10`.
        # 
        # This parameter is required.
        self.page_size = page_size
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListActivatedAlertsResponseBodyPageAlertsDispatchRules(TeaModel):
    def __init__(
        self,
        rule_id: int = None,
        rule_name: str = None,
    ):
        # The ID of the notification policy.
        self.rule_id = rule_id
        # The name of the notification policy.
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class ListActivatedAlertsResponseBodyPageAlerts(TeaModel):
    def __init__(
        self,
        alert_id: str = None,
        alert_name: str = None,
        alert_type: str = None,
        count: int = None,
        create_time: int = None,
        dispatch_rules: List[ListActivatedAlertsResponseBodyPageAlertsDispatchRules] = None,
        ends_at: int = None,
        expand_fields: Dict[str, Any] = None,
        integration_name: str = None,
        integration_type: str = None,
        involved_object_kind: str = None,
        involved_object_name: str = None,
        message: str = None,
        severity: str = None,
        starts_at: int = None,
        status: str = None,
    ):
        # The ID of the alert rule.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The type of the alert.
        self.alert_type = alert_type
        # The number of times that the alert event was received.
        self.count = count
        # The timestamp when the alert rule was created.
        self.create_time = create_time
        # The notification policies.
        self.dispatch_rules = dispatch_rules
        # The timestamp when the alert was ended.
        self.ends_at = ends_at
        # The extended fields that indicate the following tags:
        # 
        # *   The tags that are carried in the metrics of the alert rule expression.
        # *   The tags that are created based on the alert rule.
        # *   The default tags of Application Real-Time Monitoring Service (ARMS).
        self.expand_fields = expand_fields
        # The name of the object that is associated with the alert.
        self.integration_name = integration_name
        # The type of the service integration that generated the alert.
        self.integration_type = integration_type
        # The type of the object that is associated with the alert.
        self.involved_object_kind = involved_object_kind
        # The name of the service integration that generated the alert.
        self.involved_object_name = involved_object_name
        # The description of the alert.
        self.message = message
        # The level of the alert. Valid values:
        # 
        # *   `critical`
        # *   `error`
        # *   `warn`
        # *   `page`
        self.severity = severity
        # The timestamp when the alert was generated.
        self.starts_at = starts_at
        # The status of the alert. Valid values:
        # 
        # *   `Active`
        # *   `Inhibited`
        # *   `Silenced`
        # *   `Resolved`
        self.status = status

    def validate(self):
        if self.dispatch_rules:
            for k in self.dispatch_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.count is not None:
            result['Count'] = self.count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['DispatchRules'] = []
        if self.dispatch_rules is not None:
            for k in self.dispatch_rules:
                result['DispatchRules'].append(k.to_map() if k else None)
        if self.ends_at is not None:
            result['EndsAt'] = self.ends_at
        if self.expand_fields is not None:
            result['ExpandFields'] = self.expand_fields
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.involved_object_kind is not None:
            result['InvolvedObjectKind'] = self.involved_object_kind
        if self.involved_object_name is not None:
            result['InvolvedObjectName'] = self.involved_object_name
        if self.message is not None:
            result['Message'] = self.message
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.starts_at is not None:
            result['StartsAt'] = self.starts_at
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.dispatch_rules = []
        if m.get('DispatchRules') is not None:
            for k in m.get('DispatchRules'):
                temp_model = ListActivatedAlertsResponseBodyPageAlertsDispatchRules()
                self.dispatch_rules.append(temp_model.from_map(k))
        if m.get('EndsAt') is not None:
            self.ends_at = m.get('EndsAt')
        if m.get('ExpandFields') is not None:
            self.expand_fields = m.get('ExpandFields')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('InvolvedObjectKind') is not None:
            self.involved_object_kind = m.get('InvolvedObjectKind')
        if m.get('InvolvedObjectName') is not None:
            self.involved_object_name = m.get('InvolvedObjectName')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('StartsAt') is not None:
            self.starts_at = m.get('StartsAt')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListActivatedAlertsResponseBodyPage(TeaModel):
    def __init__(
        self,
        alerts: List[ListActivatedAlertsResponseBodyPageAlerts] = None,
        page: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The alerts that have been triggered.
        self.alerts = alerts
        # The page number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.alerts:
            for k in self.alerts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Alerts'] = []
        if self.alerts is not None:
            for k in self.alerts:
                result['Alerts'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alerts = []
        if m.get('Alerts') is not None:
            for k in m.get('Alerts'):
                temp_model = ListActivatedAlertsResponseBodyPageAlerts()
                self.alerts.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListActivatedAlertsResponseBody(TeaModel):
    def __init__(
        self,
        message: str = None,
        page: ListActivatedAlertsResponseBodyPage = None,
        request_id: str = None,
    ):
        self.message = message
        # The struct returned.
        self.page = page
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page:
            self.page.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.page is not None:
            result['Page'] = self.page.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Page') is not None:
            temp_model = ListActivatedAlertsResponseBodyPage()
            self.page = temp_model.from_map(m['Page'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListActivatedAlertsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListActivatedAlertsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListActivatedAlertsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAddonReleasesRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The name of the add-on.
        self.addon_name = addon_name
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListAddonReleasesResponseBodyDataReleasesConditions(TeaModel):
    def __init__(
        self,
        first_transition_time: str = None,
        last_transition_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        # The first transition time.
        self.first_transition_time = first_transition_time
        # The last transition time.
        self.last_transition_time = last_transition_time
        # The detailed information.
        self.message = message
        # The reason for the failure.
        self.reason = reason
        # The status of the phase.
        self.status = status
        # The type of the phase.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_transition_time is not None:
            result['FirstTransitionTime'] = self.first_transition_time
        if self.last_transition_time is not None:
            result['LastTransitionTime'] = self.last_transition_time
        if self.message is not None:
            result['Message'] = self.message
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirstTransitionTime') is not None:
            self.first_transition_time = m.get('FirstTransitionTime')
        if m.get('LastTransitionTime') is not None:
            self.last_transition_time = m.get('LastTransitionTime')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAddonReleasesResponseBodyDataReleases(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        alert_rule_count: int = None,
        conditions: List[ListAddonReleasesResponseBodyDataReleasesConditions] = None,
        create_time: str = None,
        dashboard_count: int = None,
        environment_id: str = None,
        exporter_count: int = None,
        have_config: bool = None,
        install_user_id: str = None,
        language: str = None,
        managed: bool = None,
        region_id: str = None,
        release_id: str = None,
        release_name: str = None,
        scene: str = None,
        status: str = None,
        update_time: str = None,
        user_id: str = None,
        version: str = None,
    ):
        # The name of the add-on.
        self.addon_name = addon_name
        # The number of alert rules.
        self.alert_rule_count = alert_rule_count
        # The installation phase.
        self.conditions = conditions
        # The time when the add-on was created.
        self.create_time = create_time
        # The number of dashboards.
        self.dashboard_count = dashboard_count
        # The environment ID.
        self.environment_id = environment_id
        # The number of exporters.
        self.exporter_count = exporter_count
        # Indicates whether the configuration is available.
        self.have_config = have_config
        # The user ID.
        self.install_user_id = install_user_id
        # The language.
        self.language = language
        self.managed = managed
        # The region ID.
        self.region_id = region_id
        # The release ID after installation.
        self.release_id = release_id
        # The name of the release.
        self.release_name = release_name
        # The scenario.
        self.scene = scene
        # The status.
        self.status = status
        # The time when the add-on was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id
        # The version of the add-on.
        self.version = version

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.alert_rule_count is not None:
            result['AlertRuleCount'] = self.alert_rule_count
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dashboard_count is not None:
            result['DashboardCount'] = self.dashboard_count
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.exporter_count is not None:
            result['ExporterCount'] = self.exporter_count
        if self.have_config is not None:
            result['HaveConfig'] = self.have_config
        if self.install_user_id is not None:
            result['InstallUserId'] = self.install_user_id
        if self.language is not None:
            result['Language'] = self.language
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_id is not None:
            result['ReleaseId'] = self.release_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AlertRuleCount') is not None:
            self.alert_rule_count = m.get('AlertRuleCount')
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = ListAddonReleasesResponseBodyDataReleasesConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DashboardCount') is not None:
            self.dashboard_count = m.get('DashboardCount')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('ExporterCount') is not None:
            self.exporter_count = m.get('ExporterCount')
        if m.get('HaveConfig') is not None:
            self.have_config = m.get('HaveConfig')
        if m.get('InstallUserId') is not None:
            self.install_user_id = m.get('InstallUserId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseId') is not None:
            self.release_id = m.get('ReleaseId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListAddonReleasesResponseBodyData(TeaModel):
    def __init__(
        self,
        releases: List[ListAddonReleasesResponseBodyDataReleases] = None,
        total: int = None,
    ):
        # The queried add-ons.
        self.releases = releases
        # The total number of entries.
        self.total = total

    def validate(self):
        if self.releases:
            for k in self.releases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Releases'] = []
        if self.releases is not None:
            for k in self.releases:
                result['Releases'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.releases = []
        if m.get('Releases') is not None:
            for k in m.get('Releases'):
                temp_model = ListAddonReleasesResponseBodyDataReleases()
                self.releases.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListAddonReleasesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListAddonReleasesResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAddonReleasesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAddonReleasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAddonReleasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAddonReleasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAddonsRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        category: str = None,
        regexp: bool = None,
        region_id: str = None,
        search: str = None,
    ):
        # Language,the default language is Chinese.
        self.aliyun_lang = aliyun_lang
        # Category filter.
        self.category = category
        # Whether to enable regular matching.
        self.regexp = regexp
        # The region ID.
        self.region_id = region_id
        # A query field can be queried by name or description.
        self.search = search

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.category is not None:
            result['Category'] = self.category
        if self.regexp is not None:
            result['Regexp'] = self.regexp
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search is not None:
            result['Search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Regexp') is not None:
            self.regexp = m.get('Regexp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Search') is not None:
            self.search = m.get('Search')
        return self


class ListAddonsResponseBodyDataDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        # The description of the dashboard.
        self.description = description
        # The name of the dashboard.
        self.name = name
        # The URL of the dashboard.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListAddonsResponseBodyDataEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        # The supported cluster types.
        self.cluster_types = cluster_types
        # The feature on which the environment depends.
        self.features = features
        # The services.
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['ClusterTypes'] = self.cluster_types
        if self.features is not None:
            result['Features'] = self.features
        if self.services is not None:
            result['Services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterTypes') is not None:
            self.cluster_types = m.get('ClusterTypes')
        if m.get('Features') is not None:
            self.features = m.get('Features')
        if m.get('Services') is not None:
            self.services = m.get('Services')
        return self


class ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        # The PromQL statements.
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        return self


class ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        # The description of the protocol.
        self.description = description
        # The URL of the protocol icon.
        self.icon = icon
        # The tag of the protocol.
        self.label = label
        # The name of the protocol.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.label is not None:
            result['Label'] = self.label
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListAddonsResponseBodyDataEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        # The default alert status.
        self.alert_default_status = alert_default_status
        # The default installation status.
        self.default_install = default_install
        # Indicates whether a service account is enabled.
        self.enable_service_account = enable_service_account
        # The metric check rule.
        self.metric_check_rule = metric_check_rule
        # Indicates whether a restart is required after the installation.
        self.need_restart_after_integration = need_restart_after_integration
        # The supported protocols.
        self.protocols = protocols
        # The target name of the add-on.
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['AlertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['DefaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['EnableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['MetricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['NeedRestartAfterIntegration'] = self.need_restart_after_integration
        result['Protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['Protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['TargetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertDefaultStatus') is not None:
            self.alert_default_status = m.get('AlertDefaultStatus')
        if m.get('DefaultInstall') is not None:
            self.default_install = m.get('DefaultInstall')
        if m.get('EnableServiceAccount') is not None:
            self.enable_service_account = m.get('EnableServiceAccount')
        if m.get('MetricCheckRule') is not None:
            temp_model = ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['MetricCheckRule'])
        if m.get('NeedRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('NeedRestartAfterIntegration')
        self.protocols = []
        if m.get('Protocols') is not None:
            for k in m.get('Protocols'):
                temp_model = ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('TargetAddonName') is not None:
            self.target_addon_name = m.get('TargetAddonName')
        return self


class ListAddonsResponseBodyDataEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: ListAddonsResponseBodyDataEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: ListAddonsResponseBodyDataEnvironmentsPolicies = None,
    ):
        # The dependencies of the environment.
        self.dependencies = dependencies
        # The description of the environment.
        self.description = description
        # Indicates whether the feature is enabled.
        self.enable = enable
        # The tag of the environment.
        self.label = label
        # The name of the environment.
        self.name = name
        # The control policies in the environment.
        self.policies = policies

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['Dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.label is not None:
            result['Label'] = self.label
        if self.name is not None:
            result['Name'] = self.name
        if self.policies is not None:
            result['Policies'] = self.policies.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dependencies') is not None:
            temp_model = ListAddonsResponseBodyDataEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['Dependencies'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policies') is not None:
            temp_model = ListAddonsResponseBodyDataEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['Policies'])
        return self


class ListAddonsResponseBodyData(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[ListAddonsResponseBodyDataDashboards] = None,
        description: str = None,
        environments: List[ListAddonsResponseBodyDataEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: str = None,
    ):
        # The alias of the add-on.
        self.alias = alias
        # The tags of the add-on.
        self.categories = categories
        # The dashboards.
        self.dashboards = dashboards
        # The description of the add-on.
        self.description = description
        # The supported environments.
        self.environments = environments
        # The URL of the icon.
        self.icon = icon
        # The collection of keywords.
        self.keywords = keywords
        # The language.
        self.language = language
        # The time when the instance was last created.
        self.latest_release_create_time = latest_release_create_time
        # The name of the add-on.
        self.name = name
        # Indicates whether the add-on can be installed only once.
        self.once = once
        # The scenario.
        self.scene = scene
        # The version of the agent.
        self.version = version
        # The weight.
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.categories is not None:
            result['Categories'] = self.categories
        result['Dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['Dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        result['Environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['Environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_release_create_time is not None:
            result['LatestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.once is not None:
            result['Once'] = self.once
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.version is not None:
            result['Version'] = self.version
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        self.dashboards = []
        if m.get('Dashboards') is not None:
            for k in m.get('Dashboards'):
                temp_model = ListAddonsResponseBodyDataDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.environments = []
        if m.get('Environments') is not None:
            for k in m.get('Environments'):
                temp_model = ListAddonsResponseBodyDataEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('LatestReleaseCreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Once') is not None:
            self.once = m.get('Once')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class ListAddonsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListAddonsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status code: 200 indicates success.
        self.code = code
        # The queried add-ons.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the alert rule was deleted. Valid values:
        # 
        # *   `true`: The alert rule was deleted.
        # *   `false`: The alert rule failed to be deleted.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListAddonsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAddonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAddonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAddonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertEventsRequest(TeaModel):
    def __init__(
        self,
        alert_name: str = None,
        end_time: str = None,
        matching_conditions: str = None,
        page: int = None,
        show_notification_policies: bool = None,
        size: int = None,
        start_time: str = None,
        status: str = None,
    ):
        # The name of the alert.
        self.alert_name = alert_name
        # The end time of the alert events that you want to query. Specify the time in the YYYY-MM-DD HH:mm:ss format.
        self.end_time = end_time
        # The list of matching conditions.
        self.matching_conditions = matching_conditions
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # Specifies whether to show the associated notification policy.
        self.show_notification_policies = show_notification_policies
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.size = size
        # The start time of the alert events that you want to query. Specify the time in the YYYY-MM-DD HH:mm:ss format.
        self.start_time = start_time
        # The status of the alert events. Valid values:
        # 
        # *   Active
        # *   Silenced
        # *   Resolved
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.matching_conditions is not None:
            result['MatchingConditions'] = self.matching_conditions
        if self.page is not None:
            result['Page'] = self.page
        if self.show_notification_policies is not None:
            result['ShowNotificationPolicies'] = self.show_notification_policies
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MatchingConditions') is not None:
            self.matching_conditions = m.get('MatchingConditions')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('ShowNotificationPolicies') is not None:
            self.show_notification_policies = m.get('ShowNotificationPolicies')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListAlertEventsResponseBodyPageBeanEventsAlarms(TeaModel):
    def __init__(
        self,
        alarm_id: int = None,
        alarm_name: str = None,
        create_time: str = None,
        state: int = None,
    ):
        # The ID of the alert.
        self.alarm_id = alarm_id
        # The name of the alert.
        self.alarm_name = alarm_name
        # The time when the alert was created.
        self.create_time = create_time
        # The status of the alert. Valid values:
        # 
        # *   0: The alert is pending.
        # *   1: The alert is being handled.
        # *   2: The alert is cleared.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_id is not None:
            result['AlarmId'] = self.alarm_id
        if self.alarm_name is not None:
            result['AlarmName'] = self.alarm_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmId') is not None:
            self.alarm_id = m.get('AlarmId')
        if m.get('AlarmName') is not None:
            self.alarm_name = m.get('AlarmName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the notification policy.
        self.id = id
        # The name of the notification policy.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListAlertEventsResponseBodyPageBeanEvents(TeaModel):
    def __init__(
        self,
        alarms: List[ListAlertEventsResponseBodyPageBeanEventsAlarms] = None,
        alert_name: str = None,
        annotations: str = None,
        description: str = None,
        end_time: str = None,
        generator_url: str = None,
        handler_name: str = None,
        integration_name: str = None,
        integration_type: str = None,
        labels: str = None,
        notification_policies: List[ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies] = None,
        receive_time: str = None,
        severity: str = None,
        start_time: str = None,
        status: str = None,
        trigger_count: int = None,
    ):
        # The associated alerts.
        self.alarms = alarms
        # The name of the alert.
        self.alert_name = alert_name
        # The annotations.
        self.annotations = annotations
        # The description of the alert event.
        self.description = description
        # The end time.
        self.end_time = end_time
        # The URL of the alert event.
        self.generator_url = generator_url
        # The user who handled the alert.
        self.handler_name = handler_name
        # The name of the alert integration.
        self.integration_name = integration_name
        # The type of the alert integration.
        self.integration_type = integration_type
        # The tags.
        self.labels = labels
        # The associated notification policies.
        self.notification_policies = notification_policies
        # The time when the alert event was received.
        self.receive_time = receive_time
        # The severity level of the alert. Valid values:
        # 
        # *   critical: P1
        # *   error: P2
        # *   warning: P3
        # *   page: P4
        # *   default: P6
        self.severity = severity
        # The start time.
        self.start_time = start_time
        # The status of the alert event. Valid values:
        # 
        # *   Active
        # *   Silenced
        # *   Resolved
        self.status = status
        # The number of times the event is triggered.
        self.trigger_count = trigger_count

    def validate(self):
        if self.alarms:
            for k in self.alarms:
                if k:
                    k.validate()
        if self.notification_policies:
            for k in self.notification_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Alarms'] = []
        if self.alarms is not None:
            for k in self.alarms:
                result['Alarms'].append(k.to_map() if k else None)
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.generator_url is not None:
            result['GeneratorURL'] = self.generator_url
        if self.handler_name is not None:
            result['HandlerName'] = self.handler_name
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.labels is not None:
            result['Labels'] = self.labels
        result['NotificationPolicies'] = []
        if self.notification_policies is not None:
            for k in self.notification_policies:
                result['NotificationPolicies'].append(k.to_map() if k else None)
        if self.receive_time is not None:
            result['ReceiveTime'] = self.receive_time
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.trigger_count is not None:
            result['TriggerCount'] = self.trigger_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alarms = []
        if m.get('Alarms') is not None:
            for k in m.get('Alarms'):
                temp_model = ListAlertEventsResponseBodyPageBeanEventsAlarms()
                self.alarms.append(temp_model.from_map(k))
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GeneratorURL') is not None:
            self.generator_url = m.get('GeneratorURL')
        if m.get('HandlerName') is not None:
            self.handler_name = m.get('HandlerName')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        self.notification_policies = []
        if m.get('NotificationPolicies') is not None:
            for k in m.get('NotificationPolicies'):
                temp_model = ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies()
                self.notification_policies.append(temp_model.from_map(k))
        if m.get('ReceiveTime') is not None:
            self.receive_time = m.get('ReceiveTime')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TriggerCount') is not None:
            self.trigger_count = m.get('TriggerCount')
        return self


class ListAlertEventsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        events: List[ListAlertEventsResponseBodyPageBeanEvents] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The queried historical alert events.
        self.events = events
        # The number of the page returned.
        self.page = page
        # The number of entries returned per page.
        self.size = size
        # The total number of returned entries.
        self.total = total

    def validate(self):
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Events'] = []
        if self.events is not None:
            for k in self.events:
                result['Events'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.events = []
        if m.get('Events') is not None:
            for k in m.get('Events'):
                temp_model = ListAlertEventsResponseBodyPageBeanEvents()
                self.events.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListAlertEventsResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: ListAlertEventsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = ListAlertEventsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAlertEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAlertsRequest(TeaModel):
    def __init__(
        self,
        alert_name: str = None,
        dispatch_rule_id: int = None,
        end_time: str = None,
        integration_type: str = None,
        owner: str = None,
        page: int = None,
        region_id: str = None,
        severity: str = None,
        show_activities: bool = None,
        show_events: bool = None,
        size: int = None,
        start_time: str = None,
        state: int = None,
    ):
        # The name of the alert rule.
        self.alert_name = alert_name
        # The ID of the notification policy.
        self.dispatch_rule_id = dispatch_rule_id
        # The end time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.
        self.end_time = end_time
        # The integration type.
        # 
        # *   ARMS
        # *   CLOUD_MONITOR
        # *   MSE
        # *   ARMS_CLOUD_DIALTEST
        # *   PROMETHEUS
        # *   LOG_SERVICE
        # *   CUSTOM
        # *   ARMS_PROMETHEUS
        # *   ARMS_APP_MON
        # *   ARMS_FRONT_MON
        # *   ARMS_CUSTOM
        # *   XTRACE
        # *   GRAFANA
        # *   ZABBIX
        # *   SKYWALKING
        # *   EVENT_BRIDGE
        # *   NAGIOS
        # *   OPENFALCON
        # *   ARMS_INSIGHTS
        self.integration_type = integration_type
        self.owner = owner
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The ID of the region.
        self.region_id = region_id
        # The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.
        self.severity = severity
        # Specifies whether to query the activities that correspond to alerts. Valid values:
        # 
        # *   `false` (default value): The activities are not queried.
        # *   `true`: The activities in the last three days are queried.
        self.show_activities = show_activities
        # Specifies whether to query the events that correspond to alerts. Valid values:
        # 
        # *   `false` (default value): The events are not queried.
        # *   `true`: The events are queried.
        self.show_events = show_events
        # The number of alerts to return on each page.
        # 
        # This parameter is required.
        self.size = size
        # The start time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.
        self.start_time = start_time
        # The status of the alert. Valid values:
        # 
        # *   0: The alert is pending.
        # *   1: The alert is being handled.
        # *   2: The alert is handled.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.page is not None:
            result['Page'] = self.page
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.show_activities is not None:
            result['ShowActivities'] = self.show_activities
        if self.show_events is not None:
            result['ShowEvents'] = self.show_events
        if self.size is not None:
            result['Size'] = self.size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('ShowActivities') is not None:
            self.show_activities = m.get('ShowActivities')
        if m.get('ShowEvents') is not None:
            self.show_events = m.get('ShowEvents')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListAlertsResponseBodyPageBeanListAlertsActivities(TeaModel):
    def __init__(
        self,
        content: str = None,
        description: str = None,
        handler_name: str = None,
        time: str = None,
        type: int = None,
    ):
        # The content of the alert notification.
        self.content = content
        # The description of the activity.
        self.description = description
        # The name of the handler.
        self.handler_name = handler_name
        # The operation time of the activity.
        self.time = time
        # The type of the activity. Valid values:
        # 
        # *   1: The alert is claimed.
        # *   2: The alert is disclaimed.
        # *   3: A comment is added for the alert.
        # *   4: The alert is disabled.
        # *   5: An alert notification is sent.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.handler_name is not None:
            result['HandlerName'] = self.handler_name
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HandlerName') is not None:
            self.handler_name = m.get('HandlerName')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListAlertsResponseBodyPageBeanListAlertsAlertEvents(TeaModel):
    def __init__(
        self,
        alert_name: str = None,
        annotations: str = None,
        description: str = None,
        end_time: str = None,
        generator_url: str = None,
        integration_name: str = None,
        integration_type: str = None,
        labels: str = None,
        receive_time: str = None,
        severity: str = None,
        start_time: str = None,
        state: str = None,
    ):
        # The name of the event.
        self.alert_name = alert_name
        # The annotations.
        self.annotations = annotations
        # The description of the event.
        self.description = description
        # The time when the event ended.
        self.end_time = end_time
        # The URL of the event.
        self.generator_url = generator_url
        # The name of the integration that corresponds to the alert event.
        self.integration_name = integration_name
        # The type of the integration that corresponds to the alert event. Valid values:
        # 
        # *   ARMS
        # *   CLOUD_MONITOR
        # *   MSE
        # *   ARMS_CLOUD_DIALTEST
        # *   PROMETHEUS
        # *   LOG_SERVICE
        # *   CUSTOM
        # *   ARMS_PROMETHEUS
        # *   ARMS_APP_MON
        # *   ARMS_FRONT_MON
        # *   ARMS_CUSTOM
        # *   XTRACE
        # *   GRAFANA
        # *   ZABBIX
        # *   SKYWALKING
        # *   EVENT_BRIDGE
        # *   NAGIOS
        # *   OPENFALCON
        # *   ARMS_INSIGHTS
        self.integration_type = integration_type
        # The tags.
        self.labels = labels
        # The time when the event was created.
        self.receive_time = receive_time
        # The severity level of the event. Valid values:
        # 
        # *   critical
        # *   error
        # *   warning
        # *   info
        self.severity = severity
        # The time when the event started.
        self.start_time = start_time
        # The status of the event. Valid values:
        # 
        # *   Active: The event is not cleared.
        # *   Silenced: The event is silenced.
        # *   Resolved: The event is cleared.
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.generator_url is not None:
            result['GeneratorURL'] = self.generator_url
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.receive_time is not None:
            result['ReceiveTime'] = self.receive_time
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GeneratorURL') is not None:
            self.generator_url = m.get('GeneratorURL')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('ReceiveTime') is not None:
            self.receive_time = m.get('ReceiveTime')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListAlertsResponseBodyPageBeanListAlerts(TeaModel):
    def __init__(
        self,
        acknowledge_time: int = None,
        activities: List[ListAlertsResponseBodyPageBeanListAlertsActivities] = None,
        alert_events: List[ListAlertsResponseBodyPageBeanListAlertsAlertEvents] = None,
        alert_id: int = None,
        alert_name: str = None,
        create_time: str = None,
        describe: str = None,
        dispatch_rule_id: float = None,
        dispatch_rule_name: str = None,
        handler: str = None,
        notify_robots: str = None,
        owner: str = None,
        recover_time: int = None,
        severity: str = None,
        solution: str = None,
        state: int = None,
    ):
        self.acknowledge_time = acknowledge_time
        # The list of activities.
        self.activities = activities
        # The list of events.
        self.alert_events = alert_events
        # The alert ID.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The time when the alert was created.
        self.create_time = create_time
        self.describe = describe
        # The ID of the notification policy.
        self.dispatch_rule_id = dispatch_rule_id
        # The name of the notification policy.
        self.dispatch_rule_name = dispatch_rule_name
        self.handler = handler
        self.notify_robots = notify_robots
        self.owner = owner
        self.recover_time = recover_time
        # The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.
        self.severity = severity
        # The Alert solution.
        self.solution = solution
        # The status of the alert. Valid values:
        # 
        # *   0: The alert is pending.
        # *   1: The alert is being handled.
        # *   2: The alert is handled.
        self.state = state

    def validate(self):
        if self.activities:
            for k in self.activities:
                if k:
                    k.validate()
        if self.alert_events:
            for k in self.alert_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acknowledge_time is not None:
            result['AcknowledgeTime'] = self.acknowledge_time
        result['Activities'] = []
        if self.activities is not None:
            for k in self.activities:
                result['Activities'].append(k.to_map() if k else None)
        result['AlertEvents'] = []
        if self.alert_events is not None:
            for k in self.alert_events:
                result['AlertEvents'].append(k.to_map() if k else None)
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.dispatch_rule_name is not None:
            result['DispatchRuleName'] = self.dispatch_rule_name
        if self.handler is not None:
            result['Handler'] = self.handler
        if self.notify_robots is not None:
            result['NotifyRobots'] = self.notify_robots
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.recover_time is not None:
            result['RecoverTime'] = self.recover_time
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.solution is not None:
            result['Solution'] = self.solution
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AcknowledgeTime') is not None:
            self.acknowledge_time = m.get('AcknowledgeTime')
        self.activities = []
        if m.get('Activities') is not None:
            for k in m.get('Activities'):
                temp_model = ListAlertsResponseBodyPageBeanListAlertsActivities()
                self.activities.append(temp_model.from_map(k))
        self.alert_events = []
        if m.get('AlertEvents') is not None:
            for k in m.get('AlertEvents'):
                temp_model = ListAlertsResponseBodyPageBeanListAlertsAlertEvents()
                self.alert_events.append(temp_model.from_map(k))
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('DispatchRuleName') is not None:
            self.dispatch_rule_name = m.get('DispatchRuleName')
        if m.get('Handler') is not None:
            self.handler = m.get('Handler')
        if m.get('NotifyRobots') is not None:
            self.notify_robots = m.get('NotifyRobots')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('RecoverTime') is not None:
            self.recover_time = m.get('RecoverTime')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Solution') is not None:
            self.solution = m.get('Solution')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListAlertsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        list_alerts: List[ListAlertsResponseBodyPageBeanListAlerts] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The alerts for which the alert sending history is queried.
        self.list_alerts = list_alerts
        # The page number of the returned page.
        self.page = page
        # The number of alerts returned per page.
        self.size = size
        # The total number of queried alerts.
        self.total = total

    def validate(self):
        if self.list_alerts:
            for k in self.list_alerts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ListAlerts'] = []
        if self.list_alerts is not None:
            for k in self.list_alerts:
                result['ListAlerts'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list_alerts = []
        if m.get('ListAlerts') is not None:
            for k in m.get('ListAlerts'):
                temp_model = ListAlertsResponseBodyPageBeanListAlerts()
                self.list_alerts.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListAlertsResponseBody(TeaModel):
    def __init__(
        self,
        message: str = None,
        page_bean: ListAlertsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        self.message = message
        # The information about the array object.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageBean') is not None:
            temp_model = ListAlertsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAlertsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAlertsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAlertsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListClusterFromGrafanaRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListClusterFromGrafanaResponseBodyPromClusterList(TeaModel):
    def __init__(
        self,
        agent_status: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        controller_id: str = None,
        create_time: int = None,
        extra: str = None,
        id: int = None,
        install_time: int = None,
        is_controller_installed: bool = None,
        last_heart_beat_time: int = None,
        node_num: int = None,
        options: str = None,
        plugins_json_array: str = None,
        region_id: str = None,
        state_json: str = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The status of the Prometheus agent on the cluster. Valid values:
        # 
        # *   INSTALL_FAILED: The Prometheus agent failed to be installed.
        # *   INSTALL_SUCCEED: The Prometheus agent was installed.
        # *   NOT_REGISTER: You have not registered an Alibaba Cloud account.
        self.agent_status = agent_status
        # The cluster ID.
        self.cluster_id = cluster_id
        # The name of the cluster.
        self.cluster_name = cluster_name
        # The type of the cluster.
        self.cluster_type = cluster_type
        # The controller ID.
        self.controller_id = controller_id
        # The time when the dashboard was created.
        self.create_time = create_time
        # The extended fields. This parameter is a JSON string.
        self.extra = extra
        # The ID of a database in the cluster.
        self.id = id
        # The timestamp when the Prometheus agent was installed.
        self.install_time = install_time
        # Indicates whether the Prometheus agent was installed. Valid values:
        # 
        # *   true: The Prometheus agent was installed.
        # *   false: The Prometheus agent was not installed.
        self.is_controller_installed = is_controller_installed
        # The time when the last heartbeat was reported.
        self.last_heart_beat_time = last_heart_beat_time
        # The number of nodes.
        self.node_num = node_num
        # The custom parameter.
        self.options = options
        # The list of nodejsonar logs.
        self.plugins_json_array = plugins_json_array
        # The region ID.
        self.region_id = region_id
        # The information about applications deployed in the cluster.
        self.state_json = state_json
        # The time when the dashboard was updated.
        self.update_time = update_time
        # The ID of the Alibaba Cloud account to which the cluster belongs.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_status is not None:
            result['AgentStatus'] = self.agent_status
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.controller_id is not None:
            result['ControllerId'] = self.controller_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.extra is not None:
            result['Extra'] = self.extra
        if self.id is not None:
            result['Id'] = self.id
        if self.install_time is not None:
            result['InstallTime'] = self.install_time
        if self.is_controller_installed is not None:
            result['IsControllerInstalled'] = self.is_controller_installed
        if self.last_heart_beat_time is not None:
            result['LastHeartBeatTime'] = self.last_heart_beat_time
        if self.node_num is not None:
            result['NodeNum'] = self.node_num
        if self.options is not None:
            result['Options'] = self.options
        if self.plugins_json_array is not None:
            result['PluginsJsonArray'] = self.plugins_json_array
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.state_json is not None:
            result['StateJson'] = self.state_json
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentStatus') is not None:
            self.agent_status = m.get('AgentStatus')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('ControllerId') is not None:
            self.controller_id = m.get('ControllerId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Extra') is not None:
            self.extra = m.get('Extra')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstallTime') is not None:
            self.install_time = m.get('InstallTime')
        if m.get('IsControllerInstalled') is not None:
            self.is_controller_installed = m.get('IsControllerInstalled')
        if m.get('LastHeartBeatTime') is not None:
            self.last_heart_beat_time = m.get('LastHeartBeatTime')
        if m.get('NodeNum') is not None:
            self.node_num = m.get('NodeNum')
        if m.get('Options') is not None:
            self.options = m.get('Options')
        if m.get('PluginsJsonArray') is not None:
            self.plugins_json_array = m.get('PluginsJsonArray')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StateJson') is not None:
            self.state_json = m.get('StateJson')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListClusterFromGrafanaResponseBody(TeaModel):
    def __init__(
        self,
        prom_cluster_list: List[ListClusterFromGrafanaResponseBodyPromClusterList] = None,
        request_id: str = None,
    ):
        # The cluster information.
        self.prom_cluster_list = prom_cluster_list
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.prom_cluster_list:
            for k in self.prom_cluster_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PromClusterList'] = []
        if self.prom_cluster_list is not None:
            for k in self.prom_cluster_list:
                result['PromClusterList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.prom_cluster_list = []
        if m.get('PromClusterList') is not None:
            for k in m.get('PromClusterList'):
                temp_model = ListClusterFromGrafanaResponseBodyPromClusterList()
                self.prom_cluster_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListClusterFromGrafanaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListClusterFromGrafanaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListClusterFromGrafanaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCmsInstancesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        type_filter: str = None,
    ):
        # This parameter is required.
        self.cluster_id = cluster_id
        # This parameter is required.
        self.region_id = region_id
        self.type_filter = type_filter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type_filter is not None:
            result['TypeFilter'] = self.type_filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TypeFilter') is not None:
            self.type_filter = m.get('TypeFilter')
        return self


class ListCmsInstancesResponseBodyDataProducts(TeaModel):
    def __init__(
        self,
        descr: str = None,
        id: str = None,
        instance: str = None,
        name: str = None,
        prod: str = None,
        source: str = None,
        state: str = None,
        time: str = None,
        type: str = None,
        url: str = None,
    ):
        self.descr = descr
        self.id = id
        self.instance = instance
        self.name = name
        self.prod = prod
        self.source = source
        self.state = state
        self.time = time
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.descr is not None:
            result['Descr'] = self.descr
        if self.id is not None:
            result['Id'] = self.id
        if self.instance is not None:
            result['Instance'] = self.instance
        if self.name is not None:
            result['Name'] = self.name
        if self.prod is not None:
            result['Prod'] = self.prod
        if self.source is not None:
            result['Source'] = self.source
        if self.state is not None:
            result['State'] = self.state
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Descr') is not None:
            self.descr = m.get('Descr')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Prod') is not None:
            self.prod = m.get('Prod')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListCmsInstancesResponseBodyData(TeaModel):
    def __init__(
        self,
        enable_tag: bool = None,
        products: List[ListCmsInstancesResponseBodyDataProducts] = None,
    ):
        self.enable_tag = enable_tag
        self.products = products

    def validate(self):
        if self.products:
            for k in self.products:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_tag is not None:
            result['EnableTag'] = self.enable_tag
        result['Products'] = []
        if self.products is not None:
            for k in self.products:
                result['Products'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableTag') is not None:
            self.enable_tag = m.get('EnableTag')
        self.products = []
        if m.get('Products') is not None:
            for k in m.get('Products'):
                temp_model = ListCmsInstancesResponseBodyDataProducts()
                self.products.append(temp_model.from_map(k))
        return self


class ListCmsInstancesResponseBody(TeaModel):
    def __init__(
        self,
        data: ListCmsInstancesResponseBodyData = None,
        request_id: str = None,
    ):
        self.data = data
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = ListCmsInstancesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListCmsInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCmsInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCmsInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDashboardsRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        dashboard_name: str = None,
        language: str = None,
        product: str = None,
        recreate_switch: bool = None,
        region_id: str = None,
        title: str = None,
    ):
        # The ID of the ACK cluster.
        self.cluster_id = cluster_id
        # Valid values: ACK, ASK, cloud-product-prometheus, and Node. You can query the dashboards of a virtual cluster by specifying the cluster type. For InfluxDB, set this parameter to `cloud-product-prometheus`.
        self.cluster_type = cluster_type
        # The unique names of the dashboards. You can query dashboards by specifying their names. The **dashboard title** can be changed whereas the **dashboard name** cannot. You can specify multiple names and separate them with commas (,), for example, `k8s-event,k8s-overview`. A dashboard may have multiple versions. If you want to specify a version, you can add version information after the name, for example, `k8s-event:v1,k8s-overview:latest`.
        self.dashboard_name = dashboard_name
        # The language of the returned Grafana dashboard. Valid values: en and zh. Default value: en.
        self.language = language
        # The cloud service code. This parameter is required if you set the ClusterType parameter to `cloud-product-prometheus`. The following cloud services are available: Serverless App Engine, Microservices Engine, Message Queue for Apache RocketMQ, Lindorm, Message Queue for Apache Kafka, ApsaraDB for ClickHouse, Data Lake Analytics, Message Queue for RabbitMQ, ApsaraDB for MongoDB, Time Series Database (TSDB) for InfluxDB, MSE Cloud-native Gateway, Grafana Service, SchedulerX, Global Transaction Service, Enterprise Distributed Application Service, Machine Learning Platform for AI - Elastic Algorithm Service (EAS), Application High Availability Service, and Performance Testing.
        self.product = product
        # Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.
        self.recreate_switch = recreate_switch
        # The region ID.
        self.region_id = region_id
        # The dashboard title. The dashboard title can be changed. We recommend that you specify the **DashboardName** parameter.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.dashboard_name is not None:
            result['DashboardName'] = self.dashboard_name
        if self.language is not None:
            result['Language'] = self.language
        if self.product is not None:
            result['Product'] = self.product
        if self.recreate_switch is not None:
            result['RecreateSwitch'] = self.recreate_switch
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DashboardName') is not None:
            self.dashboard_name = m.get('DashboardName')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RecreateSwitch') is not None:
            self.recreate_switch = m.get('RecreateSwitch')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class ListDashboardsResponseBodyDashboardVosI18nChild(TeaModel):
    def __init__(
        self,
        dashboard_type: str = None,
        exporter: str = None,
        http_url: str = None,
        https_url: str = None,
        id: str = None,
        is_arms_exporter: bool = None,
        kind: str = None,
        language: str = None,
        name: str = None,
        need_update: bool = None,
        tags: List[str] = None,
        time: str = None,
        title: str = None,
        type: str = None,
        uid: str = None,
        url: str = None,
        version: str = None,
    ):
        # The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.
        self.dashboard_type = dashboard_type
        # The type of the exporter access source. Valid values:
        # 
        # *   Prometheus
        # *   Node
        # *   GPU
        # *   Redis
        # *   MySQL
        # *   Kafka
        # *   NGINX V2
        # *   Nginx
        # *   ZooKeeper
        # *   MongoDB
        # *   RabbitMQ
        # *   PostgreSQL
        # *   Kubernetes
        # *   Client Library
        # *   Elasticsearch
        # *   RocketMQ
        self.exporter = exporter
        # The URL of the Grafana dashboard.
        self.http_url = http_url
        # The URL of the Grafana dashboard.
        self.https_url = https_url
        # The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.
        self.id = id
        # Indicates whether the exporter is provided by ARMS.
        # 
        # *   `true:` The exporter is provided by ARMS.
        # *   `false:`: The exporter is not provided by ARMS.
        self.is_arms_exporter = is_arms_exporter
        # The category of the Grafana dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM.
        self.kind = kind
        # The language of the Grafana dashboard.
        self.language = language
        # The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.
        self.name = name
        # Indicates whether the Grafana dashboard has a new version that is available for upgrade.
        self.need_update = need_update
        # The tags of the Grafana dashboard.
        self.tags = tags
        # The time when the Grafana dashboard was created. The value is a timestamp.
        self.time = time
        # The title of the Grafana dashboard.
        self.title = title
        # The type of the Grafana dashboard. Valid values:
        # 
        # *   `dash-db`: a dashboard
        # *   `dash-folder`: a folder that can include a dashboard
        self.type = type
        # The unique identifier of the Grafana dashboard.
        self.uid = uid
        # The complete URL of the Grafana dashboard.
        self.url = url
        # The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dashboard_type is not None:
            result['DashboardType'] = self.dashboard_type
        if self.exporter is not None:
            result['Exporter'] = self.exporter
        if self.http_url is not None:
            result['HttpUrl'] = self.http_url
        if self.https_url is not None:
            result['HttpsUrl'] = self.https_url
        if self.id is not None:
            result['Id'] = self.id
        if self.is_arms_exporter is not None:
            result['IsArmsExporter'] = self.is_arms_exporter
        if self.kind is not None:
            result['Kind'] = self.kind
        if self.language is not None:
            result['Language'] = self.language
        if self.name is not None:
            result['Name'] = self.name
        if self.need_update is not None:
            result['NeedUpdate'] = self.need_update
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.time is not None:
            result['Time'] = self.time
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.url is not None:
            result['Url'] = self.url
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DashboardType') is not None:
            self.dashboard_type = m.get('DashboardType')
        if m.get('Exporter') is not None:
            self.exporter = m.get('Exporter')
        if m.get('HttpUrl') is not None:
            self.http_url = m.get('HttpUrl')
        if m.get('HttpsUrl') is not None:
            self.https_url = m.get('HttpsUrl')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsArmsExporter') is not None:
            self.is_arms_exporter = m.get('IsArmsExporter')
        if m.get('Kind') is not None:
            self.kind = m.get('Kind')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NeedUpdate') is not None:
            self.need_update = m.get('NeedUpdate')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListDashboardsResponseBodyDashboardVos(TeaModel):
    def __init__(
        self,
        dashboard_type: str = None,
        exporter: str = None,
        http_url: str = None,
        https_url: str = None,
        i_18n_child: ListDashboardsResponseBodyDashboardVosI18nChild = None,
        id: str = None,
        is_arms_exporter: bool = None,
        kind: str = None,
        language: str = None,
        name: str = None,
        need_update: bool = None,
        tags: List[str] = None,
        time: str = None,
        title: str = None,
        type: str = None,
        uid: str = None,
        url: str = None,
        version: str = None,
    ):
        # The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.
        self.dashboard_type = dashboard_type
        # The type of the exporter access source. Valid values:
        # 
        # *   Prometheus
        # *   Node
        # *   GPU
        # *   Redis
        # *   MySQL
        # *   Kafka
        # *   NGINX V2
        # *   Nginx
        # *   ZooKeeper
        # *   MongoDB
        # *   RabbitMQ
        # *   PostgreSQL
        # *   Kubernetes
        # *   Client Library
        # *   Elasticsearch
        # *   RocketMQ
        self.exporter = exporter
        # The URL of the Grafana dashboard.
        self.http_url = http_url
        # The URL of the Grafana dashboard.
        self.https_url = https_url
        # The information about the Grafana dashboard.
        self.i_18n_child = i_18n_child
        # The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.
        self.id = id
        # Indicates whether the exporter is provided by Application Real-Time Monitoring Service (ARMS).
        # 
        # *   `true:` The exporter is provided by ARMS.
        # *   `false:`: The exporter is not provided by ARMS.
        self.is_arms_exporter = is_arms_exporter
        # The category of the Grafana dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM.
        self.kind = kind
        # The language of the Grafana dashboard.
        self.language = language
        # The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.
        self.name = name
        # Indicates whether the Grafana dashboard has a new version that is available for upgrade.
        self.need_update = need_update
        # The tags of the Grafana dashboard.
        self.tags = tags
        # The time when the Grafana dashboard was created. The value is a timestamp. Unit: seconds.
        self.time = time
        # The title of the Grafana dashboard.
        self.title = title
        # The type of the Grafana dashboard. Valid values:
        # 
        # *   `dash-db`: a dashboard
        # *   `dash-folder`: a folder that can include a dashboard
        self.type = type
        # The unique identifier of the Grafana dashboard.
        self.uid = uid
        # The complete URL of the Grafana dashboard.
        self.url = url
        # The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.
        self.version = version

    def validate(self):
        if self.i_18n_child:
            self.i_18n_child.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dashboard_type is not None:
            result['DashboardType'] = self.dashboard_type
        if self.exporter is not None:
            result['Exporter'] = self.exporter
        if self.http_url is not None:
            result['HttpUrl'] = self.http_url
        if self.https_url is not None:
            result['HttpsUrl'] = self.https_url
        if self.i_18n_child is not None:
            result['I18nChild'] = self.i_18n_child.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.is_arms_exporter is not None:
            result['IsArmsExporter'] = self.is_arms_exporter
        if self.kind is not None:
            result['Kind'] = self.kind
        if self.language is not None:
            result['Language'] = self.language
        if self.name is not None:
            result['Name'] = self.name
        if self.need_update is not None:
            result['NeedUpdate'] = self.need_update
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.time is not None:
            result['Time'] = self.time
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.url is not None:
            result['Url'] = self.url
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DashboardType') is not None:
            self.dashboard_type = m.get('DashboardType')
        if m.get('Exporter') is not None:
            self.exporter = m.get('Exporter')
        if m.get('HttpUrl') is not None:
            self.http_url = m.get('HttpUrl')
        if m.get('HttpsUrl') is not None:
            self.https_url = m.get('HttpsUrl')
        if m.get('I18nChild') is not None:
            temp_model = ListDashboardsResponseBodyDashboardVosI18nChild()
            self.i_18n_child = temp_model.from_map(m['I18nChild'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsArmsExporter') is not None:
            self.is_arms_exporter = m.get('IsArmsExporter')
        if m.get('Kind') is not None:
            self.kind = m.get('Kind')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NeedUpdate') is not None:
            self.need_update = m.get('NeedUpdate')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListDashboardsResponseBody(TeaModel):
    def __init__(
        self,
        dashboard_vos: List[ListDashboardsResponseBodyDashboardVos] = None,
        environment_id: str = None,
        grafana_service_opened: str = None,
        prometheus_service_opened: str = None,
        request_id: str = None,
    ):
        # The information about the Grafana dashboard.
        self.dashboard_vos = dashboard_vos
        # The ID of the environment instance.
        self.environment_id = environment_id
        # Indicates whether Managed Service for Grafana is activated.
        self.grafana_service_opened = grafana_service_opened
        # Whether or not to turn on Prometheus service.
        self.prometheus_service_opened = prometheus_service_opened
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dashboard_vos:
            for k in self.dashboard_vos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DashboardVos'] = []
        if self.dashboard_vos is not None:
            for k in self.dashboard_vos:
                result['DashboardVos'].append(k.to_map() if k else None)
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.grafana_service_opened is not None:
            result['GrafanaServiceOpened'] = self.grafana_service_opened
        if self.prometheus_service_opened is not None:
            result['PrometheusServiceOpened'] = self.prometheus_service_opened
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dashboard_vos = []
        if m.get('DashboardVos') is not None:
            for k in m.get('DashboardVos'):
                temp_model = ListDashboardsResponseBodyDashboardVos()
                self.dashboard_vos.append(temp_model.from_map(k))
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('GrafanaServiceOpened') is not None:
            self.grafana_service_opened = m.get('GrafanaServiceOpened')
        if m.get('PrometheusServiceOpened') is not None:
            self.prometheus_service_opened = m.get('PrometheusServiceOpened')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDashboardsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDashboardsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDashboardsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDashboardsByNameRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        dash_board_name: str = None,
        dash_board_version: str = None,
        data_source_type: str = None,
        group_name: str = None,
        only_query: bool = None,
        product_code: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster. If the ClusterType parameter is not set to `cloud-product-prometheus` or `cms-enterprise-prometheus`, you must specify the ClusterId parameter.
        self.cluster_id = cluster_id
        # The cluster type. Valid values:
        # 
        # *   vpc-prometheus
        # *   cloud-product-prometheus
        # *   cms-enterprise-prometheus
        # *   ExternalKubernetes
        # *   Ask
        # *   Kubernetes
        # *   ManagedKubernetes
        # *   remote-write-prometheus
        # *   GlobalViewV2
        self.cluster_type = cluster_type
        # The name of the dashboard.
        self.dash_board_name = dash_board_name
        # The version of the dashboard.
        self.dash_board_version = dash_board_version
        # The type of the data source. Valid values:
        # 
        # *   loki
        # *   prometheus
        self.data_source_type = data_source_type
        # The name of the dashboard group.
        self.group_name = group_name
        # Specifies whether to display the Grafana dashboard only in the Application Real-Time Monitoring Service (ARMS) console.
        self.only_query = only_query
        # The abbreviation of the Alibaba Cloud service name.
        self.product_code = product_code
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.dash_board_name is not None:
            result['DashBoardName'] = self.dash_board_name
        if self.dash_board_version is not None:
            result['DashBoardVersion'] = self.dash_board_version
        if self.data_source_type is not None:
            result['DataSourceType'] = self.data_source_type
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.only_query is not None:
            result['OnlyQuery'] = self.only_query
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('DashBoardName') is not None:
            self.dash_board_name = m.get('DashBoardName')
        if m.get('DashBoardVersion') is not None:
            self.dash_board_version = m.get('DashBoardVersion')
        if m.get('DataSourceType') is not None:
            self.data_source_type = m.get('DataSourceType')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('OnlyQuery') is not None:
            self.only_query = m.get('OnlyQuery')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListDashboardsByNameResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status Code. Description 200 indicates success.
        self.code = code
        # The returned struct.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The ID of the request, You can use the ID to locate logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDashboardsByNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDashboardsByNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDashboardsByNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDispatchRuleRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        region_id: str = None,
        system: bool = None,
    ):
        # The name of the notification policy. Fuzzy match is supported.
        self.name = name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # *   The type of notification policies to be queried. Valid values: `false` (default): notification policies created in Application Real-Time Monitoring Service (ARMS).
        # *   `true`: notification policies created in an external system.
        # 
        # >  You cannot use the ARMS console to modify the dispatch rules of a notification policy that is created in an external system.
        self.system = system

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.system is not None:
            result['System'] = self.system
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('System') is not None:
            self.system = m.get('System')
        return self


class ListDispatchRuleResponseBodyDispatchRules(TeaModel):
    def __init__(
        self,
        name: str = None,
        rule_id: int = None,
        state: str = None,
    ):
        # The name of the notification policy.
        self.name = name
        # The ID of the notification policy.
        self.rule_id = rule_id
        # Indicates whether the notification policy is enabled. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListDispatchRuleResponseBody(TeaModel):
    def __init__(
        self,
        dispatch_rules: List[ListDispatchRuleResponseBodyDispatchRules] = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.dispatch_rules = dispatch_rules
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.dispatch_rules:
            for k in self.dispatch_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DispatchRules'] = []
        if self.dispatch_rules is not None:
            for k in self.dispatch_rules:
                result['DispatchRules'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dispatch_rules = []
        if m.get('DispatchRules') is not None:
            for k in m.get('DispatchRules'):
                temp_model = ListDispatchRuleResponseBodyDispatchRules()
                self.dispatch_rules.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDispatchRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDispatchRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDispatchRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvCustomJobsRequest(TeaModel):
    def __init__(
        self,
        encrypt_yaml: bool = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # Specifies whether to return the encrypted YAML string.
        self.encrypt_yaml = encrypt_yaml
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encrypt_yaml is not None:
            result['EncryptYaml'] = self.encrypt_yaml
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EncryptYaml') is not None:
            self.encrypt_yaml = m.get('EncryptYaml')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvCustomJobsResponseBodyDataScrapeConfigs(TeaModel):
    def __init__(
        self,
        job_name: str = None,
        metrics_path: str = None,
        scrape_discoverys: List[str] = None,
        scrape_interval: str = None,
    ):
        # The name of the job.
        self.job_name = job_name
        # The path of the metric.
        self.metrics_path = metrics_path
        # The service discovery methods.
        self.scrape_discoverys = scrape_discoverys
        # The capture interval.
        self.scrape_interval = scrape_interval

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.metrics_path is not None:
            result['MetricsPath'] = self.metrics_path
        if self.scrape_discoverys is not None:
            result['ScrapeDiscoverys'] = self.scrape_discoverys
        if self.scrape_interval is not None:
            result['ScrapeInterval'] = self.scrape_interval
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('MetricsPath') is not None:
            self.metrics_path = m.get('MetricsPath')
        if m.get('ScrapeDiscoverys') is not None:
            self.scrape_discoverys = m.get('ScrapeDiscoverys')
        if m.get('ScrapeInterval') is not None:
            self.scrape_interval = m.get('ScrapeInterval')
        return self


class ListEnvCustomJobsResponseBodyData(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_release_name: str = None,
        addon_version: str = None,
        config_yaml: str = None,
        creation_timestamp: str = None,
        custom_job_name: str = None,
        environment_id: str = None,
        region_id: str = None,
        scrape_configs: List[ListEnvCustomJobsResponseBodyDataScrapeConfigs] = None,
        status: str = None,
    ):
        # The name of the add-on to which the custom job belongs.
        self.addon_name = addon_name
        # The instance name of the add-on.
        self.addon_release_name = addon_release_name
        # The version of the add-on.
        self.addon_version = addon_version
        # If the request parameter EncryptYaml is set to true, a Base64-encoded YAML string is returned. Otherwise, a plaintext YAML string is returned.
        self.config_yaml = config_yaml
        # The time when the custom job was created. The value of this parameter is a timestamp.
        self.creation_timestamp = creation_timestamp
        # The name of the custom job.
        self.custom_job_name = custom_job_name
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id
        # The capture configurations.
        self.scrape_configs = scrape_configs
        # The status of the custom job.
        self.status = status

    def validate(self):
        if self.scrape_configs:
            for k in self.scrape_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.addon_release_name is not None:
            result['AddonReleaseName'] = self.addon_release_name
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.creation_timestamp is not None:
            result['CreationTimestamp'] = self.creation_timestamp
        if self.custom_job_name is not None:
            result['CustomJobName'] = self.custom_job_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['ScrapeConfigs'] = []
        if self.scrape_configs is not None:
            for k in self.scrape_configs:
                result['ScrapeConfigs'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AddonReleaseName') is not None:
            self.addon_release_name = m.get('AddonReleaseName')
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('CreationTimestamp') is not None:
            self.creation_timestamp = m.get('CreationTimestamp')
        if m.get('CustomJobName') is not None:
            self.custom_job_name = m.get('CustomJobName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.scrape_configs = []
        if m.get('ScrapeConfigs') is not None:
            for k in m.get('ScrapeConfigs'):
                temp_model = ListEnvCustomJobsResponseBodyDataScrapeConfigs()
                self.scrape_configs.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListEnvCustomJobsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvCustomJobsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvCustomJobsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvCustomJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvCustomJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvCustomJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvPodMonitorsRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvPodMonitorsResponseBodyDataEndpoints(TeaModel):
    def __init__(
        self,
        interval: str = None,
        matched_target_count: int = None,
        path: str = None,
        port: str = None,
        target_port: int = None,
    ):
        # The collection interval.
        self.interval = interval
        # The number of pods that match the PodMonitor endpoint.
        self.matched_target_count = matched_target_count
        # The collection path.
        self.path = path
        # The external port.
        self.port = port
        # The destination port.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.matched_target_count is not None:
            result['MatchedTargetCount'] = self.matched_target_count
        if self.path is not None:
            result['Path'] = self.path
        if self.port is not None:
            result['Port'] = self.port
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('MatchedTargetCount') is not None:
            self.matched_target_count = m.get('MatchedTargetCount')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class ListEnvPodMonitorsResponseBodyData(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_release_name: str = None,
        addon_version: str = None,
        config_yaml: str = None,
        creation_timestamp: str = None,
        endpoints: List[ListEnvPodMonitorsResponseBodyDataEndpoints] = None,
        environment_id: str = None,
        namespace: str = None,
        pod_monitor_name: str = None,
        region_id: str = None,
        status: str = None,
    ):
        # The name of the add-on to which the PodMonitor belongs.
        self.addon_name = addon_name
        # The instance name of the add-on.
        self.addon_release_name = addon_release_name
        # The version of the add-on.
        self.addon_version = addon_version
        # The YAML configuration string.
        self.config_yaml = config_yaml
        # The time when the PodMonitor was created. The value of this parameter is a timestamp.
        self.creation_timestamp = creation_timestamp
        # The endpoints of the PodMonitor.
        self.endpoints = endpoints
        # The environment ID.
        self.environment_id = environment_id
        # The namespace.
        self.namespace = namespace
        # The name of the PodMonitor.
        self.pod_monitor_name = pod_monitor_name
        # The region ID.
        self.region_id = region_id
        # The status of the PodMonitor.
        self.status = status

    def validate(self):
        if self.endpoints:
            for k in self.endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.addon_release_name is not None:
            result['AddonReleaseName'] = self.addon_release_name
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.creation_timestamp is not None:
            result['CreationTimestamp'] = self.creation_timestamp
        result['Endpoints'] = []
        if self.endpoints is not None:
            for k in self.endpoints:
                result['Endpoints'].append(k.to_map() if k else None)
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod_monitor_name is not None:
            result['PodMonitorName'] = self.pod_monitor_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AddonReleaseName') is not None:
            self.addon_release_name = m.get('AddonReleaseName')
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('CreationTimestamp') is not None:
            self.creation_timestamp = m.get('CreationTimestamp')
        self.endpoints = []
        if m.get('Endpoints') is not None:
            for k in m.get('Endpoints'):
                temp_model = ListEnvPodMonitorsResponseBodyDataEndpoints()
                self.endpoints.append(temp_model.from_map(k))
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PodMonitorName') is not None:
            self.pod_monitor_name = m.get('PodMonitorName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListEnvPodMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvPodMonitorsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvPodMonitorsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvPodMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvPodMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvPodMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvServiceMonitorsRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvServiceMonitorsResponseBodyDataEndpoints(TeaModel):
    def __init__(
        self,
        interval: str = None,
        matched_target_count: int = None,
        path: str = None,
        port: str = None,
        target_port: int = None,
    ):
        # The collection interval.
        self.interval = interval
        # The number of pods that match the ServiceMonitor endpoint.
        self.matched_target_count = matched_target_count
        # The collection path.
        self.path = path
        # The external port.
        self.port = port
        # The destination port.
        self.target_port = target_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.matched_target_count is not None:
            result['MatchedTargetCount'] = self.matched_target_count
        if self.path is not None:
            result['Path'] = self.path
        if self.port is not None:
            result['Port'] = self.port
        if self.target_port is not None:
            result['TargetPort'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('MatchedTargetCount') is not None:
            self.matched_target_count = m.get('MatchedTargetCount')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Port') is not None:
            self.port = m.get('Port')
        if m.get('TargetPort') is not None:
            self.target_port = m.get('TargetPort')
        return self


class ListEnvServiceMonitorsResponseBodyData(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        addon_release_name: str = None,
        addon_version: str = None,
        config_yaml: str = None,
        creation_timestamp: str = None,
        endpoints: List[ListEnvServiceMonitorsResponseBodyDataEndpoints] = None,
        environment_id: str = None,
        matched_service_count: int = None,
        namespace: str = None,
        region_id: str = None,
        service_monitor_name: str = None,
        status: str = None,
    ):
        # The name of the add-on to which the ServiceMonitor belongs.
        self.addon_name = addon_name
        # The instance name of the add-on.
        self.addon_release_name = addon_release_name
        # The version of the add-on.
        self.addon_version = addon_version
        # The YAML configuration string.
        self.config_yaml = config_yaml
        # The time when the ServiceMonitor was created. The value of this parameter is a timestamp.
        self.creation_timestamp = creation_timestamp
        # The endpoints of the ServiceMonitor.
        self.endpoints = endpoints
        # The environment ID.
        self.environment_id = environment_id
        # The number of matched services.
        self.matched_service_count = matched_service_count
        # The namespace.
        self.namespace = namespace
        # The region ID.
        self.region_id = region_id
        # The name of the ServiceMonitor.
        self.service_monitor_name = service_monitor_name
        # The status of the ServiceMonitor.
        self.status = status

    def validate(self):
        if self.endpoints:
            for k in self.endpoints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.addon_release_name is not None:
            result['AddonReleaseName'] = self.addon_release_name
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.creation_timestamp is not None:
            result['CreationTimestamp'] = self.creation_timestamp
        result['Endpoints'] = []
        if self.endpoints is not None:
            for k in self.endpoints:
                result['Endpoints'].append(k.to_map() if k else None)
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.matched_service_count is not None:
            result['MatchedServiceCount'] = self.matched_service_count
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service_monitor_name is not None:
            result['ServiceMonitorName'] = self.service_monitor_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('AddonReleaseName') is not None:
            self.addon_release_name = m.get('AddonReleaseName')
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('CreationTimestamp') is not None:
            self.creation_timestamp = m.get('CreationTimestamp')
        self.endpoints = []
        if m.get('Endpoints') is not None:
            for k in m.get('Endpoints'):
                temp_model = ListEnvServiceMonitorsResponseBodyDataEndpoints()
                self.endpoints.append(temp_model.from_map(k))
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('MatchedServiceCount') is not None:
            self.matched_service_count = m.get('MatchedServiceCount')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServiceMonitorName') is not None:
            self.service_monitor_name = m.get('ServiceMonitorName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListEnvServiceMonitorsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvServiceMonitorsResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvServiceMonitorsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEnvServiceMonitorsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvServiceMonitorsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvServiceMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentAddonsRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        region_id: str = None,
    ):
        # This parameter is required.
        self.environment_id = environment_id
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentAddonsResponseBodyDataAddonsDashboards(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        url: str = None,
    ):
        # The description of the dashboard.
        self.description = description
        # The name of the dashboard.
        self.name = name
        # The URL of the dashboard.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsDependencies(TeaModel):
    def __init__(
        self,
        cluster_types: List[str] = None,
        features: Dict[str, bool] = None,
        services: List[str] = None,
    ):
        # The cluster type.
        self.cluster_types = cluster_types
        # The feature that can be installed in the environment.
        self.features = features
        # The services.
        self.services = services

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_types is not None:
            result['ClusterTypes'] = self.cluster_types
        if self.features is not None:
            result['Features'] = self.features
        if self.services is not None:
            result['Services'] = self.services
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterTypes') is not None:
            self.cluster_types = m.get('ClusterTypes')
        if m.get('Features') is not None:
            self.features = m.get('Features')
        if m.get('Services') is not None:
            self.services = m.get('Services')
        return self


class ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPoliciesMetricCheckRule(TeaModel):
    def __init__(
        self,
        prom_ql: List[str] = None,
    ):
        # The PromQL statements.
        self.prom_ql = prom_ql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        return self


class ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPoliciesProtocols(TeaModel):
    def __init__(
        self,
        description: str = None,
        icon: str = None,
        label: str = None,
        name: str = None,
    ):
        # The description of the protocol.
        self.description = description
        # The URL of the protocol icon.
        self.icon = icon
        # The tag of the protocol.
        self.label = label
        # The name of the protocol.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.label is not None:
            result['Label'] = self.label
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPolicies(TeaModel):
    def __init__(
        self,
        alert_default_status: str = None,
        default_install: bool = None,
        enable_service_account: bool = None,
        metric_check_rule: ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPoliciesMetricCheckRule = None,
        need_restart_after_integration: bool = None,
        protocols: List[ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPoliciesProtocols] = None,
        target_addon_name: str = None,
    ):
        # The default alert status.
        self.alert_default_status = alert_default_status
        # The default installation status.
        self.default_install = default_install
        # Indicates whether a service account is enabled.
        self.enable_service_account = enable_service_account
        # The metric check rule.
        self.metric_check_rule = metric_check_rule
        # Indicates whether a restart is required after the installation.
        self.need_restart_after_integration = need_restart_after_integration
        # The supported protocols.
        self.protocols = protocols
        # The target name of the add-on.
        self.target_addon_name = target_addon_name

    def validate(self):
        if self.metric_check_rule:
            self.metric_check_rule.validate()
        if self.protocols:
            for k in self.protocols:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_default_status is not None:
            result['AlertDefaultStatus'] = self.alert_default_status
        if self.default_install is not None:
            result['DefaultInstall'] = self.default_install
        if self.enable_service_account is not None:
            result['EnableServiceAccount'] = self.enable_service_account
        if self.metric_check_rule is not None:
            result['MetricCheckRule'] = self.metric_check_rule.to_map()
        if self.need_restart_after_integration is not None:
            result['NeedRestartAfterIntegration'] = self.need_restart_after_integration
        result['Protocols'] = []
        if self.protocols is not None:
            for k in self.protocols:
                result['Protocols'].append(k.to_map() if k else None)
        if self.target_addon_name is not None:
            result['TargetAddonName'] = self.target_addon_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertDefaultStatus') is not None:
            self.alert_default_status = m.get('AlertDefaultStatus')
        if m.get('DefaultInstall') is not None:
            self.default_install = m.get('DefaultInstall')
        if m.get('EnableServiceAccount') is not None:
            self.enable_service_account = m.get('EnableServiceAccount')
        if m.get('MetricCheckRule') is not None:
            temp_model = ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPoliciesMetricCheckRule()
            self.metric_check_rule = temp_model.from_map(m['MetricCheckRule'])
        if m.get('NeedRestartAfterIntegration') is not None:
            self.need_restart_after_integration = m.get('NeedRestartAfterIntegration')
        self.protocols = []
        if m.get('Protocols') is not None:
            for k in m.get('Protocols'):
                temp_model = ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPoliciesProtocols()
                self.protocols.append(temp_model.from_map(k))
        if m.get('TargetAddonName') is not None:
            self.target_addon_name = m.get('TargetAddonName')
        return self


class ListEnvironmentAddonsResponseBodyDataAddonsEnvironments(TeaModel):
    def __init__(
        self,
        dependencies: ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsDependencies = None,
        description: str = None,
        enable: bool = None,
        label: str = None,
        name: str = None,
        policies: ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPolicies = None,
    ):
        # The dependencies of the environment.
        self.dependencies = dependencies
        # The description of the environment.
        self.description = description
        # Indicates whether the feature is enabled.
        self.enable = enable
        # The tag of the environment.
        self.label = label
        # The name of the environment.
        self.name = name
        # The control policies in the environment.
        self.policies = policies

    def validate(self):
        if self.dependencies:
            self.dependencies.validate()
        if self.policies:
            self.policies.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['Dependencies'] = self.dependencies.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.label is not None:
            result['Label'] = self.label
        if self.name is not None:
            result['Name'] = self.name
        if self.policies is not None:
            result['Policies'] = self.policies.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dependencies') is not None:
            temp_model = ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsDependencies()
            self.dependencies = temp_model.from_map(m['Dependencies'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Policies') is not None:
            temp_model = ListEnvironmentAddonsResponseBodyDataAddonsEnvironmentsPolicies()
            self.policies = temp_model.from_map(m['Policies'])
        return self


class ListEnvironmentAddonsResponseBodyDataAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        categories: List[str] = None,
        dashboards: List[ListEnvironmentAddonsResponseBodyDataAddonsDashboards] = None,
        description: str = None,
        environments: List[ListEnvironmentAddonsResponseBodyDataAddonsEnvironments] = None,
        icon: str = None,
        keywords: List[str] = None,
        language: str = None,
        latest_release_create_time: str = None,
        name: str = None,
        once: bool = None,
        scene: str = None,
        version: str = None,
        weight: str = None,
    ):
        # The alias of the add-on.
        self.alias = alias
        # The tags of the add-on.
        self.categories = categories
        # The dashboards.
        self.dashboards = dashboards
        # The description of the add-on.
        self.description = description
        # The supported environments.
        self.environments = environments
        # The URL of the icon.
        self.icon = icon
        # The collection of keywords.
        self.keywords = keywords
        # The language.
        self.language = language
        # The time when the instance was last created.
        self.latest_release_create_time = latest_release_create_time
        # The name of the add-on.
        self.name = name
        # Indicates whether the add-on can be installed only once.
        self.once = once
        # The scenario.
        self.scene = scene
        # The version of the agent.
        self.version = version
        # The weight.
        self.weight = weight

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.categories is not None:
            result['Categories'] = self.categories
        result['Dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['Dashboards'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        result['Environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['Environments'].append(k.to_map() if k else None)
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_release_create_time is not None:
            result['LatestReleaseCreateTime'] = self.latest_release_create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.once is not None:
            result['Once'] = self.once
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.version is not None:
            result['Version'] = self.version
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Categories') is not None:
            self.categories = m.get('Categories')
        self.dashboards = []
        if m.get('Dashboards') is not None:
            for k in m.get('Dashboards'):
                temp_model = ListEnvironmentAddonsResponseBodyDataAddonsDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.environments = []
        if m.get('Environments') is not None:
            for k in m.get('Environments'):
                temp_model = ListEnvironmentAddonsResponseBodyDataAddonsEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('LatestReleaseCreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Once') is not None:
            self.once = m.get('Once')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class ListEnvironmentAddonsResponseBodyData(TeaModel):
    def __init__(
        self,
        addons: List[ListEnvironmentAddonsResponseBodyDataAddons] = None,
        total: int = None,
    ):
        # The queried add-ons.
        self.addons = addons
        self.total = total

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['Addons'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('Addons') is not None:
            for k in m.get('Addons'):
                temp_model = ListEnvironmentAddonsResponseBodyDataAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEnvironmentAddonsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentAddonsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        # The result of the operation.
        self.data = data
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentAddonsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentAddonsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentAddonsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentAddonsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentAlertRulesRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        environment_id: str = None,
        region_id: str = None,
        scene: str = None,
    ):
        # The name of the add-on. You must specify AddonName or Scene.
        self.addon_name = addon_name
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id
        # The scenario of the add-on. You must specify AddonName or Scene.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene is not None:
            result['Scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        return self


class ListEnvironmentAlertRulesResponseBodyDataRules(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        name: str = None,
    ):
        # The ID of the alert rule.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentAlertRulesResponseBodyData(TeaModel):
    def __init__(
        self,
        groups: List[str] = None,
        rules: List[ListEnvironmentAlertRulesResponseBodyDataRules] = None,
        total: int = None,
    ):
        # The queried alert groups.
        self.groups = groups
        # The queried rules.
        self.rules = rules
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.groups is not None:
            result['Groups'] = self.groups
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = ListEnvironmentAlertRulesResponseBodyDataRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEnvironmentAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentAlertRulesResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The struct returned.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentAlertRulesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentDashboardsRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        environment_id: str = None,
        region_id: str = None,
        scene: str = None,
    ):
        # Name of Addon,One of AddonName and Scene must be filled in.
        self.addon_name = addon_name
        # The ID of the environment instance.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID of the instance.
        self.region_id = region_id
        # The scenario of Addon. Either AddonName or Scene is required.
        self.scene = scene

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene is not None:
            result['Scene'] = self.scene
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        return self


class ListEnvironmentDashboardsResponseBodyDataDashboards(TeaModel):
    def __init__(
        self,
        folder_uid: str = None,
        region: str = None,
        tags: List[str] = None,
        title: str = None,
        uid: str = None,
        url: str = None,
    ):
        # The UID of the folder.
        self.folder_uid = folder_uid
        # The region ID.
        self.region = region
        # The keyword.
        self.tags = tags
        # The title of the Grafana dashboard.
        self.title = title
        # The unique identifier of the dashboard.
        self.uid = uid
        # The complete URL of the dashboard.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.folder_uid is not None:
            result['FolderUid'] = self.folder_uid
        if self.region is not None:
            result['Region'] = self.region
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.title is not None:
            result['Title'] = self.title
        if self.uid is not None:
            result['Uid'] = self.uid
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FolderUid') is not None:
            self.folder_uid = m.get('FolderUid')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Uid') is not None:
            self.uid = m.get('Uid')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListEnvironmentDashboardsResponseBodyData(TeaModel):
    def __init__(
        self,
        dashboards: List[ListEnvironmentDashboardsResponseBodyDataDashboards] = None,
        total: int = None,
    ):
        # The dashboards.
        self.dashboards = dashboards
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['Dashboards'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dashboards = []
        if m.get('Dashboards') is not None:
            for k in m.get('Dashboards'):
                temp_model = ListEnvironmentDashboardsResponseBodyDataDashboards()
                self.dashboards.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEnvironmentDashboardsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentDashboardsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentDashboardsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentDashboardsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentDashboardsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentDashboardsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentFeaturesRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_id: str = None,
        region_id: str = None,
    ):
        # The language. Default value: zh.
        # 
        # Valid values:
        # 
        # *   en: English.
        # *   zh: Chinese.
        self.aliyun_lang = aliyun_lang
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentFeaturesResponseBodyData(TeaModel):
    def __init__(
        self,
        alias: str = None,
        config: Dict[str, str] = None,
        description: str = None,
        environment_id: str = None,
        icon: str = None,
        language: str = None,
        latest_version: str = None,
        managed: bool = None,
        name: str = None,
        status: str = None,
        version: str = None,
    ):
        # The alias of the feature.
        self.alias = alias
        # The feature configuration.
        self.config = config
        # The description of the feature.
        self.description = description
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The URL of the icon.
        self.icon = icon
        # The language. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        self.language = language
        # The latest version number.
        self.latest_version = latest_version
        # Indicates whether the component is fully managed.
        self.managed = managed
        # The name of the feature.
        self.name = name
        # The status of the feature. Valid values:
        # 
        # *   Installing: The agent is being installed.
        # *   Success: The agent is installed.
        # *   Failed: The agent failed to be installed.
        # *   UnInstall: The agent is uninstalled.
        # *   Uninstalling: The agent is being uninstalled.
        # *   UnInstallFailed: The agent failed to be uninstalled.
        self.status = status
        # The version of the feature.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.config is not None:
            result['Config'] = self.config
        if self.description is not None:
            result['Description'] = self.description
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.language is not None:
            result['Language'] = self.language
        if self.latest_version is not None:
            result['LatestVersion'] = self.latest_version
        if self.managed is not None:
            result['Managed'] = self.managed
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('LatestVersion') is not None:
            self.latest_version = m.get('LatestVersion')
        if m.get('Managed') is not None:
            self.managed = m.get('Managed')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListEnvironmentFeaturesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvironmentFeaturesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # Status Code. Description 200 indicates success.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the alert rule was deleted. Valid values:
        # 
        # *   `true`: The alert rule was deleted.
        # *   `false`: The alert rule failed to be deleted.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvironmentFeaturesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentFeaturesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentFeaturesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentFeaturesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentKubeResourcesRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        kind: str = None,
        label_selectors: Dict[str, str] = None,
        namespace: str = None,
        region_id: str = None,
    ):
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The resource type. Valid values: Pod, Deployment, and Service.
        # 
        # This parameter is required.
        self.kind = kind
        # The tags.
        self.label_selectors = label_selectors
        # The namespace.
        self.namespace = namespace
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.kind is not None:
            result['Kind'] = self.kind
        if self.label_selectors is not None:
            result['LabelSelectors'] = self.label_selectors
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Kind') is not None:
            self.kind = m.get('Kind')
        if m.get('LabelSelectors') is not None:
            self.label_selectors = m.get('LabelSelectors')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentKubeResourcesShrinkRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        kind: str = None,
        label_selectors_shrink: str = None,
        namespace: str = None,
        region_id: str = None,
    ):
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The resource type. Valid values: Pod, Deployment, and Service.
        # 
        # This parameter is required.
        self.kind = kind
        # The tags.
        self.label_selectors_shrink = label_selectors_shrink
        # The namespace.
        self.namespace = namespace
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.kind is not None:
            result['Kind'] = self.kind
        if self.label_selectors_shrink is not None:
            result['LabelSelectors'] = self.label_selectors_shrink
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Kind') is not None:
            self.kind = m.get('Kind')
        if m.get('LabelSelectors') is not None:
            self.label_selectors_shrink = m.get('LabelSelectors')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentKubeResourcesResponseBodyDataMetadata(TeaModel):
    def __init__(
        self,
        annotations: Dict[str, str] = None,
        labels: Dict[str, str] = None,
        name: str = None,
        namespace: str = None,
    ):
        # The annotations.
        self.annotations = annotations
        # The tags.
        self.labels = labels
        # The resource name.
        self.name = name
        # The namespace.
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class ListEnvironmentKubeResourcesResponseBodyData(TeaModel):
    def __init__(
        self,
        api_version: str = None,
        kind: str = None,
        metadata: ListEnvironmentKubeResourcesResponseBodyDataMetadata = None,
        spec: Any = None,
        status: Any = None,
    ):
        # The version number of the API.
        self.api_version = api_version
        # The resource type.
        self.kind = kind
        # The metadata.
        self.metadata = metadata
        # The resource specifications.
        self.spec = spec
        # The status of the resource.
        self.status = status

    def validate(self):
        if self.metadata:
            self.metadata.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_version is not None:
            result['ApiVersion'] = self.api_version
        if self.kind is not None:
            result['Kind'] = self.kind
        if self.metadata is not None:
            result['Metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiVersion') is not None:
            self.api_version = m.get('ApiVersion')
        if m.get('Kind') is not None:
            self.kind = m.get('Kind')
        if m.get('Metadata') is not None:
            temp_model = ListEnvironmentKubeResourcesResponseBodyDataMetadata()
            self.metadata = temp_model.from_map(m['Metadata'])
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListEnvironmentKubeResourcesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListEnvironmentKubeResourcesResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListEnvironmentKubeResourcesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentKubeResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentKubeResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentKubeResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentMetricTargetsRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        job_name: str = None,
        region_id: str = None,
    ):
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The job name.
        self.job_name = job_name
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListEnvironmentMetricTargetsResponseBodyDataActiveTargets(TeaModel):
    def __init__(
        self,
        discovered_labels: Dict[str, str] = None,
        global_url: str = None,
        health: str = None,
        labels: Dict[str, str] = None,
        last_error: str = None,
        last_scrape: str = None,
        last_scrape_duration: float = None,
        last_scrape_series: int = None,
        scrape_pool: str = None,
        scrape_url: str = None,
    ):
        # The tags used for service discovery.
        self.discovered_labels = discovered_labels
        # The URL of the target.
        self.global_url = global_url
        # The health status.
        self.health = health
        # The tags.
        self.labels = labels
        # The last error message.
        self.last_error = last_error
        # The last collection time.
        self.last_scrape = last_scrape
        # The duration of the last collection.
        self.last_scrape_duration = last_scrape_duration
        # The amount of metrics in the last collection.
        self.last_scrape_series = last_scrape_series
        # The name of the collection.
        self.scrape_pool = scrape_pool
        # The URL of the collection.
        self.scrape_url = scrape_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discovered_labels is not None:
            result['DiscoveredLabels'] = self.discovered_labels
        if self.global_url is not None:
            result['GlobalUrl'] = self.global_url
        if self.health is not None:
            result['Health'] = self.health
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.last_error is not None:
            result['LastError'] = self.last_error
        if self.last_scrape is not None:
            result['LastScrape'] = self.last_scrape
        if self.last_scrape_duration is not None:
            result['LastScrapeDuration'] = self.last_scrape_duration
        if self.last_scrape_series is not None:
            result['LastScrapeSeries'] = self.last_scrape_series
        if self.scrape_pool is not None:
            result['ScrapePool'] = self.scrape_pool
        if self.scrape_url is not None:
            result['ScrapeUrl'] = self.scrape_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscoveredLabels') is not None:
            self.discovered_labels = m.get('DiscoveredLabels')
        if m.get('GlobalUrl') is not None:
            self.global_url = m.get('GlobalUrl')
        if m.get('Health') is not None:
            self.health = m.get('Health')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LastError') is not None:
            self.last_error = m.get('LastError')
        if m.get('LastScrape') is not None:
            self.last_scrape = m.get('LastScrape')
        if m.get('LastScrapeDuration') is not None:
            self.last_scrape_duration = m.get('LastScrapeDuration')
        if m.get('LastScrapeSeries') is not None:
            self.last_scrape_series = m.get('LastScrapeSeries')
        if m.get('ScrapePool') is not None:
            self.scrape_pool = m.get('ScrapePool')
        if m.get('ScrapeUrl') is not None:
            self.scrape_url = m.get('ScrapeUrl')
        return self


class ListEnvironmentMetricTargetsResponseBodyDataDroppedTargets(TeaModel):
    def __init__(
        self,
        discovered_labels: Dict[str, str] = None,
        global_url: str = None,
        health: str = None,
        labels: Dict[str, str] = None,
        last_error: str = None,
        last_scrape: str = None,
        last_scrape_duration: float = None,
        last_scrape_series: int = None,
        scrape_pool: str = None,
        scrape_url: str = None,
    ):
        # The tags used for service discovery.
        self.discovered_labels = discovered_labels
        # The URL of the target.
        self.global_url = global_url
        # The health status.
        self.health = health
        # The tags.
        self.labels = labels
        # The last error message.
        self.last_error = last_error
        # The last collection time.
        self.last_scrape = last_scrape
        # The duration of the last collection.
        self.last_scrape_duration = last_scrape_duration
        # The amount of metrics in the last collection.
        self.last_scrape_series = last_scrape_series
        # The name of the collection.
        self.scrape_pool = scrape_pool
        # The URL of the collection.
        self.scrape_url = scrape_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discovered_labels is not None:
            result['DiscoveredLabels'] = self.discovered_labels
        if self.global_url is not None:
            result['GlobalUrl'] = self.global_url
        if self.health is not None:
            result['Health'] = self.health
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.last_error is not None:
            result['LastError'] = self.last_error
        if self.last_scrape is not None:
            result['LastScrape'] = self.last_scrape
        if self.last_scrape_duration is not None:
            result['LastScrapeDuration'] = self.last_scrape_duration
        if self.last_scrape_series is not None:
            result['LastScrapeSeries'] = self.last_scrape_series
        if self.scrape_pool is not None:
            result['ScrapePool'] = self.scrape_pool
        if self.scrape_url is not None:
            result['ScrapeUrl'] = self.scrape_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiscoveredLabels') is not None:
            self.discovered_labels = m.get('DiscoveredLabels')
        if m.get('GlobalUrl') is not None:
            self.global_url = m.get('GlobalUrl')
        if m.get('Health') is not None:
            self.health = m.get('Health')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('LastError') is not None:
            self.last_error = m.get('LastError')
        if m.get('LastScrape') is not None:
            self.last_scrape = m.get('LastScrape')
        if m.get('LastScrapeDuration') is not None:
            self.last_scrape_duration = m.get('LastScrapeDuration')
        if m.get('LastScrapeSeries') is not None:
            self.last_scrape_series = m.get('LastScrapeSeries')
        if m.get('ScrapePool') is not None:
            self.scrape_pool = m.get('ScrapePool')
        if m.get('ScrapeUrl') is not None:
            self.scrape_url = m.get('ScrapeUrl')
        return self


class ListEnvironmentMetricTargetsResponseBodyData(TeaModel):
    def __init__(
        self,
        active_targets: List[ListEnvironmentMetricTargetsResponseBodyDataActiveTargets] = None,
        dropped_targets: List[ListEnvironmentMetricTargetsResponseBodyDataDroppedTargets] = None,
    ):
        # The active targets.
        self.active_targets = active_targets
        # The deleted targets.
        self.dropped_targets = dropped_targets

    def validate(self):
        if self.active_targets:
            for k in self.active_targets:
                if k:
                    k.validate()
        if self.dropped_targets:
            for k in self.dropped_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActiveTargets'] = []
        if self.active_targets is not None:
            for k in self.active_targets:
                result['ActiveTargets'].append(k.to_map() if k else None)
        result['DroppedTargets'] = []
        if self.dropped_targets is not None:
            for k in self.dropped_targets:
                result['DroppedTargets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.active_targets = []
        if m.get('ActiveTargets') is not None:
            for k in m.get('ActiveTargets'):
                temp_model = ListEnvironmentMetricTargetsResponseBodyDataActiveTargets()
                self.active_targets.append(temp_model.from_map(k))
        self.dropped_targets = []
        if m.get('DroppedTargets') is not None:
            for k in m.get('DroppedTargets'):
                temp_model = ListEnvironmentMetricTargetsResponseBodyDataDroppedTargets()
                self.dropped_targets.append(temp_model.from_map(k))
        return self


class ListEnvironmentMetricTargetsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentMetricTargetsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The struct returned.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentMetricTargetsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentMetricTargetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentMetricTargetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentMetricTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEnvironmentsRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListEnvironmentsRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        bind_resource_id: str = None,
        environment_type: str = None,
        fee_package: str = None,
        filter_region_ids: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tag: List[ListEnvironmentsRequestTag] = None,
    ):
        # The add-on name. You must specify at least one of the AddonName and EnvironmentType parameters.
        self.addon_name = addon_name
        # The ID of the resource.
        self.bind_resource_id = bind_resource_id
        # The environment type. You must specify at least one of the AddonName and EnvironmentType parameters.
        # 
        # Valid values:
        # 
        # *   CS
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Container Service for Kubernetes (ACK)
        # 
        #     <!-- -->
        # 
        # *   ECS
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Elastic Compute Service (ECS)
        # 
        #     <!-- -->
        # 
        # *   Cloud
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     cloud service
        # 
        #     <!-- -->
        self.environment_type = environment_type
        # The payable resource plan.
        # 
        # *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
        # *   Otherwise, leave the parameter empty.
        # 
        # Valid values:
        # 
        # *   CS_Pro: Container Monitoring Pro
        # *   CS_Basic: Container Monitoring Basic
        self.fee_package = fee_package
        # The region IDs.
        self.filter_region_ids = filter_region_ids
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.filter_region_ids is not None:
            result['FilterRegionIds'] = self.filter_region_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('FilterRegionIds') is not None:
            self.filter_region_ids = m.get('FilterRegionIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListEnvironmentsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ListEnvironmentsShrinkRequest(TeaModel):
    def __init__(
        self,
        addon_name: str = None,
        bind_resource_id: str = None,
        environment_type: str = None,
        fee_package: str = None,
        filter_region_ids: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tag_shrink: str = None,
    ):
        # The add-on name. You must specify at least one of the AddonName and EnvironmentType parameters.
        self.addon_name = addon_name
        # The ID of the resource.
        self.bind_resource_id = bind_resource_id
        # The environment type. You must specify at least one of the AddonName and EnvironmentType parameters.
        # 
        # Valid values:
        # 
        # *   CS
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Container Service for Kubernetes (ACK)
        # 
        #     <!-- -->
        # 
        # *   ECS
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Elastic Compute Service (ECS)
        # 
        #     <!-- -->
        # 
        # *   Cloud
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     cloud service
        # 
        #     <!-- -->
        self.environment_type = environment_type
        # The payable resource plan.
        # 
        # *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
        # *   Otherwise, leave the parameter empty.
        # 
        # Valid values:
        # 
        # *   CS_Pro: Container Monitoring Pro
        # *   CS_Basic: Container Monitoring Basic
        self.fee_package = fee_package
        # The region IDs.
        self.filter_region_ids = filter_region_ids
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tag_shrink = tag_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_name is not None:
            result['AddonName'] = self.addon_name
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.filter_region_ids is not None:
            result['FilterRegionIds'] = self.filter_region_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tag_shrink is not None:
            result['Tag'] = self.tag_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonName') is not None:
            self.addon_name = m.get('AddonName')
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('FilterRegionIds') is not None:
            self.filter_region_ids = m.get('FilterRegionIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tag') is not None:
            self.tag_shrink = m.get('Tag')
        return self


class ListEnvironmentsResponseBodyDataEnvironmentsAddons(TeaModel):
    def __init__(
        self,
        alias: str = None,
        description: str = None,
        icon: str = None,
        name: str = None,
    ):
        # The alias of the add-on.
        self.alias = alias
        # The description of the add-on.
        self.description = description
        # The URL of the icon.
        self.icon = icon
        # The name of the add-on.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentsResponseBodyDataEnvironmentsFeatures(TeaModel):
    def __init__(
        self,
        alias: str = None,
        description: str = None,
        icon: str = None,
        name: str = None,
    ):
        # The alias of the feature.
        self.alias = alias
        # The description of the feature.
        self.description = description
        # The URL of the icon.
        self.icon = icon
        # The name of the feature.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.description is not None:
            result['Description'] = self.description
        if self.icon is not None:
            result['Icon'] = self.icon
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Icon') is not None:
            self.icon = m.get('Icon')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEnvironmentsResponseBodyDataEnvironmentsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListEnvironmentsResponseBodyDataEnvironments(TeaModel):
    def __init__(
        self,
        addons: List[ListEnvironmentsResponseBodyDataEnvironmentsAddons] = None,
        bind_resource_id: str = None,
        bind_resource_profile: str = None,
        bind_resource_type: str = None,
        bind_vpc_cidr: str = None,
        create_time: str = None,
        created_user_id: str = None,
        environment_id: str = None,
        environment_name: str = None,
        environment_type: str = None,
        features: List[ListEnvironmentsResponseBodyDataEnvironmentsFeatures] = None,
        fee_package: str = None,
        grafana_datasource_uid: str = None,
        grafana_folder_title: str = None,
        grafana_folder_uid: str = None,
        latest_release_create_time: str = None,
        managed_type: str = None,
        prometheus_id: int = None,
        prometheus_instance_id: str = None,
        region_id: str = None,
        release_count: int = None,
        resource_group_id: str = None,
        tags: List[ListEnvironmentsResponseBodyDataEnvironmentsTags] = None,
        user_id: str = None,
    ):
        # The add-ons.
        self.addons = addons
        # The ID of the resource bound to the environment instance. The resource can be a Kubernetes cluster or a VPC.
        self.bind_resource_id = bind_resource_id
        # The profile that is bound to the resource.
        self.bind_resource_profile = bind_resource_profile
        # The resource type.
        self.bind_resource_type = bind_resource_type
        # The CIDR block that is bound to the VPC.
        self.bind_vpc_cidr = bind_vpc_cidr
        # The time when the environment instance was created.
        self.create_time = create_time
        # The user ID.
        self.created_user_id = created_user_id
        # The ID of the environment instance.
        self.environment_id = environment_id
        # The name of the environment instance.
        self.environment_name = environment_name
        # The type of the environment instance. Valid values:
        # 
        # *   CS: Container Service
        # *   ECS: Elastic Compute Service
        # *   Cloud: cloud service
        self.environment_type = environment_type
        # The parameters of the feature.
        self.features = features
        # The payable resource plan.
        # 
        # *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro.
        # *   Otherwise, leave the parameter empty.
        self.fee_package = fee_package
        # The unique ID of the Grafana data source.
        self.grafana_datasource_uid = grafana_datasource_uid
        # The name of the Grafana directory.
        self.grafana_folder_title = grafana_folder_title
        # The unique ID of the Grafana directory.
        self.grafana_folder_uid = grafana_folder_uid
        # The time when the last add-on was created.
        self.latest_release_create_time = latest_release_create_time
        # Indicates whether agents or exporters are managed. Valid values:
        # 
        # *   none: No. By default, no managed agents or exporters are provided for ACK clusters.
        # *   agent: Agents are managed. By default, managed agents are provided for ASK clusters, ACS clusters, and ACK One clusters.
        # *   agent-exproter: Agents and exporters are managed. By default, managed agents and exporters are provided for cloud services.
        self.managed_type = managed_type
        # The Prometheus ID.
        self.prometheus_id = prometheus_id
        # The ID of the Prometheus instance.
        self.prometheus_instance_id = prometheus_instance_id
        # The region ID.
        self.region_id = region_id
        # The number of installed add-ons.
        self.release_count = release_count
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags of the environment resource.
        self.tags = tags
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.addons:
            for k in self.addons:
                if k:
                    k.validate()
        if self.features:
            for k in self.features:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Addons'] = []
        if self.addons is not None:
            for k in self.addons:
                result['Addons'].append(k.to_map() if k else None)
        if self.bind_resource_id is not None:
            result['BindResourceId'] = self.bind_resource_id
        if self.bind_resource_profile is not None:
            result['BindResourceProfile'] = self.bind_resource_profile
        if self.bind_resource_type is not None:
            result['BindResourceType'] = self.bind_resource_type
        if self.bind_vpc_cidr is not None:
            result['BindVpcCidr'] = self.bind_vpc_cidr
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.created_user_id is not None:
            result['CreatedUserId'] = self.created_user_id
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.environment_type is not None:
            result['EnvironmentType'] = self.environment_type
        result['Features'] = []
        if self.features is not None:
            for k in self.features:
                result['Features'].append(k.to_map() if k else None)
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.grafana_datasource_uid is not None:
            result['GrafanaDatasourceUid'] = self.grafana_datasource_uid
        if self.grafana_folder_title is not None:
            result['GrafanaFolderTitle'] = self.grafana_folder_title
        if self.grafana_folder_uid is not None:
            result['GrafanaFolderUid'] = self.grafana_folder_uid
        if self.latest_release_create_time is not None:
            result['LatestReleaseCreateTime'] = self.latest_release_create_time
        if self.managed_type is not None:
            result['ManagedType'] = self.managed_type
        if self.prometheus_id is not None:
            result['PrometheusId'] = self.prometheus_id
        if self.prometheus_instance_id is not None:
            result['PrometheusInstanceId'] = self.prometheus_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_count is not None:
            result['ReleaseCount'] = self.release_count
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.addons = []
        if m.get('Addons') is not None:
            for k in m.get('Addons'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironmentsAddons()
                self.addons.append(temp_model.from_map(k))
        if m.get('BindResourceId') is not None:
            self.bind_resource_id = m.get('BindResourceId')
        if m.get('BindResourceProfile') is not None:
            self.bind_resource_profile = m.get('BindResourceProfile')
        if m.get('BindResourceType') is not None:
            self.bind_resource_type = m.get('BindResourceType')
        if m.get('BindVpcCidr') is not None:
            self.bind_vpc_cidr = m.get('BindVpcCidr')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatedUserId') is not None:
            self.created_user_id = m.get('CreatedUserId')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('EnvironmentType') is not None:
            self.environment_type = m.get('EnvironmentType')
        self.features = []
        if m.get('Features') is not None:
            for k in m.get('Features'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironmentsFeatures()
                self.features.append(temp_model.from_map(k))
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('GrafanaDatasourceUid') is not None:
            self.grafana_datasource_uid = m.get('GrafanaDatasourceUid')
        if m.get('GrafanaFolderTitle') is not None:
            self.grafana_folder_title = m.get('GrafanaFolderTitle')
        if m.get('GrafanaFolderUid') is not None:
            self.grafana_folder_uid = m.get('GrafanaFolderUid')
        if m.get('LatestReleaseCreateTime') is not None:
            self.latest_release_create_time = m.get('LatestReleaseCreateTime')
        if m.get('ManagedType') is not None:
            self.managed_type = m.get('ManagedType')
        if m.get('PrometheusId') is not None:
            self.prometheus_id = m.get('PrometheusId')
        if m.get('PrometheusInstanceId') is not None:
            self.prometheus_instance_id = m.get('PrometheusInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseCount') is not None:
            self.release_count = m.get('ReleaseCount')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironmentsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListEnvironmentsResponseBodyData(TeaModel):
    def __init__(
        self,
        environments: List[ListEnvironmentsResponseBodyDataEnvironments] = None,
        total: int = None,
    ):
        # The queried environments.
        self.environments = environments
        # The total number of returned entries.
        self.total = total

    def validate(self):
        if self.environments:
            for k in self.environments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Environments'] = []
        if self.environments is not None:
            for k in self.environments:
                result['Environments'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.environments = []
        if m.get('Environments') is not None:
            for k in m.get('Environments'):
                temp_model = ListEnvironmentsResponseBodyDataEnvironments()
                self.environments.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEnvironmentsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListEnvironmentsResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListEnvironmentsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListEnvironmentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEnvironmentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEnvironmentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEscalationPoliciesRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page: int = None,
        size: int = None,
    ):
        # The name of the escalation policy.
        self.name = name
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        # The ID of the escalation policy.
        self.id = id
        # The name of the escalation policy.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEscalationPoliciesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        escalation_policies: List[ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The list of escalation policies.
        self.escalation_policies = escalation_policies
        # The page number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.size = size
        # The total number of returned entries.
        self.total = total

    def validate(self):
        if self.escalation_policies:
            for k in self.escalation_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EscalationPolicies'] = []
        if self.escalation_policies is not None:
            for k in self.escalation_policies:
                result['EscalationPolicies'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.escalation_policies = []
        if m.get('EscalationPolicies') is not None:
            for k in m.get('EscalationPolicies'):
                temp_model = ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies()
                self.escalation_policies.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEscalationPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: ListEscalationPoliciesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned objects.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = ListEscalationPoliciesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEscalationPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEscalationPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEscalationPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListEventBridgeIntegrationsRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page: int = None,
        size: int = None,
    ):
        # The name of the EventBridge integration.
        self.name = name
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
    ):
        # The description of the EventBridge integration.
        self.description = description
        # The ID of the EventBridge integration.
        self.id = id
        # The name of the EventBridge integration.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListEventBridgeIntegrationsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        event_bridge_integrations: List[ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The EventBridge integrations.
        self.event_bridge_integrations = event_bridge_integrations
        # The number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.size = size
        # The total number of EventBridge integrations that are returned.
        self.total = total

    def validate(self):
        if self.event_bridge_integrations:
            for k in self.event_bridge_integrations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventBridgeIntegrations'] = []
        if self.event_bridge_integrations is not None:
            for k in self.event_bridge_integrations:
                result['EventBridgeIntegrations'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_bridge_integrations = []
        if m.get('EventBridgeIntegrations') is not None:
            for k in m.get('EventBridgeIntegrations'):
                temp_model = ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations()
                self.event_bridge_integrations.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListEventBridgeIntegrationsResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: ListEventBridgeIntegrationsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The information about EventBridge integrations that is returned on each page.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = ListEventBridgeIntegrationsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListEventBridgeIntegrationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListEventBridgeIntegrationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListEventBridgeIntegrationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGrafanaWorkspaceRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListGrafanaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[ListGrafanaWorkspaceRequestTags] = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group to which the Prometheus instance belongs.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListGrafanaWorkspaceRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListGrafanaWorkspaceShrinkRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags_shrink: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group to which the Prometheus instance belongs.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class ListGrafanaWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[GrafanaWorkspace] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned result.
        self.data = data
        # The error message returned if the request parameters are invalid.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success
        # The trace ID that is used to query the details of the request.
        self.trace_id = trace_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GrafanaWorkspace()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class ListGrafanaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGrafanaWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGrafanaWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListInsightsEventsRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        insights_types: str = None,
        pid: str = None,
        region_id: str = None,
        start_time: str = None,
    ):
        # The end of the time range to query. The value is a timestamp.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The types of the events that you want to query. Separate multiple event types with commas (,). If you do not specify this parameter, all events are queried.
        # 
        # *   errorIncrease: API error-rate spike events. Examples: HTTP API error-rate spike events and Dubbo API error-rate spike events.
        # *   topErrorIncrease: the top five API error-rate spike events with the highest traffic.
        # *   topRtIncrease: API response-time spike events. Examples: HTTP API response-time spike events and Dubbo API response-time spike events.
        # *   rtIncrease: the top five API response-time spike events with the highest traffic.
        self.insights_types = insights_types
        # The ID of the application.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The start of the time range to query. The value is a timestamp.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.insights_types is not None:
            result['InsightsTypes'] = self.insights_types
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InsightsTypes') is not None:
            self.insights_types = m.get('InsightsTypes')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ListInsightsEventsResponseBodyInsightsEvents(TeaModel):
    def __init__(
        self,
        date: int = None,
        desc: str = None,
        level: str = None,
        pid: str = None,
        problem_id: str = None,
        title: str = None,
        type: str = None,
    ):
        # The time when the event occurred. The value is a timestamp.
        self.date = date
        # The description of the alert event.
        self.desc = desc
        # The severity of the event.
        self.level = level
        # The ID of the application associated with the event.
        self.pid = pid
        # The problem identifier.
        self.problem_id = problem_id
        # The title of the event.
        self.title = title
        # The type of the event.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.date is not None:
            result['Date'] = self.date
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.level is not None:
            result['Level'] = self.level
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.problem_id is not None:
            result['ProblemId'] = self.problem_id
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Date') is not None:
            self.date = m.get('Date')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('ProblemId') is not None:
            self.problem_id = m.get('ProblemId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListInsightsEventsResponseBody(TeaModel):
    def __init__(
        self,
        insights_events: List[ListInsightsEventsResponseBodyInsightsEvents] = None,
        request_id: str = None,
    ):
        # The details of the event.
        self.insights_events = insights_events
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.insights_events:
            for k in self.insights_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InsightsEvents'] = []
        if self.insights_events is not None:
            for k in self.insights_events:
                result['InsightsEvents'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.insights_events = []
        if m.get('InsightsEvents') is not None:
            for k in m.get('InsightsEvents'):
                temp_model = ListInsightsEventsResponseBodyInsightsEvents()
                self.insights_events.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListInsightsEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListInsightsEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListInsightsEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListIntegrationRequest(TeaModel):
    def __init__(
        self,
        integration_name: str = None,
        integration_product_type: str = None,
        is_detail: bool = None,
        page: int = None,
        size: int = None,
    ):
        # The name of the alert integration.
        self.integration_name = integration_name
        # The type of the alert integration. Valid values:
        # 
        # *   CLOUD_MONITOR: CloudMonitor
        # *   LOG_SERVICE: Log Service
        # 
        # This parameter is required.
        self.integration_product_type = integration_product_type
        # Specifies whether to display the details of each alert integration:
        # 
        # *   true
        # *   false
        self.is_detail = is_detail
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The number of alert integrations to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_product_type is not None:
            result['IntegrationProductType'] = self.integration_product_type
        if self.is_detail is not None:
            result['IsDetail'] = self.is_detail
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationProductType') is not None:
            self.integration_product_type = m.get('IntegrationProductType')
        if m.get('IsDetail') is not None:
            self.is_detail = m.get('IsDetail')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail(TeaModel):
    def __init__(
        self,
        auto_recover: bool = None,
        description: str = None,
        duplicate_key: str = None,
        extended_field_redefine_rules: List[Dict[str, Any]] = None,
        field_redefine_rules: List[Dict[str, Any]] = None,
        initiative_recover_field: str = None,
        initiative_recover_value: str = None,
        recover_time: int = None,
        stat: List[int] = None,
    ):
        # Indicates whether alert events are automatically cleared. Valid values:
        # 
        # *   true (default)
        # *   false
        self.auto_recover = auto_recover
        # The description of the alert integration.
        self.description = description
        # The fields whose values are deduplicated.
        self.duplicate_key = duplicate_key
        # The extended mapped fields of the alert source.
        self.extended_field_redefine_rules = extended_field_redefine_rules
        # The predefined mapped fields of the alert source.
        self.field_redefine_rules = field_redefine_rules
        # The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
        # 
        # > Only the Log Service alert integration supports the parameter.
        self.initiative_recover_field = initiative_recover_field
        # The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
        # 
        # > Only the Log Service alert integration supports the parameter.
        self.initiative_recover_value = initiative_recover_value
        # The time when alert events are automatically cleared. Unit: seconds. Default value: 300.
        self.recover_time = recover_time
        # The total number of alert events and the number of abnormal alert events in the last hour.
        self.stat = stat

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover is not None:
            result['AutoRecover'] = self.auto_recover
        if self.description is not None:
            result['Description'] = self.description
        if self.duplicate_key is not None:
            result['DuplicateKey'] = self.duplicate_key
        if self.extended_field_redefine_rules is not None:
            result['ExtendedFieldRedefineRules'] = self.extended_field_redefine_rules
        if self.field_redefine_rules is not None:
            result['FieldRedefineRules'] = self.field_redefine_rules
        if self.initiative_recover_field is not None:
            result['InitiativeRecoverField'] = self.initiative_recover_field
        if self.initiative_recover_value is not None:
            result['InitiativeRecoverValue'] = self.initiative_recover_value
        if self.recover_time is not None:
            result['RecoverTime'] = self.recover_time
        if self.stat is not None:
            result['Stat'] = self.stat
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRecover') is not None:
            self.auto_recover = m.get('AutoRecover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DuplicateKey') is not None:
            self.duplicate_key = m.get('DuplicateKey')
        if m.get('ExtendedFieldRedefineRules') is not None:
            self.extended_field_redefine_rules = m.get('ExtendedFieldRedefineRules')
        if m.get('FieldRedefineRules') is not None:
            self.field_redefine_rules = m.get('FieldRedefineRules')
        if m.get('InitiativeRecoverField') is not None:
            self.initiative_recover_field = m.get('InitiativeRecoverField')
        if m.get('InitiativeRecoverValue') is not None:
            self.initiative_recover_value = m.get('InitiativeRecoverValue')
        if m.get('RecoverTime') is not None:
            self.recover_time = m.get('RecoverTime')
        if m.get('Stat') is not None:
            self.stat = m.get('Stat')
        return self


class ListIntegrationResponseBodyPageInfoIntegrations(TeaModel):
    def __init__(
        self,
        api_endpoint: str = None,
        create_time: str = None,
        integration_detail: ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail = None,
        integration_id: int = None,
        integration_name: str = None,
        integration_product_type: str = None,
        liveness: str = None,
        short_token: str = None,
        state: bool = None,
    ):
        # The endpoint of the alert integration.
        self.api_endpoint = api_endpoint
        # The time when the alert integration was created.
        self.create_time = create_time
        # The information about the alert events.
        self.integration_detail = integration_detail
        # The ID of the alert integration.
        self.integration_id = integration_id
        # The name of the alert integration.
        self.integration_name = integration_name
        # The type of the alert integration. Valid values:
        # 
        # *   CLOUD_MONITOR: CloudMonitor
        # *   LOG_SERVICE: Log Service
        self.integration_product_type = integration_product_type
        # The activity of the alert integration
        self.liveness = liveness
        # The authentication token of the alert integration.
        self.short_token = short_token
        # Indicates whether the alert integration was enabled. Valid values:
        # 
        # *   true
        # *   false
        self.state = state

    def validate(self):
        if self.integration_detail:
            self.integration_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_endpoint is not None:
            result['ApiEndpoint'] = self.api_endpoint
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.integration_detail is not None:
            result['IntegrationDetail'] = self.integration_detail.to_map()
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_product_type is not None:
            result['IntegrationProductType'] = self.integration_product_type
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.short_token is not None:
            result['ShortToken'] = self.short_token
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiEndpoint') is not None:
            self.api_endpoint = m.get('ApiEndpoint')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('IntegrationDetail') is not None:
            temp_model = ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail()
            self.integration_detail = temp_model.from_map(m['IntegrationDetail'])
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationProductType') is not None:
            self.integration_product_type = m.get('IntegrationProductType')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('ShortToken') is not None:
            self.short_token = m.get('ShortToken')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListIntegrationResponseBodyPageInfo(TeaModel):
    def __init__(
        self,
        integrations: List[ListIntegrationResponseBodyPageInfoIntegrations] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The information about each alert integration.
        self.integrations = integrations
        # The page number of the returned page.
        self.page = page
        # The number of alert integrations returned per page.
        self.size = size
        # The total number of alert integrations.
        self.total = total

    def validate(self):
        if self.integrations:
            for k in self.integrations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Integrations'] = []
        if self.integrations is not None:
            for k in self.integrations:
                result['Integrations'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.integrations = []
        if m.get('Integrations') is not None:
            for k in m.get('Integrations'):
                temp_model = ListIntegrationResponseBodyPageInfoIntegrations()
                self.integrations.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        page_info: ListIntegrationResponseBodyPageInfo = None,
        request_id: str = None,
    ):
        # The pagination information.
        self.page_info = page_info
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_info:
            self.page_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_info is not None:
            result['PageInfo'] = self.page_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageInfo') is not None:
            temp_model = ListIntegrationResponseBodyPageInfo()
            self.page_info = temp_model.from_map(m['PageInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListNotificationPoliciesRequest(TeaModel):
    def __init__(
        self,
        directed_mode: bool = None,
        ids: str = None,
        is_detail: bool = None,
        name: str = None,
        page: int = None,
        region_id: str = None,
        size: int = None,
    ):
        # Specifies whether to enable simple mode.
        self.directed_mode = directed_mode
        # The ID of the notification policy.
        self.ids = ids
        # Specifies whether to query the details about notification policies. Valid values:
        # 
        # *   `true`: Details about notification policies are queried.
        # *   `false`: Details about notification policies are not queried.
        self.is_detail = is_detail
        # The name of the notification policy.
        self.name = name
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The ID of the region. Default value: **cn-hangzhou**.
        self.region_id = region_id
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directed_mode is not None:
            result['DirectedMode'] = self.directed_mode
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.is_detail is not None:
            result['IsDetail'] = self.is_detail
        if self.name is not None:
            result['Name'] = self.name
        if self.page is not None:
            result['Page'] = self.page
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DirectedMode') is not None:
            self.directed_mode = m.get('DirectedMode')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('IsDetail') is not None:
            self.is_detail = m.get('IsDetail')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule(TeaModel):
    def __init__(
        self,
        group_interval: int = None,
        group_wait: int = None,
        grouping_fields: List[str] = None,
    ):
        # The time interval of grouping. Unit: seconds. Default value: 30.
        self.group_interval = group_interval
        # The waiting time for grouping. Unit: seconds. Default value: 5.
        self.group_wait = group_wait
        # An array of alert event group objects.
        # 
        # *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
        # *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
        self.grouping_fields = grouping_fields

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_interval is not None:
            result['GroupInterval'] = self.group_interval
        if self.group_wait is not None:
            result['GroupWait'] = self.group_wait
        if self.grouping_fields is not None:
            result['GroupingFields'] = self.grouping_fields
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupInterval') is not None:
            self.group_interval = m.get('GroupInterval')
        if m.get('GroupWait') is not None:
            self.group_wait = m.get('GroupWait')
        if m.get('GroupingFields') is not None:
            self.grouping_fields = m.get('GroupingFields')
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The key of the matching condition.
        self.key = key
        # The logical operator of the matching condition. Valid values:
        # 
        # *   `eq`: equal to
        # *   `neq`: not equal to
        # *   `in`: contains
        # *   `nin`: does not contain
        # *   `re`: regular expression match
        # *   `nre`: regular expression mismatch
        self.operator = operator
        # The value of the matching condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules(TeaModel):
    def __init__(
        self,
        matching_conditions: List[ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions] = None,
    ):
        # The matching conditions.
        self.matching_conditions = matching_conditions

    def validate(self):
        if self.matching_conditions:
            for k in self.matching_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MatchingConditions'] = []
        if self.matching_conditions is not None:
            for k in self.matching_conditions:
                result['MatchingConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.matching_conditions = []
        if m.get('MatchingConditions') is not None:
            for k in m.get('MatchingConditions'):
                temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions()
                self.matching_conditions.append(temp_model.from_map(k))
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects(TeaModel):
    def __init__(
        self,
        notify_channels: List[str] = None,
        notify_object_id: int = None,
        notify_object_name: str = None,
        notify_object_type: str = None,
    ):
        # The notification methods specified for a contact.
        self.notify_channels = notify_channels
        # The ID of the notification object.
        self.notify_object_id = notify_object_id
        # The name of the notification object.
        self.notify_object_name = notify_object_name
        # The type of the notification object. Valid values:
        # 
        # - CONTACT: an individual contact
        # - CONTACT_GROUP: a contact group
        # - DING_ROBOT: an instant messaging (IM) chatbot
        # - CONTACT_SCHEDULE: a person on duty based on an established schedule
        self.notify_object_type = notify_object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_channels is not None:
            result['NotifyChannels'] = self.notify_channels
        if self.notify_object_id is not None:
            result['NotifyObjectId'] = self.notify_object_id
        if self.notify_object_name is not None:
            result['NotifyObjectName'] = self.notify_object_name
        if self.notify_object_type is not None:
            result['NotifyObjectType'] = self.notify_object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotifyChannels') is not None:
            self.notify_channels = m.get('NotifyChannels')
        if m.get('NotifyObjectId') is not None:
            self.notify_object_id = m.get('NotifyObjectId')
        if m.get('NotifyObjectName') is not None:
            self.notify_object_name = m.get('NotifyObjectName')
        if m.get('NotifyObjectType') is not None:
            self.notify_object_type = m.get('NotifyObjectType')
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule(TeaModel):
    def __init__(
        self,
        notify_channels: List[str] = None,
        notify_end_time: str = None,
        notify_objects: List[ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects] = None,
        notify_start_time: str = None,
    ):
        # The notification method.
        self.notify_channels = notify_channels
        # The end time of the notification window.
        self.notify_end_time = notify_end_time
        # The notification objects.
        self.notify_objects = notify_objects
        # The start time of the notification window.
        self.notify_start_time = notify_start_time

    def validate(self):
        if self.notify_objects:
            for k in self.notify_objects:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.notify_channels is not None:
            result['NotifyChannels'] = self.notify_channels
        if self.notify_end_time is not None:
            result['NotifyEndTime'] = self.notify_end_time
        result['NotifyObjects'] = []
        if self.notify_objects is not None:
            for k in self.notify_objects:
                result['NotifyObjects'].append(k.to_map() if k else None)
        if self.notify_start_time is not None:
            result['NotifyStartTime'] = self.notify_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('NotifyChannels') is not None:
            self.notify_channels = m.get('NotifyChannels')
        if m.get('NotifyEndTime') is not None:
            self.notify_end_time = m.get('NotifyEndTime')
        self.notify_objects = []
        if m.get('NotifyObjects') is not None:
            for k in m.get('NotifyObjects'):
                temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects()
                self.notify_objects.append(temp_model.from_map(k))
        if m.get('NotifyStartTime') is not None:
            self.notify_start_time = m.get('NotifyStartTime')
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate(TeaModel):
    def __init__(
        self,
        email_content: str = None,
        email_recover_content: str = None,
        email_recover_title: str = None,
        email_title: str = None,
        robot_content: str = None,
        sms_content: str = None,
        sms_recover_content: str = None,
        tts_content: str = None,
        tts_recover_content: str = None,
    ):
        # The content of the alert notification sent by email.
        self.email_content = email_content
        # The content of the alert resolution notification sent by email.
        self.email_recover_content = email_recover_content
        # The title of the alert resolution notification sent by email.
        self.email_recover_title = email_recover_title
        # The title of the alert notification sent by email.
        self.email_title = email_title
        # The content of the alert notification sent by an IM chatbot.
        self.robot_content = robot_content
        # The content of the alert notification sent by text message.
        self.sms_content = sms_content
        # The content of the alert resolution notification sent by text message.
        self.sms_recover_content = sms_recover_content
        # The content of the alert notification sent by phone.
        self.tts_content = tts_content
        # The content of the alert resolution notification sent by phone.
        self.tts_recover_content = tts_recover_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email_content is not None:
            result['EmailContent'] = self.email_content
        if self.email_recover_content is not None:
            result['EmailRecoverContent'] = self.email_recover_content
        if self.email_recover_title is not None:
            result['EmailRecoverTitle'] = self.email_recover_title
        if self.email_title is not None:
            result['EmailTitle'] = self.email_title
        if self.robot_content is not None:
            result['RobotContent'] = self.robot_content
        if self.sms_content is not None:
            result['SmsContent'] = self.sms_content
        if self.sms_recover_content is not None:
            result['SmsRecoverContent'] = self.sms_recover_content
        if self.tts_content is not None:
            result['TtsContent'] = self.tts_content
        if self.tts_recover_content is not None:
            result['TtsRecoverContent'] = self.tts_recover_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EmailContent') is not None:
            self.email_content = m.get('EmailContent')
        if m.get('EmailRecoverContent') is not None:
            self.email_recover_content = m.get('EmailRecoverContent')
        if m.get('EmailRecoverTitle') is not None:
            self.email_recover_title = m.get('EmailRecoverTitle')
        if m.get('EmailTitle') is not None:
            self.email_title = m.get('EmailTitle')
        if m.get('RobotContent') is not None:
            self.robot_content = m.get('RobotContent')
        if m.get('SmsContent') is not None:
            self.sms_content = m.get('SmsContent')
        if m.get('SmsRecoverContent') is not None:
            self.sms_recover_content = m.get('SmsRecoverContent')
        if m.get('TtsContent') is not None:
            self.tts_content = m.get('TtsContent')
        if m.get('TtsRecoverContent') is not None:
            self.tts_recover_content = m.get('TtsRecoverContent')
        return self


class ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies(TeaModel):
    def __init__(
        self,
        directed_mode: bool = None,
        escalation_policy_id: int = None,
        group_rule: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule = None,
        id: int = None,
        integration_id: int = None,
        matching_rules: List[ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules] = None,
        name: str = None,
        notify_rule: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule = None,
        notify_template: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate = None,
        repeat: bool = None,
        repeat_interval: int = None,
        send_recover_message: bool = None,
        state: str = None,
    ):
        # Indicates whether simple mode is enabled.
        self.directed_mode = directed_mode
        # The ID of the escalation policy.
        self.escalation_policy_id = escalation_policy_id
        # The grouping rule for alert events.
        self.group_rule = group_rule
        # The ID of the notification policy.
        self.id = id
        # The integration ID of the ticket system to which alerts are pushed.
        self.integration_id = integration_id
        # The matching rules for alert events.
        self.matching_rules = matching_rules
        # The name of the notification policy.
        self.name = name
        # The notification rule.
        self.notify_rule = notify_rule
        # The notification template.
        self.notify_template = notify_template
        # Indicates whether the system resends notifications for a long-lasting unresolved alert. Valid values:
        # 
        # - `true` (default): The system resends notifications for a long-lasting unresolved alert at a specified time interval.
        # - `false`: The system resends notifications for a long-lasting unresolved alert based on an escalation policy.
        self.repeat = repeat
        # The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
        self.repeat_interval = repeat_interval
        # Indicates whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. The system sends a notification to the alert contacts when the alert status changes to Resolved.
        # 
        # - `true` (default): The system sends a notification.
        # - `false`: The system does not send a notification.
        self.send_recover_message = send_recover_message
        # Indicates whether the notification policy is enabled. Valid values: enable and disable.
        self.state = state

    def validate(self):
        if self.group_rule:
            self.group_rule.validate()
        if self.matching_rules:
            for k in self.matching_rules:
                if k:
                    k.validate()
        if self.notify_rule:
            self.notify_rule.validate()
        if self.notify_template:
            self.notify_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directed_mode is not None:
            result['DirectedMode'] = self.directed_mode
        if self.escalation_policy_id is not None:
            result['EscalationPolicyId'] = self.escalation_policy_id
        if self.group_rule is not None:
            result['GroupRule'] = self.group_rule.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        result['MatchingRules'] = []
        if self.matching_rules is not None:
            for k in self.matching_rules:
                result['MatchingRules'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.notify_rule is not None:
            result['NotifyRule'] = self.notify_rule.to_map()
        if self.notify_template is not None:
            result['NotifyTemplate'] = self.notify_template.to_map()
        if self.repeat is not None:
            result['Repeat'] = self.repeat
        if self.repeat_interval is not None:
            result['RepeatInterval'] = self.repeat_interval
        if self.send_recover_message is not None:
            result['SendRecoverMessage'] = self.send_recover_message
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DirectedMode') is not None:
            self.directed_mode = m.get('DirectedMode')
        if m.get('EscalationPolicyId') is not None:
            self.escalation_policy_id = m.get('EscalationPolicyId')
        if m.get('GroupRule') is not None:
            temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule()
            self.group_rule = temp_model.from_map(m['GroupRule'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        self.matching_rules = []
        if m.get('MatchingRules') is not None:
            for k in m.get('MatchingRules'):
                temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules()
                self.matching_rules.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NotifyRule') is not None:
            temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule()
            self.notify_rule = temp_model.from_map(m['NotifyRule'])
        if m.get('NotifyTemplate') is not None:
            temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate()
            self.notify_template = temp_model.from_map(m['NotifyTemplate'])
        if m.get('Repeat') is not None:
            self.repeat = m.get('Repeat')
        if m.get('RepeatInterval') is not None:
            self.repeat_interval = m.get('RepeatInterval')
        if m.get('SendRecoverMessage') is not None:
            self.send_recover_message = m.get('SendRecoverMessage')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class ListNotificationPoliciesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        notification_policies: List[ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The queried notification policies.
        self.notification_policies = notification_policies
        # The number of the page returned.
        self.page = page
        # The number of entries that are returned on each page.
        self.size = size
        # The number of notification policies that are returned.
        self.total = total

    def validate(self):
        if self.notification_policies:
            for k in self.notification_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotificationPolicies'] = []
        if self.notification_policies is not None:
            for k in self.notification_policies:
                result['NotificationPolicies'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.notification_policies = []
        if m.get('NotificationPolicies') is not None:
            for k in m.get('NotificationPolicies'):
                temp_model = ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies()
                self.notification_policies.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListNotificationPoliciesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: ListNotificationPoliciesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned pages.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = ListNotificationPoliciesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListNotificationPoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListNotificationPoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListNotificationPoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOnCallSchedulesRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        page: int = None,
        size: int = None,
    ):
        # The name of the scheduling policy.
        self.name = name
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: int = None,
        name: str = None,
    ):
        # The description of the scheduling policy.
        self.description = description
        # The ID of the scheduling policy.
        self.id = id
        # The name of the scheduling policy.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ListOnCallSchedulesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        on_call_schedules: List[ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules] = None,
        page: int = None,
        size: int = None,
        total: int = None,
    ):
        # The information about the scheduling policy.
        self.on_call_schedules = on_call_schedules
        # The page number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.size = size
        # The total number of returned entries.
        self.total = total

    def validate(self):
        if self.on_call_schedules:
            for k in self.on_call_schedules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OnCallSchedules'] = []
        if self.on_call_schedules is not None:
            for k in self.on_call_schedules:
                result['OnCallSchedules'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.on_call_schedules = []
        if m.get('OnCallSchedules') is not None:
            for k in m.get('OnCallSchedules'):
                temp_model = ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules()
                self.on_call_schedules.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListOnCallSchedulesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: ListOnCallSchedulesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The objects that were returned.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = ListOnCallSchedulesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListOnCallSchedulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOnCallSchedulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOnCallSchedulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusAlertRulesRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusAlertRulesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        match_expressions: str = None,
        name: str = None,
        region_id: str = None,
        status: int = None,
        tags: List[ListPrometheusAlertRulesRequestTags] = None,
        type: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The tag match conditions that are described in a JSON string. For more information about this parameter, see the **Additional description of the MatchExpressions parameter** section.
        self.match_expressions = match_expressions
        # The name of the alert rule.
        self.name = name
        # The region ID of the instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether the alert rule is enabled. Valid values:
        # 
        # - 1: enables the alert rule.
        # - 0: disables the alert rule.
        self.status = status
        # The tags.
        self.tags = tags
        # The type of the alert rule.
        self.type = type

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.match_expressions is not None:
            result['MatchExpressions'] = self.match_expressions
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MatchExpressions') is not None:
            self.match_expressions = m.get('MatchExpressions')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListPrometheusAlertRulesRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the annotation.
        self.name = name
        # The value of the annotation.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the tag.
        self.name = name
        # The value of the tag associated with the instance.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusAlertRulesResponseBodyPrometheusAlertRules(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_name: str = None,
        annotations: List[ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations] = None,
        cluster_id: str = None,
        dispatch_rule_id: int = None,
        duration: str = None,
        expression: str = None,
        labels: List[ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels] = None,
        message: str = None,
        notify_type: str = None,
        status: int = None,
        tags: List[ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags] = None,
        type: str = None,
    ):
        # The ID of the alert rule.
        self.alert_id = alert_id
        # The name of the alert rule.
        self.alert_name = alert_name
        # The annotations of the alert rule.
        self.annotations = annotations
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The ID of the notification policy. This parameter is returned if the NotifyType parameter is set to `DISPATCH_RULE`.
        self.dispatch_rule_id = dispatch_rule_id
        # The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
        self.duration = duration
        # The expression of the alert rule.
        self.expression = expression
        # The tags of the alert rule.
        self.labels = labels
        # The alert message. Tags can be referenced in the {{$labels.xxx}} format.
        self.message = message
        # The method that is used to send alert notifications. Valid values:
        # 
        # - ALERT_MANAGER: Alert notifications are sent by Operation Center.
        # - DISPATCH_RULE: Alert notifications are
        self.notify_type = notify_type
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # - 1: The alert rule is enabled.
        # - 0: The alert rule is disabled.
        self.status = status
        # The tags.
        self.tags = tags
        # The type of the alert rule.
        self.type = type

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPrometheusAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        prometheus_alert_rules: List[ListPrometheusAlertRulesResponseBodyPrometheusAlertRules] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned message.
        self.message = message
        # The returned struct.
        self.prometheus_alert_rules = prometheus_alert_rules
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        if self.prometheus_alert_rules:
            for k in self.prometheus_alert_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        result['PrometheusAlertRules'] = []
        if self.prometheus_alert_rules is not None:
            for k in self.prometheus_alert_rules:
                result['PrometheusAlertRules'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        self.prometheus_alert_rules = []
        if m.get('PrometheusAlertRules') is not None:
            for k in m.get('PrometheusAlertRules'):
                temp_model = ListPrometheusAlertRulesResponseBodyPrometheusAlertRules()
                self.prometheus_alert_rules.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListPrometheusAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusAlertTemplatesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The ID of the cluster.
        self.cluster_id = cluster_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the annotation.
        self.name = name
        # The value of the annotation.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # The name of the tag.
        self.name = name
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates(TeaModel):
    def __init__(
        self,
        alert_name: str = None,
        annotations: List[ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations] = None,
        description: str = None,
        duration: str = None,
        expression: str = None,
        labels: List[ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels] = None,
        type: str = None,
        version: str = None,
    ):
        # The name of the alert rule.
        self.alert_name = alert_name
        # The annotations of the alert rule.
        self.annotations = annotations
        # The content of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.
        self.description = description
        # The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
        self.duration = duration
        # The expression of the alert rule.
        self.expression = expression
        # The tags of the alert rule.
        self.labels = labels
        # The type of the alert rule.
        self.type = type
        # The version of the alert rule.
        self.version = version

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListPrometheusAlertTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        prometheus_alert_templates: List[ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates] = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.prometheus_alert_templates = prometheus_alert_templates
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.prometheus_alert_templates:
            for k in self.prometheus_alert_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrometheusAlertTemplates'] = []
        if self.prometheus_alert_templates is not None:
            for k in self.prometheus_alert_templates:
                result['PrometheusAlertTemplates'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.prometheus_alert_templates = []
        if m.get('PrometheusAlertTemplates') is not None:
            for k in m.get('PrometheusAlertTemplates'):
                temp_model = ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates()
                self.prometheus_alert_templates.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrometheusAlertTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusAlertTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusAlertTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. Description 200 means success.
        self.code = code
        # The list of global aggregation instances. The value of this parameter is a string in the JSON format.
        self.data = data
        # More information.
        self.message = message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        tag: List[ListPrometheusInstanceByTagAndResourceGroupIdRequestTag] = None,
    ):
        # The region ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListPrometheusInstanceByTagAndResourceGroupIdRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The tag key.
        self.tag_key = tag_key
        # The tag value.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_id: str = None,
        cluster_name: str = None,
        cluster_type: str = None,
        grafana_instance_id: str = None,
        http_api_inter_url: str = None,
        http_api_intra_url: str = None,
        payment_type: str = None,
        push_gateway_inter_url: str = None,
        push_gateway_intra_url: str = None,
        region_id: str = None,
        remote_read_inter_url: str = None,
        remote_read_intra_url: str = None,
        remote_write_inter_url: str = None,
        remote_write_intra_url: str = None,
        resource_group_id: str = None,
        resource_type: str = None,
        security_group_id: str = None,
        sub_clusters_json: str = None,
        tags: List[ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags] = None,
        user_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The authorization token.
        self.auth_token = auth_token
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The name of the Prometheus instance.
        self.cluster_name = cluster_name
        # The instance type. Valid values:
        # 
        # *   remote-write: Prometheus instance for Remote Write
        # *   ecs: Prometheus instances for ECS
        # *   cloud-monitor: Prometheus instance for Alibaba Cloud services in the Chinese mainland
        # *   cloud-product: Prometheus instance for Alibaba Cloud services outside the Chinese mainland
        # *   global-view: global aggregation instance
        # *   aliyun-cs: Prometheus instance for Container Service
        self.cluster_type = cluster_type
        # The ID of the Grafana workspace.
        self.grafana_instance_id = grafana_instance_id
        # The public URL for the HTTP API.
        self.http_api_inter_url = http_api_inter_url
        # The internal URL for the HTTP API.
        self.http_api_intra_url = http_api_intra_url
        # The billing method. Valid values:
        # 
        # *   PREPAY: subscription
        # *   POSTPAY: pay-as-you-go
        self.payment_type = payment_type
        # The public URL for Pushgateway.
        self.push_gateway_inter_url = push_gateway_inter_url
        # The internal URL for Pushgateway.
        self.push_gateway_intra_url = push_gateway_intra_url
        # The region ID.
        self.region_id = region_id
        # The public URL for remote read.
        self.remote_read_inter_url = remote_read_inter_url
        # The internal URL for remote read.
        self.remote_read_intra_url = remote_read_intra_url
        # The public URL for remote write.
        self.remote_write_inter_url = remote_write_inter_url
        # The internal URL for remote write.
        self.remote_write_intra_url = remote_write_intra_url
        # The ID of the resource group to which the Prometheus instance belongs.
        self.resource_group_id = resource_group_id
        # The resource type.
        self.resource_type = resource_type
        # The ID of the security group.
        self.security_group_id = security_group_id
        # The child instances of the global aggregation instance. The value is a JSON string.
        self.sub_clusters_json = sub_clusters_json
        # The list of tags.
        self.tags = tags
        # The ID of the user.
        self.user_id = user_id
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['AuthToken'] = self.auth_token
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_name is not None:
            result['ClusterName'] = self.cluster_name
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.grafana_instance_id is not None:
            result['GrafanaInstanceId'] = self.grafana_instance_id
        if self.http_api_inter_url is not None:
            result['HttpApiInterUrl'] = self.http_api_inter_url
        if self.http_api_intra_url is not None:
            result['HttpApiIntraUrl'] = self.http_api_intra_url
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.push_gateway_inter_url is not None:
            result['PushGatewayInterUrl'] = self.push_gateway_inter_url
        if self.push_gateway_intra_url is not None:
            result['PushGatewayIntraUrl'] = self.push_gateway_intra_url
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remote_read_inter_url is not None:
            result['RemoteReadInterUrl'] = self.remote_read_inter_url
        if self.remote_read_intra_url is not None:
            result['RemoteReadIntraUrl'] = self.remote_read_intra_url
        if self.remote_write_inter_url is not None:
            result['RemoteWriteInterUrl'] = self.remote_write_inter_url
        if self.remote_write_intra_url is not None:
            result['RemoteWriteIntraUrl'] = self.remote_write_intra_url
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.sub_clusters_json is not None:
            result['SubClustersJson'] = self.sub_clusters_json
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthToken') is not None:
            self.auth_token = m.get('AuthToken')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterName') is not None:
            self.cluster_name = m.get('ClusterName')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('GrafanaInstanceId') is not None:
            self.grafana_instance_id = m.get('GrafanaInstanceId')
        if m.get('HttpApiInterUrl') is not None:
            self.http_api_inter_url = m.get('HttpApiInterUrl')
        if m.get('HttpApiIntraUrl') is not None:
            self.http_api_intra_url = m.get('HttpApiIntraUrl')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('PushGatewayInterUrl') is not None:
            self.push_gateway_inter_url = m.get('PushGatewayInterUrl')
        if m.get('PushGatewayIntraUrl') is not None:
            self.push_gateway_intra_url = m.get('PushGatewayIntraUrl')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoteReadInterUrl') is not None:
            self.remote_read_inter_url = m.get('RemoteReadInterUrl')
        if m.get('RemoteReadIntraUrl') is not None:
            self.remote_read_intra_url = m.get('RemoteReadIntraUrl')
        if m.get('RemoteWriteInterUrl') is not None:
            self.remote_write_inter_url = m.get('RemoteWriteInterUrl')
        if m.get('RemoteWriteIntraUrl') is not None:
            self.remote_write_intra_url = m.get('RemoteWriteIntraUrl')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SubClustersJson') is not None:
            self.sub_clusters_json = m.get('SubClustersJson')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData(TeaModel):
    def __init__(
        self,
        prometheus_instances: List[ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances] = None,
    ):
        # The queried Prometheus instances.
        self.prometheus_instances = prometheus_instances

    def validate(self):
        if self.prometheus_instances:
            for k in self.prometheus_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrometheusInstances'] = []
        if self.prometheus_instances is not None:
            for k in self.prometheus_instances:
                result['PrometheusInstances'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.prometheus_instances = []
        if m.get('PrometheusInstances') is not None:
            for k in m.get('PrometheusInstances'):
                temp_model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances()
                self.prometheus_instances.append(temp_model.from_map(k))
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The response code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrometheusInstanceByTagAndResourceGroupIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusInstanceByTagAndResourceGroupIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusInstancesRequest(TeaModel):
    def __init__(
        self,
        cluster_type: str = None,
        region_id: str = None,
        show_global_view: bool = None,
    ):
        # The cluster type. If you do not specify this parameter, all cluster types are queried. Valid values:
        # 
        # *   cloud-product-prometheus: Prometheus instance for cloud services
        # *   ManagedKubernetes: ACK managed cluster
        # *   satellite: Prometheus instance for ARMS OpenTelemetry
        # *   Ask: ACK Serverless cluster
        # *   remote-write-prometheus: general-purpose Prometheus instance
        # *   cloud-monitor-cmee: Hybrid Cloud Monitoring
        # *   ExternalKubernetes: external Kubernetes cluster registered in ACK
        # *   vpc-prometheus: Prometheus instance for ECS
        # *   cloud-monitor-direct: cloud service self-monitoring
        # *   Edge Kubernetes: ACK Edge cluster
        self.cluster_type = cluster_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether to obtain global aggregation instances. Valid values:
        # 
        # *   true
        # *   false
        # 
        # This parameter is required.
        self.show_global_view = show_global_view

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_global_view is not None:
            result['ShowGlobalView'] = self.show_global_view
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowGlobalView') is not None:
            self.show_global_view = m.get('ShowGlobalView')
        return self


class ListPrometheusInstancesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code.
        self.code = code
        # The Prometheus instances in the region in the JSON format.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrometheusInstancesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusInstancesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        integration_type: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance. Only aliyun-cs and ecs instances are supported.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
        # 
        # This parameter is required.
        self.integration_type = integration_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListPrometheusIntegrationResponseBodyData(TeaModel):
    def __init__(
        self,
        can_delete: bool = None,
        can_editor: bool = None,
        cluster_id: str = None,
        container_name: str = None,
        describe: str = None,
        exporter_type: str = None,
        instance_id: int = None,
        instance_name: str = None,
        integration_type: str = None,
        namespace: str = None,
        need_upgrade: bool = None,
        param: str = None,
        pod_name: str = None,
        show_describe: bool = None,
        show_log: bool = None,
        status: str = None,
        target: str = None,
        version: str = None,
    ):
        # Indicates whether the exporter can be deleted.
        self.can_delete = can_delete
        # Indicates whether the exporter can be edited.
        self.can_editor = can_editor
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The name of the container.
        self.container_name = container_name
        # The description of the exporter.
        self.describe = describe
        # The type of the exporter.
        self.exporter_type = exporter_type
        # The ID of the exporter.
        self.instance_id = instance_id
        # The name of the exporter.
        self.instance_name = instance_name
        # The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
        self.integration_type = integration_type
        # The namespace.
        self.namespace = namespace
        # Indicates whether an upgrade is required.
        self.need_upgrade = need_upgrade
        # The configurations of the exporter. The value is a JSON string.
        self.param = param
        # The pod name of the exporter.
        self.pod_name = pod_name
        # Indicates whether the description is displayed.
        self.show_describe = show_describe
        # Indicates whether the exporter logs are displayed.
        self.show_log = show_log
        # The status of the exporter.
        self.status = status
        # The monitored IP address.
        self.target = target
        # The version number.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.can_delete is not None:
            result['CanDelete'] = self.can_delete
        if self.can_editor is not None:
            result['CanEditor'] = self.can_editor
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.exporter_type is not None:
            result['ExporterType'] = self.exporter_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.need_upgrade is not None:
            result['NeedUpgrade'] = self.need_upgrade
        if self.param is not None:
            result['Param'] = self.param
        if self.pod_name is not None:
            result['PodName'] = self.pod_name
        if self.show_describe is not None:
            result['ShowDescribe'] = self.show_describe
        if self.show_log is not None:
            result['ShowLog'] = self.show_log
        if self.status is not None:
            result['Status'] = self.status
        if self.target is not None:
            result['Target'] = self.target
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CanDelete') is not None:
            self.can_delete = m.get('CanDelete')
        if m.get('CanEditor') is not None:
            self.can_editor = m.get('CanEditor')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('ExporterType') is not None:
            self.exporter_type = m.get('ExporterType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NeedUpgrade') is not None:
            self.need_upgrade = m.get('NeedUpgrade')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('PodName') is not None:
            self.pod_name = m.get('PodName')
        if m.get('ShowDescribe') is not None:
            self.show_describe = m.get('ShowDescribe')
        if m.get('ShowLog') is not None:
            self.show_log = m.get('ShowLog')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class ListPrometheusIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListPrometheusIntegrationResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The response code. The status code 200 indicates that the request was successful.
        self.code = code
        # The queried exporters.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListPrometheusIntegrationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrometheusIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPrometheusMonitoringRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID. Default value: `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the monitoring configuration. Valid values for a Prometheus instance for Container Service: ServiceMonitor, PodMonitor, CustomJob, and Probe. Valid values for a Prometheus instance for ECS: CustomJob and Probe.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPrometheusMonitoringResponseBodyData(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        config_yaml: str = None,
        monitoring_name: str = None,
        status: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The monitoring configuration. The value is a YAML string.
        self.config_yaml = config_yaml
        # The name of the monitoring configuration.
        self.monitoring_name = monitoring_name
        # The status of the monitoring configuration.
        self.status = status
        # The type of the monitoring configuration.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.monitoring_name is not None:
            result['MonitoringName'] = self.monitoring_name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('MonitoringName') is not None:
            self.monitoring_name = m.get('MonitoringName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListPrometheusMonitoringResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: List[ListPrometheusMonitoringResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListPrometheusMonitoringResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPrometheusMonitoringResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPrometheusMonitoringResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPrometheusMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRetcodeAppsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListRetcodeAppsRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[ListRetcodeAppsRequestTags] = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
        self.resource_group_id = resource_group_id
        # The tags that you want to add to the task.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListRetcodeAppsRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListRetcodeAppsResponseBodyRetcodeAppsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListRetcodeAppsResponseBodyRetcodeApps(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        app_name: str = None,
        nick_name: str = None,
        pid: str = None,
        resource_group_id: str = None,
        retcode_app_type: str = None,
        tags: List[ListRetcodeAppsResponseBodyRetcodeAppsTags] = None,
    ):
        # The ID of the application. The parameter is an auto-increment parameter.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The alias of the application monitored by Browser Monitoring.
        self.nick_name = nick_name
        # The process identifier (PID) of the application.
        self.pid = pid
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The type of the application. Valid values:
        # 
        # *   `web`: web application
        # *   `weex`: Weex mobile app
        # *   `mini_dd`: DingTalk mini program
        # *   `mini_alipay`: Alipay mini program
        # *   `mini_wx`: WeChat mini program
        # *   `mini_common`: mini program on other platforms
        self.retcode_app_type = retcode_app_type
        # The tags of the task.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retcode_app_type is not None:
            result['RetcodeAppType'] = self.retcode_app_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetcodeAppType') is not None:
            self.retcode_app_type = m.get('RetcodeAppType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListRetcodeAppsResponseBodyRetcodeAppsTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListRetcodeAppsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        retcode_apps: List[ListRetcodeAppsResponseBodyRetcodeApps] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The list of applications monitored by Browser Monitoring.
        self.retcode_apps = retcode_apps

    def validate(self):
        if self.retcode_apps:
            for k in self.retcode_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RetcodeApps'] = []
        if self.retcode_apps is not None:
            for k in self.retcode_apps:
                result['RetcodeApps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.retcode_apps = []
        if m.get('RetcodeApps') is not None:
            for k in m.get('RetcodeApps'):
                temp_model = ListRetcodeAppsResponseBodyRetcodeApps()
                self.retcode_apps.append(temp_model.from_map(k))
        return self


class ListRetcodeAppsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRetcodeAppsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRetcodeAppsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListScenarioRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        name: str = None,
        region_id: str = None,
        scenario: str = None,
        sign: str = None,
    ):
        # The ID of the application.
        # 
        # This parameter is required.
        self.app_id = app_id
        # The name of the business monitoring job.
        # 
        # This parameter is required.
        self.name = name
        # The ID of the region.
        self.region_id = region_id
        # The scenario where the business monitoring job is used. Valid values:
        # 
        # *   `USER-DEFINED`: user-defined. This is the default value.
        # *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
        # *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
        # *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
        self.scenario = scenario
        # The code of the business monitoring job. Set this parameter when you know the code of the business monitoring job you want to query.
        self.sign = sign

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scenario is not None:
            result['Scenario'] = self.scenario
        if self.sign is not None:
            result['Sign'] = self.sign
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scenario') is not None:
            self.scenario = m.get('Scenario')
        if m.get('Sign') is not None:
            self.sign = m.get('Sign')
        return self


class ListScenarioResponseBodyArmsScenarios(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        create_time: str = None,
        extensions: str = None,
        id: int = None,
        name: str = None,
        region_id: str = None,
        sign: str = None,
        update_time: str = None,
        user_id: str = None,
    ):
        # The ID of the application.
        self.app_id = app_id
        # The time when the business monitoring job was created.
        self.create_time = create_time
        # The extended information. The value is a JSON string.
        self.extensions = extensions
        # The ID of the business monitoring job.
        self.id = id
        # The name of the business monitoring job.
        self.name = name
        # The ID of the region.
        self.region_id = region_id
        # The code of the business monitoring job.
        self.sign = sign
        # The time when the business monitoring job was updated.
        self.update_time = update_time
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.extensions is not None:
            result['Extensions'] = self.extensions
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sign is not None:
            result['Sign'] = self.sign
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Extensions') is not None:
            self.extensions = m.get('Extensions')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Sign') is not None:
            self.sign = m.get('Sign')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListScenarioResponseBody(TeaModel):
    def __init__(
        self,
        arms_scenarios: List[ListScenarioResponseBodyArmsScenarios] = None,
        request_id: str = None,
    ):
        # The detailed information of the business monitoring job.
        self.arms_scenarios = arms_scenarios
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.arms_scenarios:
            for k in self.arms_scenarios:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ArmsScenarios'] = []
        if self.arms_scenarios is not None:
            for k in self.arms_scenarios:
                result['ArmsScenarios'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.arms_scenarios = []
        if m.get('ArmsScenarios') is not None:
            for k in m.get('ArmsScenarios'):
                temp_model = ListScenarioResponseBodyArmsScenarios()
                self.arms_scenarios.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListScenarioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListScenarioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListScenarioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSilencePoliciesRequest(TeaModel):
    def __init__(
        self,
        is_detail: bool = None,
        name: str = None,
        page: int = None,
        region_id: str = None,
        size: int = None,
    ):
        # Specifies whether to query the details of a silence policy. Valid values:
        # 
        # *   `true`: Details of the silence policy are queried.
        # *   `false`: Details about notification policies are not queried.
        self.is_detail = is_detail
        # The name of the silence policy.
        self.name = name
        # The number of the page to return.
        # 
        # This parameter is required.
        self.page = page
        # The ID of the region.
        self.region_id = region_id
        # The number of entries to return on each page.
        # 
        # This parameter is required.
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_detail is not None:
            result['IsDetail'] = self.is_detail
        if self.name is not None:
            result['Name'] = self.name
        if self.page is not None:
            result['Page'] = self.page
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsDetail') is not None:
            self.is_detail = m.get('IsDetail')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        value: str = None,
    ):
        # The key of the matching condition.
        self.key = key
        # The logical operator of the matching condition. Valid values:
        # 
        # *   `eq`: equal to
        # *   `neq`: not equal to
        # *   `in`: contains
        # *   `nin`: does not contain
        # *   `re`: regular expression match
        # *   `nre`: regular expression mismatch
        self.operator = operator
        # The value of the matching condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules(TeaModel):
    def __init__(
        self,
        matching_conditions: List[ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions] = None,
    ):
        # The matching conditions.
        self.matching_conditions = matching_conditions

    def validate(self):
        if self.matching_conditions:
            for k in self.matching_conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MatchingConditions'] = []
        if self.matching_conditions is not None:
            for k in self.matching_conditions:
                result['MatchingConditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.matching_conditions = []
        if m.get('MatchingConditions') is not None:
            for k in m.get('MatchingConditions'):
                temp_model = ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions()
                self.matching_conditions.append(temp_model.from_map(k))
        return self


class ListSilencePoliciesResponseBodyPageBeanSilencePolicies(TeaModel):
    def __init__(
        self,
        effective_time_type: str = None,
        id: int = None,
        matching_rules: List[ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules] = None,
        name: str = None,
        state: str = None,
        time_period: str = None,
        time_slots: str = None,
    ):
        self.effective_time_type = effective_time_type
        # The ID of the silence policy.
        self.id = id
        # The matching rules.
        self.matching_rules = matching_rules
        # The name of the silence policy.
        self.name = name
        # Indicates whether the silence policy is enabled. Valid values: enable and disable.
        self.state = state
        self.time_period = time_period
        self.time_slots = time_slots

    def validate(self):
        if self.matching_rules:
            for k in self.matching_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effective_time_type is not None:
            result['EffectiveTimeType'] = self.effective_time_type
        if self.id is not None:
            result['Id'] = self.id
        result['MatchingRules'] = []
        if self.matching_rules is not None:
            for k in self.matching_rules:
                result['MatchingRules'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        if self.time_period is not None:
            result['TimePeriod'] = self.time_period
        if self.time_slots is not None:
            result['TimeSlots'] = self.time_slots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EffectiveTimeType') is not None:
            self.effective_time_type = m.get('EffectiveTimeType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        self.matching_rules = []
        if m.get('MatchingRules') is not None:
            for k in m.get('MatchingRules'):
                temp_model = ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules()
                self.matching_rules.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TimePeriod') is not None:
            self.time_period = m.get('TimePeriod')
        if m.get('TimeSlots') is not None:
            self.time_slots = m.get('TimeSlots')
        return self


class ListSilencePoliciesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        page: int = None,
        silence_policies: List[ListSilencePoliciesResponseBodyPageBeanSilencePolicies] = None,
        size: int = None,
        total: int = None,
    ):
        # The number of the page returned.
        self.page = page
        # The queried silence policies.
        self.silence_policies = silence_policies
        # The number of entries returned per page.
        self.size = size
        # The number of silence policies that were returned.
        self.total = total

    def validate(self):
        if self.silence_policies:
            for k in self.silence_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page is not None:
            result['Page'] = self.page
        result['SilencePolicies'] = []
        if self.silence_policies is not None:
            for k in self.silence_policies:
                result['SilencePolicies'].append(k.to_map() if k else None)
        if self.size is not None:
            result['Size'] = self.size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Page') is not None:
            self.page = m.get('Page')
        self.silence_policies = []
        if m.get('SilencePolicies') is not None:
            for k in m.get('SilencePolicies'):
                temp_model = ListSilencePoliciesResponseBodyPageBeanSilencePolicies()
                self.silence_policies.append(temp_model.from_map(k))
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListSilencePoliciesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: ListSilencePoliciesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned pages.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = ListSilencePoliciesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSilencePoliciesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSilencePoliciesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSilencePoliciesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSyntheticDetailRequestAdvancedFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        op_type: str = None,
        value: Any = None,
    ):
        # The filter condition. The taskType and dataId fields are supported.
        # 
        # *   To query the list of synthetic test results, set the key to taskType.
        # *   To query the result details of a synthetic monitoring task, set the key to dataId.
        self.key = key
        # The type of the filter condition. Valid values: eq and in. eq: equal to. in: include.
        self.op_type = op_type
        # The value of the filter condition. The type of the task. Valid values: 1: ICMP 2: TCP 3: DNS 4: HTTP 5: website speed measurement 6: file download
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListSyntheticDetailRequestExactFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        op_type: str = None,
        value: Any = None,
    ):
        # A reserved field.
        self.key = key
        # A reserved field.
        self.op_type = op_type
        # A reserved field.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListSyntheticDetailRequest(TeaModel):
    def __init__(
        self,
        advanced_filters: List[ListSyntheticDetailRequestAdvancedFilters] = None,
        category: str = None,
        detail: str = None,
        end_time: int = None,
        exact_filters: List[ListSyntheticDetailRequestExactFilters] = None,
        filters: Dict[str, str] = None,
        order: str = None,
        order_by: str = None,
        page: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: int = None,
        synthetic_type: int = None,
    ):
        # An array of filter conditions. This parameter is required.
        # 
        # *   To query the list of synthetic test results, set this parameter in the following format: [{"Key":"taskType","OpType":"in","Value":[Task type]}].
        # *   To query the result details of a synthetic monitoring task, set this parameter in the following format: [{"Key":"dataId","OpType":"eq","Value":"dataId"}]. dataId is returned when you query the list of synthetic test results.
        self.advanced_filters = advanced_filters
        # The type of the results. Set the value to SYNTHETIC.
        self.category = category
        # The type of the list that contains the results. This parameter is required. Valid values:
        # 
        # *   ICMP_LIST
        # *   TCP_LIST
        # *   DNS_LIST
        # *   HTTP_LIST
        # *   WEBSITE_LIST
        # *   DOWNLOAD_LIST
        # *   ALL
        self.detail = detail
        # The timestamp of the end time of the query. Unit: milliseconds.
        self.end_time = end_time
        # A reserved field.
        self.exact_filters = exact_filters
        # The filter condition. This parameter is required.
        # 
        # *   To query the result of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}"}.
        # *   To query the result details of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}","dataId":"${dataId}"}.
        self.filters = filters
        # The order in which results are sorted. Valid values:
        # 
        # - `ASC`: ascending order
        # - `DESC`: descending order
        self.order = order
        # The field based on which results are sorted. Set the value to timestamp.
        self.order_by = order_by
        # The page number. Pages start from page 1.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the region. Set the value to cn-hangzhou.
        self.region_id = region_id
        # The timestamp of the start time of the query. Unit: milliseconds.
        self.start_time = start_time
        # The type of the synthetic test. Valid values: 1 and 2. 1 represents an immediate test, and 2 represents a scheduled test.
        self.synthetic_type = synthetic_type

    def validate(self):
        if self.advanced_filters:
            for k in self.advanced_filters:
                if k:
                    k.validate()
        if self.exact_filters:
            for k in self.exact_filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdvancedFilters'] = []
        if self.advanced_filters is not None:
            for k in self.advanced_filters:
                result['AdvancedFilters'].append(k.to_map() if k else None)
        if self.category is not None:
            result['Category'] = self.category
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['ExactFilters'] = []
        if self.exact_filters is not None:
            for k in self.exact_filters:
                result['ExactFilters'].append(k.to_map() if k else None)
        if self.filters is not None:
            result['Filters'] = self.filters
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.synthetic_type is not None:
            result['SyntheticType'] = self.synthetic_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.advanced_filters = []
        if m.get('AdvancedFilters') is not None:
            for k in m.get('AdvancedFilters'):
                temp_model = ListSyntheticDetailRequestAdvancedFilters()
                self.advanced_filters.append(temp_model.from_map(k))
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.exact_filters = []
        if m.get('ExactFilters') is not None:
            for k in m.get('ExactFilters'):
                temp_model = ListSyntheticDetailRequestExactFilters()
                self.exact_filters.append(temp_model.from_map(k))
        if m.get('Filters') is not None:
            self.filters = m.get('Filters')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SyntheticType') is not None:
            self.synthetic_type = m.get('SyntheticType')
        return self


class ListSyntheticDetailShrinkRequest(TeaModel):
    def __init__(
        self,
        advanced_filters_shrink: str = None,
        category: str = None,
        detail: str = None,
        end_time: int = None,
        exact_filters_shrink: str = None,
        filters_shrink: str = None,
        order: str = None,
        order_by: str = None,
        page: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: int = None,
        synthetic_type: int = None,
    ):
        # An array of filter conditions. This parameter is required.
        # 
        # *   To query the list of synthetic test results, set this parameter in the following format: [{"Key":"taskType","OpType":"in","Value":[Task type]}].
        # *   To query the result details of a synthetic monitoring task, set this parameter in the following format: [{"Key":"dataId","OpType":"eq","Value":"dataId"}]. dataId is returned when you query the list of synthetic test results.
        self.advanced_filters_shrink = advanced_filters_shrink
        # The type of the results. Set the value to SYNTHETIC.
        self.category = category
        # The type of the list that contains the results. This parameter is required. Valid values:
        # 
        # *   ICMP_LIST
        # *   TCP_LIST
        # *   DNS_LIST
        # *   HTTP_LIST
        # *   WEBSITE_LIST
        # *   DOWNLOAD_LIST
        # *   ALL
        self.detail = detail
        # The timestamp of the end time of the query. Unit: milliseconds.
        self.end_time = end_time
        # A reserved field.
        self.exact_filters_shrink = exact_filters_shrink
        # The filter condition. This parameter is required.
        # 
        # *   To query the result of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}"}.
        # *   To query the result details of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}","dataId":"${dataId}"}.
        self.filters_shrink = filters_shrink
        # The order in which results are sorted. Valid values:
        # 
        # - `ASC`: ascending order
        # - `DESC`: descending order
        self.order = order
        # The field based on which results are sorted. Set the value to timestamp.
        self.order_by = order_by
        # The page number. Pages start from page 1.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The ID of the region. Set the value to cn-hangzhou.
        self.region_id = region_id
        # The timestamp of the start time of the query. Unit: milliseconds.
        self.start_time = start_time
        # The type of the synthetic test. Valid values: 1 and 2. 1 represents an immediate test, and 2 represents a scheduled test.
        self.synthetic_type = synthetic_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_filters_shrink is not None:
            result['AdvancedFilters'] = self.advanced_filters_shrink
        if self.category is not None:
            result['Category'] = self.category
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.exact_filters_shrink is not None:
            result['ExactFilters'] = self.exact_filters_shrink
        if self.filters_shrink is not None:
            result['Filters'] = self.filters_shrink
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.synthetic_type is not None:
            result['SyntheticType'] = self.synthetic_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdvancedFilters') is not None:
            self.advanced_filters_shrink = m.get('AdvancedFilters')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ExactFilters') is not None:
            self.exact_filters_shrink = m.get('ExactFilters')
        if m.get('Filters') is not None:
            self.filters_shrink = m.get('Filters')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SyntheticType') is not None:
            self.synthetic_type = m.get('SyntheticType')
        return self


class ListSyntheticDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        items: List[Dict[str, Any]] = None,
        page: int = None,
        page_size: int = None,
        task_create_time: int = None,
        total: int = None,
    ):
        # The list of results.
        self.items = items
        # The page number.
        self.page = page
        # The number of entries returned on each page.
        self.page_size = page_size
        # A reserved field.
        self.task_create_time = task_create_time
        # The total number of entries.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['Items'] = self.items
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_create_time is not None:
            result['TaskCreateTime'] = self.task_create_time
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskCreateTime') is not None:
            self.task_create_time = m.get('TaskCreateTime')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListSyntheticDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListSyntheticDetailResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code returned. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The error message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListSyntheticDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSyntheticDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSyntheticDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSyntheticDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTimingSyntheticTasksRequestSearch(TeaModel):
    def __init__(
        self,
        name: str = None,
        order: int = None,
        order_field: str = None,
        page: int = None,
        page_size: int = None,
        status: str = None,
        task_ids: List[str] = None,
        task_types: List[int] = None,
    ):
        # The task name.
        self.name = name
        # The order by which tasks are sorted. 1: ascending order. -1: descending order.
        self.order = order
        # The condition by which tasks are sorted. You can sort tasks by gmtCreate, gmtModified, status, or monitorCount.
        self.order_field = order_field
        # The page number. This parameter is required.
        self.page = page
        # The number of entries per page. This parameter is required.
        self.page_size = page_size
        # The task status. CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota limit. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: An exception occurs while deleting the task.
        self.status = status
        # The task IDs.
        self.task_ids = task_ids
        # The task types.
        self.task_types = task_types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.order_field is not None:
            result['OrderField'] = self.order_field
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.task_types is not None:
            result['TaskTypes'] = self.task_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderField') is not None:
            self.order_field = m.get('OrderField')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('TaskTypes') is not None:
            self.task_types = m.get('TaskTypes')
        return self


class ListTimingSyntheticTasksRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTimingSyntheticTasksRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        search: ListTimingSyntheticTasksRequestSearch = None,
        tags: List[ListTimingSyntheticTasksRequestTags] = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The search keyword.
        self.search = search
        # The tags.
        self.tags = tags

    def validate(self):
        if self.search:
            self.search.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.search is not None:
            result['Search'] = self.search.to_map()
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Search') is not None:
            temp_model = ListTimingSyntheticTasksRequestSearch()
            self.search = temp_model.from_map(m['Search'])
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListTimingSyntheticTasksRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListTimingSyntheticTasksShrinkRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        resource_group_id: str = None,
        search_shrink: str = None,
        tags_shrink: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The search keyword.
        self.search_shrink = search_shrink
        # The tags.
        self.tags_shrink = tags_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.search_shrink is not None:
            result['Search'] = self.search_shrink
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Search') is not None:
            self.search_shrink = m.get('Search')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        return self


class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts(TeaModel):
    def __init__(
        self,
        domain: str = None,
        ip_type: int = None,
        ips: List[str] = None,
    ):
        # The destination domain name.
        self.domain = domain
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4.
        # *   2: IPv6.
        self.ip_type = ip_type
        # The IP address.
        self.ips = ips

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.ips is not None:
            result['Ips'] = self.ips
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        return self


class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost(TeaModel):
    def __init__(
        self,
        hosts: List[ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts] = None,
        select_type: int = None,
    ):
        # The custom host settings.
        self.hosts = hosts
        # The selection mode. Valid values:
        # 
        # *   0: random
        # *   1: polling
        self.select_type = select_type

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['Hosts'].append(k.to_map() if k else None)
        if self.select_type is not None:
            result['SelectType'] = self.select_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.hosts = []
        if m.get('Hosts') is not None:
            for k in m.get('Hosts'):
                temp_model = ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts()
                self.hosts.append(temp_model.from_map(k))
        if m.get('SelectType') is not None:
            self.select_type = m.get('SelectType')
        return self


class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting(TeaModel):
    def __init__(
        self,
        prometheus_cluster_id: str = None,
        prometheus_cluster_region: str = None,
        prometheus_labels: Dict[str, str] = None,
    ):
        # A reserved field.
        self.prometheus_cluster_id = prometheus_cluster_id
        # A reserved field.
        self.prometheus_cluster_region = prometheus_cluster_region
        # A reserved field.
        self.prometheus_labels = prometheus_labels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_cluster_id is not None:
            result['PrometheusClusterId'] = self.prometheus_cluster_id
        if self.prometheus_cluster_region is not None:
            result['PrometheusClusterRegion'] = self.prometheus_cluster_region
        if self.prometheus_labels is not None:
            result['PrometheusLabels'] = self.prometheus_labels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PrometheusClusterId') is not None:
            self.prometheus_cluster_id = m.get('PrometheusClusterId')
        if m.get('PrometheusClusterRegion') is not None:
            self.prometheus_cluster_region = m.get('PrometheusClusterRegion')
        if m.get('PrometheusLabels') is not None:
            self.prometheus_labels = m.get('PrometheusLabels')
        return self


class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        secure_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The ID of the security group to which the client belongs. The security group specifies the inbound and outbound rules of the client for the VPC. You need to allow the security group to which the client belongs to access the security group to which the VPC belongs. Otherwise, the client cannot access resources in the VPC.
        self.secure_group_id = secure_group_id
        # The vSwitch ID.
        self.v_switch_id = v_switch_id
        # The VPC ID.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.secure_group_id is not None:
            result['SecureGroupId'] = self.secure_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecureGroupId') is not None:
            self.secure_group_id = m.get('SecureGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting(TeaModel):
    def __init__(
        self,
        custom_host: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost = None,
        custom_prometheus_setting: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting = None,
        custom_vpcsetting: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting = None,
        ip_type: int = None,
        is_open_trace: bool = None,
        monitor_samples: int = None,
        trace_client_type: int = None,
        xtrace_region: str = None,
    ):
        # The custom host settings.
        self.custom_host = custom_host
        # A reserved field.
        self.custom_prometheus_setting = custom_prometheus_setting
        # The information about the virtual private cloud (VPC). If the destination URL is an Alibaba Cloud internal endpoint, you need to configure a VPC.
        self.custom_vpcsetting = custom_vpcsetting
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4.
        # *   2: IPv6.
        self.ip_type = ip_type
        # Indicates whether tracing is enabled.
        self.is_open_trace = is_open_trace
        # Indicates whether monitoring samples are evenly distributed. Valid values:
        # 
        # *   0: No
        # *   1: Yes
        self.monitor_samples = monitor_samples
        # The type of the client for tracing. Valid values:
        # 
        # *   0: ARMS agent
        # *   1: OpenTelemetry
        # *   2: Jaeger
        self.trace_client_type = trace_client_type
        # The region to which trace data is reported.
        self.xtrace_region = xtrace_region

    def validate(self):
        if self.custom_host:
            self.custom_host.validate()
        if self.custom_prometheus_setting:
            self.custom_prometheus_setting.validate()
        if self.custom_vpcsetting:
            self.custom_vpcsetting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_host is not None:
            result['CustomHost'] = self.custom_host.to_map()
        if self.custom_prometheus_setting is not None:
            result['CustomPrometheusSetting'] = self.custom_prometheus_setting.to_map()
        if self.custom_vpcsetting is not None:
            result['CustomVPCSetting'] = self.custom_vpcsetting.to_map()
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.is_open_trace is not None:
            result['IsOpenTrace'] = self.is_open_trace
        if self.monitor_samples is not None:
            result['MonitorSamples'] = self.monitor_samples
        if self.trace_client_type is not None:
            result['TraceClientType'] = self.trace_client_type
        if self.xtrace_region is not None:
            result['XtraceRegion'] = self.xtrace_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHost') is not None:
            temp_model = ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost()
            self.custom_host = temp_model.from_map(m['CustomHost'])
        if m.get('CustomPrometheusSetting') is not None:
            temp_model = ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting()
            self.custom_prometheus_setting = temp_model.from_map(m['CustomPrometheusSetting'])
        if m.get('CustomVPCSetting') is not None:
            temp_model = ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting()
            self.custom_vpcsetting = temp_model.from_map(m['CustomVPCSetting'])
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('IsOpenTrace') is not None:
            self.is_open_trace = m.get('IsOpenTrace')
        if m.get('MonitorSamples') is not None:
            self.monitor_samples = m.get('MonitorSamples')
        if m.get('TraceClientType') is not None:
            self.trace_client_type = m.get('TraceClientType')
        if m.get('XtraceRegion') is not None:
            self.xtrace_region = m.get('XtraceRegion')
        return self


class ListTimingSyntheticTasksResponseBodyDataItemsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTimingSyntheticTasksResponseBodyDataItems(TeaModel):
    def __init__(
        self,
        common_setting: ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting = None,
        frequency: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        monitor_category: int = None,
        monitor_num: str = None,
        name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        status: str = None,
        tags: List[ListTimingSyntheticTasksResponseBodyDataItemsTags] = None,
        task_id: str = None,
        task_type: int = None,
        url: str = None,
    ):
        # The general settings.
        self.common_setting = common_setting
        # The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
        self.frequency = frequency
        # The time when the task was created.
        self.gmt_create = gmt_create
        # The time when the task was modified.
        self.gmt_modified = gmt_modified
        # The detection point type. 1: PC. 2: mobile device.
        self.monitor_category = monitor_category
        # The number of detection points.
        self.monitor_num = monitor_num
        # The task name.
        self.name = name
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The task status. CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota limit. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: An exception occurs while deleting the task.
        self.status = status
        # The tags.
        self.tags = tags
        # The ID of the synthetic monitoring task.
        self.task_id = task_id
        # The type of the task. Valid values:
        # 
        # 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed. 6: file download.
        self.task_type = task_type
        # The URL for synthetic monitoring.
        self.url = url

    def validate(self):
        if self.common_setting:
            self.common_setting.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.common_setting is not None:
            result['CommonSetting'] = self.common_setting.to_map()
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.monitor_category is not None:
            result['MonitorCategory'] = self.monitor_category
        if self.monitor_num is not None:
            result['MonitorNum'] = self.monitor_num
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CommonSetting') is not None:
            temp_model = ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting()
            self.common_setting = temp_model.from_map(m['CommonSetting'])
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('MonitorCategory') is not None:
            self.monitor_category = m.get('MonitorCategory')
        if m.get('MonitorNum') is not None:
            self.monitor_num = m.get('MonitorNum')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListTimingSyntheticTasksResponseBodyDataItemsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ListTimingSyntheticTasksResponseBodyData(TeaModel):
    def __init__(
        self,
        items: List[ListTimingSyntheticTasksResponseBodyDataItems] = None,
        page: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The queried tasks.
        self.items = items
        # The page number.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The total number of tasks.
        self.total = total

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = ListTimingSyntheticTasksResponseBodyDataItems()
                self.items.append(temp_model.from_map(k))
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListTimingSyntheticTasksResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: ListTimingSyntheticTasksResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListTimingSyntheticTasksResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTimingSyntheticTasksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTimingSyntheticTasksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTimingSyntheticTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTraceAppsRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTraceAppsRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        region: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[ListTraceAppsRequestTags] = None,
    ):
        # The type of the application that is associated with the alert rule. Valid values:
        # 
        # - TRACE: Application Monitoring
        # - EBPF: Application Monitoring eBPF Edition
        self.app_type = app_type
        # The region ID.
        self.region = region
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.region is not None:
            result['Region'] = self.region
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListTraceAppsRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class ListTraceAppsResponseBodyTraceAppsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTraceAppsResponseBodyTraceApps(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        app_name: str = None,
        cluster_id: str = None,
        create_time: int = None,
        labels: List[str] = None,
        language: str = None,
        namespace: str = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        show: bool = None,
        source: str = None,
        tags: List[ListTraceAppsResponseBodyTraceAppsTags] = None,
        type: str = None,
        update_time: int = None,
        user_id: str = None,
        workload_kind: str = None,
        workload_name: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The cluster ID.
        self.cluster_id = cluster_id
        # The time when the monitoring task was created. The value is a timestamp. Unit: milliseconds.
        self.create_time = create_time
        # The labels of the application.
        self.labels = labels
        # The language.
        self.language = language
        # The namespace.
        self.namespace = namespace
        # The process identifier (PID) of the application.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
        # 
        # *   `true`: yes
        # *   `false`: no
        self.show = show
        # The application source.
        self.source = source
        # The tags.
        self.tags = tags
        # The type of the monitoring task. Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: Browser Monitoring
        self.type = type
        # The time when the monitoring task was updated. The value is a timestamp. Unit: milliseconds.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id
        # The type of the workload.
        self.workload_kind = workload_kind
        # The name of the workload.
        self.workload_name = workload_name

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.language is not None:
            result['Language'] = self.language
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.show is not None:
            result['Show'] = self.show
        if self.source is not None:
            result['Source'] = self.source
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.workload_kind is not None:
            result['WorkloadKind'] = self.workload_kind
        if self.workload_name is not None:
            result['WorkloadName'] = self.workload_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = ListTraceAppsResponseBodyTraceAppsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('WorkloadKind') is not None:
            self.workload_kind = m.get('WorkloadKind')
        if m.get('WorkloadName') is not None:
            self.workload_name = m.get('WorkloadName')
        return self


class ListTraceAppsResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_apps: List[ListTraceAppsResponseBodyTraceApps] = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   `2XX`: The request is successful.
        # *   `3XX`: A redirection message is returned.
        # *   `4XX`: The request is invalid.
        # *   `5XX`: A server error occurs.
        self.code = code
        # The error message returned if the request parameters are invalid.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.success = success
        # The list of Application Monitoring tasks.
        self.trace_apps = trace_apps

    def validate(self):
        if self.trace_apps:
            for k in self.trace_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TraceApps'] = []
        if self.trace_apps is not None:
            for k in self.trace_apps:
                result['TraceApps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.trace_apps = []
        if m.get('TraceApps') is not None:
            for k in m.get('TraceApps'):
                temp_model = ListTraceAppsResponseBodyTraceApps()
                self.trace_apps.append(temp_model.from_map(k))
        return self


class ListTraceAppsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTraceAppsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTraceAppsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ManageGetRecordingRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        query_user_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The user ID.
        # 
        # This parameter is required.
        self.query_user_id = query_user_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.query_user_id is not None:
            result['QueryUserId'] = self.query_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('QueryUserId') is not None:
            self.query_user_id = m.get('QueryUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ManageGetRecordingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # 200
        self.code = code
        # The returned message.
        self.data = data
        # 
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ManageGetRecordingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ManageGetRecordingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ManageGetRecordingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ManageRecordingRuleRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        query_user_id: str = None,
        region_id: str = None,
        rule_yaml: str = None,
    ):
        # The ID of the cluster.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the user.
        # 
        # This parameter is required.
        self.query_user_id = query_user_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The recording rule.
        # 
        # This parameter is required.
        self.rule_yaml = rule_yaml

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.query_user_id is not None:
            result['QueryUserId'] = self.query_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_yaml is not None:
            result['RuleYaml'] = self.rule_yaml
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('QueryUserId') is not None:
            self.query_user_id = m.get('QueryUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleYaml') is not None:
            self.rule_yaml = m.get('RuleYaml')
        return self


class ManageRecordingRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request. You can use the ID to troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ManageRecordingRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ManageRecordingRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ManageRecordingRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenArmsDefaultSLRRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class OpenArmsDefaultSLRResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful. Valid values:
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenArmsDefaultSLRResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenArmsDefaultSLRResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenArmsDefaultSLRResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenArmsServiceSecondVersionRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        type: str = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the service. Valid values:
        # 
        # *   `arms`: ARMS
        # *   `arms_app`: Application Monitoring
        # *   `arms_web`: Browser Monitoring
        # *   `prometheus_monitor`: Managed Service for Prometheus
        # *   `synthetic_post`: Synthetic Monitoring
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class OpenArmsServiceSecondVersionResponseBody(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        request_id: str = None,
    ):
        # The service ID returned if the service is activated.
        self.order_id = order_id
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenArmsServiceSecondVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenArmsServiceSecondVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenArmsServiceSecondVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenVClusterRequest(TeaModel):
    def __init__(
        self,
        cluster_type: str = None,
        length: int = None,
        product: str = None,
        recreate_switch: bool = None,
        region_id: str = None,
    ):
        # The type of the cluster. For cloud services, set this parameter to `cloud-product-prometheus`.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The length of the cluster ID. Default value: 10.
        self.length = length
        # The name of the cloud service. This parameter must be specified when ClusterType is set to `cloud-product-prometheus`. Valid values: influxdb, mongodb, and DLA. You cannot specify multiple service names.
        self.product = product
        # Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.
        self.recreate_switch = recreate_switch
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.length is not None:
            result['Length'] = self.length
        if self.product is not None:
            result['Product'] = self.product
        if self.recreate_switch is not None:
            result['RecreateSwitch'] = self.recreate_switch
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RecreateSwitch') is not None:
            self.recreate_switch = m.get('RecreateSwitch')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class OpenVClusterResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The cluster ID.
        self.data = data
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenVClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenVClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenVClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenXtraceDefaultSLRRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
    ):
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class OpenXtraceDefaultSLRResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # Indicates whether the request was successful. Valid values:
        #  
        # *   `true`
        # *   `false`
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenXtraceDefaultSLRResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenXtraceDefaultSLRResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenXtraceDefaultSLRResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAppMetadataRequest(TeaModel):
    def __init__(
        self,
        meta_ids: str = None,
        meta_type: str = None,
        pid: str = None,
        region_id: str = None,
    ):
        # The metadata IDs. Separate multiple IDs with commas (,).
        # 
        # You can obtain the exception ID on the **Exception Analysis** page of your application in the ARMS console.
        # 
        # This parameter is required.
        self.meta_ids = meta_ids
        # The metadata type. Valid values:
        # 
        # *   sql: obtains an SQL statement based on sqlId.
        # *   exception: obtains the exception stack based on exceptionId.
        # 
        # This parameter is required.
        self.meta_type = meta_type
        # The process identifier (PID) of the application. You can obtain the PID of an application by calling the **ListTraceApps** operation.
        # 
        # This parameter is required.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta_ids is not None:
            result['MetaIds'] = self.meta_ids
        if self.meta_type is not None:
            result['MetaType'] = self.meta_type
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetaIds') is not None:
            self.meta_ids = m.get('MetaIds')
        if m.get('MetaType') is not None:
            self.meta_type = m.get('MetaType')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class QueryAppMetadataResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Dict[str, Any] = None,
        http_status_code: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   2XX: The request is successful.
        # *   3XX: A redirection message is returned.
        # *   4XX: The request is invalid.
        # *   5XX: A server error occurs.
        self.code = code
        # The returned struct.
        self.data = data
        # The HTTP status code returned.
        self.http_status_code = http_status_code
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryAppMetadataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAppMetadataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAppMetadataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryAppTopologyRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        db: str = None,
        db_name: str = None,
        end_time: int = None,
        filters: Dict[str, str] = None,
        pid: str = None,
        region_id: str = None,
        rpc: str = None,
        start_time: int = None,
        type: str = None,
    ):
        # The application type
        self.app_type = app_type
        # The database domain name.
        self.db = db
        # The name of the database.
        self.db_name = db_name
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter conditions.
        self.filters = filters
        # The ID of the application.
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
        self.pid = pid
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # RPC interface name.
        self.rpc = rpc
        # The start of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The type kind of topology.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.db is not None:
            result['Db'] = self.db
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filters is not None:
            result['Filters'] = self.filters
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rpc is not None:
            result['Rpc'] = self.rpc
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Db') is not None:
            self.db = m.get('Db')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Filters') is not None:
            self.filters = m.get('Filters')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Rpc') is not None:
            self.rpc = m.get('Rpc')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryAppTopologyShrinkRequest(TeaModel):
    def __init__(
        self,
        app_type: str = None,
        db: str = None,
        db_name: str = None,
        end_time: int = None,
        filters_shrink: str = None,
        pid: str = None,
        region_id: str = None,
        rpc: str = None,
        start_time: int = None,
        type: str = None,
    ):
        # The application type
        self.app_type = app_type
        # The database domain name.
        self.db = db
        # The name of the database.
        self.db_name = db_name
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter conditions.
        self.filters_shrink = filters_shrink
        # The ID of the application.
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
        self.pid = pid
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # RPC interface name.
        self.rpc = rpc
        # The start of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The type kind of topology.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.db is not None:
            result['Db'] = self.db
        if self.db_name is not None:
            result['DbName'] = self.db_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filters_shrink is not None:
            result['Filters'] = self.filters_shrink
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rpc is not None:
            result['Rpc'] = self.rpc
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('Db') is not None:
            self.db = m.get('Db')
        if m.get('DbName') is not None:
            self.db_name = m.get('DbName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Filters') is not None:
            self.filters_shrink = m.get('Filters')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Rpc') is not None:
            self.rpc = m.get('Rpc')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryAppTopologyResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Any = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # The returned struct.
        self.data = data
        # The error message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryAppTopologyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryAppTopologyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryAppTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCommercialUsageRequestAdvancedFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        op_type: str = None,
        value: str = None,
    ):
        # The key of the filter condition.
        self.key = key
        # The operator. Valid values: eq and in.
        self.op_type = op_type
        # The value of the filter condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryCommercialUsageRequest(TeaModel):
    def __init__(
        self,
        advanced_filters: List[QueryCommercialUsageRequestAdvancedFilters] = None,
        dimensions: List[str] = None,
        end_time: int = None,
        interval_in_sec: int = None,
        measures: List[str] = None,
        metric: str = None,
        order: str = None,
        order_by: str = None,
        query_type: str = None,
        start_time: int = None,
    ):
        # The filter conditions.
        self.advanced_filters = advanced_filters
        # The dimensions of the metric that you want to query. Valid values:
        # 
        # *   dataType: data type
        # *   productType: product type
        # *   instanceId: instance ID
        # *   instanceName: instance name
        # *   instanceType: instance type
        self.dimensions = dimensions
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The time interval between data slices. Unit: seconds. Minimum value: 3600.
        # 
        # Valid values:
        # 
        # *   3600: hours
        # *   86400: days
        self.interval_in_sec = interval_in_sec
        # The measures of the metric that you want to query.
        self.measures = measures
        # The name of the metric. Valid value: USAGEFEE.STAT.
        # 
        # This parameter is required.
        self.metric = metric
        # The order in which data is sorted. Valid value:
        # 
        # *   `ASC`: ascending order
        # *   `DESC`: descending order
        self.order = order
        # The dimension by which data is sorted.
        # 
        # Valid value:
        # 
        # *   dataType
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.order_by = order_by
        # The data type. Valid values:
        # 
        # *   instantQuery: non-time series
        # *   timeSeriesQuery: time series
        # 
        # This parameter is required.
        self.query_type = query_type
        # The start of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        if self.advanced_filters:
            for k in self.advanced_filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdvancedFilters'] = []
        if self.advanced_filters is not None:
            for k in self.advanced_filters:
                result['AdvancedFilters'].append(k.to_map() if k else None)
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval_in_sec is not None:
            result['IntervalInSec'] = self.interval_in_sec
        if self.measures is not None:
            result['Measures'] = self.measures
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.query_type is not None:
            result['QueryType'] = self.query_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.advanced_filters = []
        if m.get('AdvancedFilters') is not None:
            for k in m.get('AdvancedFilters'):
                temp_model = QueryCommercialUsageRequestAdvancedFilters()
                self.advanced_filters.append(temp_model.from_map(k))
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IntervalInSec') is not None:
            self.interval_in_sec = m.get('IntervalInSec')
        if m.get('Measures') is not None:
            self.measures = m.get('Measures')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('QueryType') is not None:
            self.query_type = m.get('QueryType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryCommercialUsageResponseBodyData(TeaModel):
    def __init__(
        self,
        complete: bool = None,
        items: List[Dict[str, Any]] = None,
    ):
        # Indicates whether a multi-region query is complete. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.complete = complete
        # The returned struct.
        self.items = items

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete is not None:
            result['Complete'] = self.complete
        if self.items is not None:
            result['Items'] = self.items
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Complete') is not None:
            self.complete = m.get('Complete')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        return self


class QueryCommercialUsageResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: QueryCommercialUsageResponseBodyData = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response status. Valid values: 2XX: The request is successful. 3XX: A redirection message is returned. 4XX: The request is invalid. 5XX: A server error occurs.
        self.code = code
        # The returned struct.
        self.data = data
        self.http_status_code = http_status_code
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryCommercialUsageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryCommercialUsageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCommercialUsageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCommercialUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMetricByPageRequestFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the filter condition. You must set the key to `pid` or `regionId`.
        self.key = key
        # The value of the filter condition. You must set the value of the `pid` or `regionId` condition. For information about how to obtain the `pid`, see the "Obtain the PID of an application" section.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryMetricByPageRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        custom_filters: List[str] = None,
        dimensions: List[str] = None,
        end_time: int = None,
        filters: List[QueryMetricByPageRequestFilters] = None,
        interval_in_sec: int = None,
        measures: List[str] = None,
        metric: str = None,
        order: str = None,
        order_by: str = None,
        page_size: int = None,
        start_time: int = None,
    ):
        # The page number. Default value: `1`.
        self.current_page = current_page
        # Custom filter conditions.
        self.custom_filters = custom_filters
        # The dimensions of the metric that you want to query.
        self.dimensions = dimensions
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter conditions.
        self.filters = filters
        # The time interval at which you want to query metric data. Unit: milliseconds. Minimum value: 60000.
        self.interval_in_sec = interval_in_sec
        # The measures of the metric that you want to query.
        self.measures = measures
        # The metric that you want to query. You cannot specify a custom metric. For more information, see the "Application monitoring metrics that can be queried" section.
        # 
        # This parameter is required.
        self.metric = metric
        # The order in which measures are sorted. Valid values:
        # 
        # *   `ASC`: ascending order
        # *   `DESC`: descending order
        # 
        # > If you do not specify the parameter, data is not sorted.
        self.order = order
        # The dimension for arranging metrics in sequence. For more information, see the supplementary metrics.
        self.order_by = order_by
        # This parameter is no longer supported. The number of entries per page.
        self.page_size = page_size
        # The start of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.custom_filters is not None:
            result['CustomFilters'] = self.custom_filters
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['Filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['Filters'].append(k.to_map() if k else None)
        if self.interval_in_sec is not None:
            result['IntervalInSec'] = self.interval_in_sec
        if self.measures is not None:
            result['Measures'] = self.measures
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('CustomFilters') is not None:
            self.custom_filters = m.get('CustomFilters')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.filters = []
        if m.get('Filters') is not None:
            for k in m.get('Filters'):
                temp_model = QueryMetricByPageRequestFilters()
                self.filters.append(temp_model.from_map(k))
        if m.get('IntervalInSec') is not None:
            self.interval_in_sec = m.get('IntervalInSec')
        if m.get('Measures') is not None:
            self.measures = m.get('Measures')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryMetricByPageResponseBodyData(TeaModel):
    def __init__(
        self,
        completed: bool = None,
        items: List[Dict[str, Any]] = None,
        page: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # Whether the paging query ends.
        # 
        # true: end.
        # false: Need to continue pagination (continue to query after CurrentPage+1).
        self.completed = completed
        # The data entries returned.
        self.items = items
        # The page number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.completed is not None:
            result['Completed'] = self.completed
        if self.items is not None:
            result['Items'] = self.items
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Completed') is not None:
            self.completed = m.get('Completed')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryMetricByPageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryMetricByPageResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   2XX: The request was successful.
        # *   3XX: A redirection message was returned.
        # *   4XX: The request was invalid.
        # *   5XX: A server error occurred.
        self.code = code
        # The information about the array object.
        self.data = data
        # The error message returned if the call fails.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryMetricByPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryMetricByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMetricByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMetricByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryPromInstallStatusRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # The cluster ID.
        self.cluster_id = cluster_id
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class QueryPromInstallStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        is_controller_installed: bool = None,
    ):
        # Indicates whether the call was successful. Valid values:
        # 
        # true: The call was successful. false: The call fails.
        self.is_controller_installed = is_controller_installed

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_controller_installed is not None:
            result['isControllerInstalled'] = self.is_controller_installed
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isControllerInstalled') is not None:
            self.is_controller_installed = m.get('isControllerInstalled')
        return self


class QueryPromInstallStatusResponseBody(TeaModel):
    def __init__(
        self,
        data: QueryPromInstallStatusResponseBodyData = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = QueryPromInstallStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryPromInstallStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryPromInstallStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryPromInstallStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryReleaseMetricRequest(TeaModel):
    def __init__(
        self,
        change_order_id: str = None,
        create_time: int = None,
        metric_type: str = None,
        pid: str = None,
        proxy_user_id: str = None,
        release_end_time: int = None,
        release_start_time: int = None,
        service: str = None,
    ):
        # The ID of the change order.
        # 
        # This parameter is required.
        self.change_order_id = change_order_id
        # The time when the change order was created.
        self.create_time = create_time
        # The type of the metric that you want to query.
        self.metric_type = metric_type
        # The ID of the Enterprise Distributed Application Service (EDAS) or Kubernetes application.
        # 
        # This parameter is required.
        self.pid = pid
        # This parameter is not in use.
        self.proxy_user_id = proxy_user_id
        # The end time of the version release.
        # 
        # This parameter is required.
        self.release_end_time = release_end_time
        # The start time of the version release.
        # 
        # This parameter is required.
        self.release_start_time = release_start_time
        # The service that you want to query.
        self.service = service

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.change_order_id is not None:
            result['ChangeOrderId'] = self.change_order_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.proxy_user_id is not None:
            result['ProxyUserId'] = self.proxy_user_id
        if self.release_end_time is not None:
            result['ReleaseEndTime'] = self.release_end_time
        if self.release_start_time is not None:
            result['ReleaseStartTime'] = self.release_start_time
        if self.service is not None:
            result['Service'] = self.service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChangeOrderId') is not None:
            self.change_order_id = m.get('ChangeOrderId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('ProxyUserId') is not None:
            self.proxy_user_id = m.get('ProxyUserId')
        if m.get('ReleaseEndTime') is not None:
            self.release_end_time = m.get('ReleaseEndTime')
        if m.get('ReleaseStartTime') is not None:
            self.release_start_time = m.get('ReleaseStartTime')
        if m.get('Service') is not None:
            self.service = m.get('Service')
        return self


class QueryReleaseMetricResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The returned metric data.
        self.data = data
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryReleaseMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryReleaseMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryReleaseMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveAliClusterIdsFromPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        cluster_ids: str = None,
        global_view_cluster_id: str = None,
        group_name: str = None,
        region_id: str = None,
    ):
        # The IDs of clusters. Separate multiple IDs with commas (,).
        # 
        # This parameter is required.
        self.cluster_ids = cluster_ids
        # The ID of the global aggregation instance.
        # 
        # This parameter is required.
        self.global_view_cluster_id = global_view_cluster_id
        # The name of the global aggregation instance.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_ids is not None:
            result['ClusterIds'] = self.cluster_ids
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterIds') is not None:
            self.cluster_ids = m.get('ClusterIds')
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData(TeaModel):
    def __init__(
        self,
        info: str = None,
        msg: str = None,
        success: bool = None,
    ):
        # The Info-level information.
        self.info = info
        # The additional information.
        self.msg = msg
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The message returned.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveAliClusterIdsFromPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveSourcesFromPrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        global_view_cluster_id: str = None,
        group_name: str = None,
        region_id: str = None,
        source_names: str = None,
    ):
        # The ID of the global aggregation instance.
        # 
        # This parameter is required.
        self.global_view_cluster_id = global_view_cluster_id
        # The name of the global aggregation instance.
        # 
        # This parameter is required.
        self.group_name = group_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The list of custom data sources. You can specify multiple data sources and separate them with commas (,).
        # 
        # This parameter is required.
        self.source_names = source_names

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.global_view_cluster_id is not None:
            result['GlobalViewClusterId'] = self.global_view_cluster_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.source_names is not None:
            result['SourceNames'] = self.source_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GlobalViewClusterId') is not None:
            self.global_view_cluster_id = m.get('GlobalViewClusterId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SourceNames') is not None:
            self.source_names = m.get('SourceNames')
        return self


class RemoveSourcesFromPrometheusGlobalViewResponseBodyData(TeaModel):
    def __init__(
        self,
        info: str = None,
        msg: str = None,
        success: bool = None,
    ):
        # The Info-level information.
        self.info = info
        # The additional information.
        self.msg = msg
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveSourcesFromPrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: RemoveSourcesFromPrometheusGlobalViewResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # Status code. 200 is success, other status codes are exceptions.
        self.code = code
        # The returned struct.
        self.data = data
        # Returns a hint message for the result.
        self.message = message
        # The request ID. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RemoveSourcesFromPrometheusGlobalViewResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveSourcesFromPrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveSourcesFromPrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveSourcesFromPrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RestartEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        environment_id: str = None,
        feature_name: str = None,
        region_id: str = None,
    ):
        # The ID of the environment.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The feature name. Valid values: app-agent-pilot, metric-agent, ebpf-agent, and service-check.
        # 
        # This parameter is required.
        self.feature_name = feature_name
        # The region ID. Default value: cn-hangzhou.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.feature_name is not None:
            result['FeatureName'] = self.feature_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('FeatureName') is not None:
            self.feature_name = m.get('FeatureName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RestartEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.data = data
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values: true false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RestartEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RestartEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RestartEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveTraceAppConfigRequestSettings(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the settings that you want to modify. For more information about the supported settings, see the following sections.
        # 
        # *   Trace sampling settings
        # *   Agent switch settings
        # *   Threshold settings
        # *   Advanced settings
        # *   Thread settings
        # *   Memory snapshot settings
        # *   URL convergence settings
        # *   Business log association settings
        self.key = key
        # The value of the settings that you want to modify. For more information about the supported settings, see the following sections.
        # 
        # *   Trace sampling settings
        # *   Agent switch settings
        # *   Threshold settings
        # *   Advanced settings
        # *   Thread settings
        # *   Memory snapshot settings
        # *   URL convergence settings
        # *   Business log association settings
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SaveTraceAppConfigRequest(TeaModel):
    def __init__(
        self,
        pid: str = None,
        settings: List[SaveTraceAppConfigRequestSettings] = None,
    ):
        # The process ID (PID) of the application.
        # 
        # Log on to the ARMS console. In the left-side navigation pane, choose **Application Monitoring** > **Application List**. On the Application List page, click the name of an application. The URL in the address bar contains the PID of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with an at sign (@) to obtain xxx@74xxx.
        # 
        # This parameter is required.
        self.pid = pid
        # The settings of Application Monitoring.
        self.settings = settings

    def validate(self):
        if self.settings:
            for k in self.settings:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pid is not None:
            result['Pid'] = self.pid
        result['Settings'] = []
        if self.settings is not None:
            for k in self.settings:
                result['Settings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        self.settings = []
        if m.get('Settings') is not None:
            for k in m.get('Settings'):
                temp_model = SaveTraceAppConfigRequestSettings()
                self.settings.append(temp_model.from_map(k))
        return self


class SaveTraceAppConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
        self.code = code
        # Indicates whether the call was successful.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveTraceAppConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveTraceAppConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveTraceAppConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchAlertContactRequest(TeaModel):
    def __init__(
        self,
        contact_ids: str = None,
        contact_name: str = None,
        current_page: str = None,
        email: str = None,
        page_size: str = None,
        phone: str = None,
        region_id: str = None,
    ):
        # The ID of the alert contact.
        self.contact_ids = contact_ids
        # The name of the alert contact.
        self.contact_name = contact_name
        # The number of the page to return.
        self.current_page = current_page
        # The email address of the alert contact.
        self.email = email
        # The number of entries to return on each page.
        self.page_size = page_size
        # The mobile number of the alert contact.
        self.phone = phone
        # The ID of the region. Set the value to `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.email is not None:
            result['Email'] = self.email
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SearchAlertContactResponseBodyPageBeanContacts(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
        contact_name: str = None,
        content: str = None,
        create_time: int = None,
        ding_robot: str = None,
        email: str = None,
        phone: str = None,
        resource_group_id: str = None,
        system_noc: bool = None,
        update_time: int = None,
        user_id: str = None,
        webhook: str = None,
    ):
        # The ID of the alert contact.
        self.contact_id = contact_id
        # The name of the alert contact.
        self.contact_name = contact_name
        # The contact group to which the contact belongs. If your contacts are added to multiple contact groups, the contact groups are separated by vertical bars (|).
        self.content = content
        # The timestamp generated when the alert contact was created.
        self.create_time = create_time
        # The webhook URL of the DingTalk chatbot.
        self.ding_robot = ding_robot
        # The email address of the alert contact.
        self.email = email
        # The mobile number of the alert contact.
        self.phone = phone
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # Indicates whether the alert contact receives system notifications. Valid values:
        # 
        # *   `true`: The alert contact receives system notifications.
        # *   `false`: The alert contact does not receive system notifications.
        self.system_noc = system_noc
        # The timestamp generated when the alert contact was updated.
        self.update_time = update_time
        # The ID of the user.
        self.user_id = user_id
        # The information about the webhook.
        self.webhook = webhook

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.content is not None:
            result['Content'] = self.content
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.system_noc is not None:
            result['SystemNoc'] = self.system_noc
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SystemNoc') is not None:
            self.system_noc = m.get('SystemNoc')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class SearchAlertContactResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        contacts: List[SearchAlertContactResponseBodyPageBeanContacts] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The information about the alert contacts.
        self.contacts = contacts
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['Contacts'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contacts = []
        if m.get('Contacts') is not None:
            for k in m.get('Contacts'):
                temp_model = SearchAlertContactResponseBodyPageBeanContacts()
                self.contacts.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchAlertContactResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: SearchAlertContactResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = SearchAlertContactResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchAlertContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchAlertContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchAlertContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchAlertContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_ids: str = None,
        contact_group_name: str = None,
        contact_id: int = None,
        contact_name: str = None,
        is_detail: bool = None,
        region_id: str = None,
    ):
        # The ID of the alert contact group. You can query multiple alert contact groups at a time. Separate multiple group IDs with commas (,).
        self.contact_group_ids = contact_group_ids
        # The name of the alert contact group.
        self.contact_group_name = contact_group_name
        # The ID of the alert contact. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](https://help.aliyun.com/document_detail/130703.html).
        self.contact_id = contact_id
        # The name of the alert contact.
        self.contact_name = contact_name
        # Specifies whether to return all alert contacts in the queried alert contact group. By default, not all alert contacts are returned.
        self.is_detail = is_detail
        # The ID of the region. Default value: `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_ids is not None:
            result['ContactGroupIds'] = self.contact_group_ids
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.is_detail is not None:
            result['IsDetail'] = self.is_detail
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupIds') is not None:
            self.contact_group_ids = m.get('ContactGroupIds')
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('IsDetail') is not None:
            self.is_detail = m.get('IsDetail')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SearchAlertContactGroupResponseBodyContactGroupsContacts(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
        contact_name: str = None,
        create_time: int = None,
        ding_robot: str = None,
        email: str = None,
        phone: str = None,
        system_noc: bool = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The ID of the alert contact.
        self.contact_id = contact_id
        # The name of the alert contact.
        self.contact_name = contact_name
        # The time when the alert contact group list was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The webhook URL of the DingTalk chatbot.
        self.ding_robot = ding_robot
        # The email address of the alert contact.
        self.email = email
        # The mobile number of the alert contact.
        self.phone = phone
        # Indicates whether the alert contact receives system notifications. Valid values:
        # 
        # *   true: receives system notifications.
        # *   false: does not receive system notifications.
        self.system_noc = system_noc
        # The time when the alert contact group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.ding_robot is not None:
            result['DingRobot'] = self.ding_robot
        if self.email is not None:
            result['Email'] = self.email
        if self.phone is not None:
            result['Phone'] = self.phone
        if self.system_noc is not None:
            result['SystemNoc'] = self.system_noc
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DingRobot') is not None:
            self.ding_robot = m.get('DingRobot')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        if m.get('SystemNoc') is not None:
            self.system_noc = m.get('SystemNoc')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchAlertContactGroupResponseBodyContactGroups(TeaModel):
    def __init__(
        self,
        contact_group_id: int = None,
        contact_group_name: str = None,
        contacts: List[SearchAlertContactGroupResponseBodyContactGroupsContacts] = None,
        create_time: int = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The ID of the alert contact group.
        self.contact_group_id = contact_group_id
        # The name of the alert contact group.
        self.contact_group_name = contact_group_name
        # The alert contact list.
        self.contacts = contacts
        # The time when the alert contact group list was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time
        # The time when the alert contact group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        result['Contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['Contacts'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        self.contacts = []
        if m.get('Contacts') is not None:
            for k in m.get('Contacts'):
                temp_model = SearchAlertContactGroupResponseBodyContactGroupsContacts()
                self.contacts.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchAlertContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        contact_groups: List[SearchAlertContactGroupResponseBodyContactGroups] = None,
        request_id: str = None,
    ):
        # The information about the alert contact groups.
        self.contact_groups = contact_groups
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.contact_groups:
            for k in self.contact_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactGroups'] = []
        if self.contact_groups is not None:
            for k in self.contact_groups:
                result['ContactGroups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.contact_groups = []
        if m.get('ContactGroups') is not None:
            for k in m.get('ContactGroups'):
                temp_model = SearchAlertContactGroupResponseBodyContactGroups()
                self.contact_groups.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchAlertContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchAlertContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchAlertContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchAlertHistoriesRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_type: int = None,
        current_page: int = None,
        end_time: int = None,
        page_size: int = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
        self.alert_id = alert_id
        # The type of the alert rule. Valid values:
        # 
        # *   `1`: a custom alert rule that is used to monitor drill-down data sets
        # *   `3`: a custom alert rule that is used to monitor tiled data sets
        # *   `4`: an alert rule that is used to monitor web pages, including the default alert rule for browser monitoring
        # *   `5`: an alert rule that is used to monitor applications, including the default alert rule for application monitoring
        # *   `6`: the default alert rule for browser monitoring
        # *   `7`: the default alert rule for application monitoring
        # *   `8`: a Tracing Analysis alert rule
        # *   `101`: a Prometheus alert rule
        self.alert_type = alert_type
        # The number of the page to return. Default value: `1`.
        self.current_page = current_page
        # The end of the time range to query. The value is a UNIX timestamp of the LONG data type. Unit: milliseconds. The default value is the current time.
        self.end_time = end_time
        # The number of entries to return on each page. Default value: `10`.
        self.page_size = page_size
        # The ID of the region. Default value: `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The beginning of the time range to query. The value is a UNIX timestamp of the LONG data type. Unit: milliseconds. The default value is 10 minutes before the current time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SearchAlertHistoriesResponseBodyPageBeanAlarmHistories(TeaModel):
    def __init__(
        self,
        alarm_content: str = None,
        alarm_response_code: int = None,
        alarm_sources: str = None,
        alarm_time: int = None,
        alarm_type: int = None,
        emails: str = None,
        id: int = None,
        phones: str = None,
        strategy_id: str = None,
        target: str = None,
        user_id: str = None,
    ):
        # The content of the alert notification.
        self.alarm_content = alarm_content
        # The response code returned after the alert notification was sent.
        self.alarm_response_code = alarm_response_code
        # The webhook URL, such as the webhook URL of a DingTalk chatbot.
        self.alarm_sources = alarm_sources
        # The time when the alert notification was sent.
        self.alarm_time = alarm_time
        # The type of the alert rule. Default value: 4. Valid values:
        # 
        # *   `1`: a custom alert rule that is used to monitor drill-down data sets
        # *   `3`: a custom alert rule that is used to monitor tiled data sets
        # *   `4`: an alert rule that is used to monitor web pages, including the default alert rule for browser monitoring
        # *   `5`: an alert rule that is used to monitor applications, including the default alert rule for application monitoring
        # *   `6`: the default alert rule for browser monitoring
        # *   `7`: the default alert rule for application monitoring
        # *   `8`: a Tracing Analysis alert rule
        # *   `101`: a Prometheus alert rule
        self.alarm_type = alarm_type
        # The email address of the alert contact.
        self.emails = emails
        # The ID of the alert notification.
        self.id = id
        # The mobile phone number of the alert contact.
        self.phones = phones
        # The internal fields.
        self.strategy_id = strategy_id
        # The internal fields.
        self.target = target
        # The ID of the user.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_content is not None:
            result['AlarmContent'] = self.alarm_content
        if self.alarm_response_code is not None:
            result['AlarmResponseCode'] = self.alarm_response_code
        if self.alarm_sources is not None:
            result['AlarmSources'] = self.alarm_sources
        if self.alarm_time is not None:
            result['AlarmTime'] = self.alarm_time
        if self.alarm_type is not None:
            result['AlarmType'] = self.alarm_type
        if self.emails is not None:
            result['Emails'] = self.emails
        if self.id is not None:
            result['Id'] = self.id
        if self.phones is not None:
            result['Phones'] = self.phones
        if self.strategy_id is not None:
            result['StrategyId'] = self.strategy_id
        if self.target is not None:
            result['Target'] = self.target
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmContent') is not None:
            self.alarm_content = m.get('AlarmContent')
        if m.get('AlarmResponseCode') is not None:
            self.alarm_response_code = m.get('AlarmResponseCode')
        if m.get('AlarmSources') is not None:
            self.alarm_sources = m.get('AlarmSources')
        if m.get('AlarmTime') is not None:
            self.alarm_time = m.get('AlarmTime')
        if m.get('AlarmType') is not None:
            self.alarm_type = m.get('AlarmType')
        if m.get('Emails') is not None:
            self.emails = m.get('Emails')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Phones') is not None:
            self.phones = m.get('Phones')
        if m.get('StrategyId') is not None:
            self.strategy_id = m.get('StrategyId')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchAlertHistoriesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        alarm_histories: List[SearchAlertHistoriesResponseBodyPageBeanAlarmHistories] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The information about alert records.
        self.alarm_histories = alarm_histories
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.alarm_histories:
            for k in self.alarm_histories:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlarmHistories'] = []
        if self.alarm_histories is not None:
            for k in self.alarm_histories:
                result['AlarmHistories'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alarm_histories = []
        if m.get('AlarmHistories') is not None:
            for k in m.get('AlarmHistories'):
                temp_model = SearchAlertHistoriesResponseBodyPageBeanAlarmHistories()
                self.alarm_histories.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchAlertHistoriesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: SearchAlertHistoriesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = SearchAlertHistoriesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchAlertHistoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchAlertHistoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchAlertHistoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchAlertRulesRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag. The following system preset fields are provided:
        # 
        # *   traceId: the ID of the trace.
        # *   serverApp: the name of the server application.
        # *   clientApp: the name of the client application.
        # *   service: the name of the operation.
        # *   rpc: the type of the call.
        # *   msOfSpan: the duration exceeds a specific value.
        # *   clientIp: the IP address of the client.
        # *   serverIp: the IP address of the server.
        # *   isError: specifies whether the call is abnormal.
        # *   hasTprof: contains only thread profiling.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchAlertRulesRequest(TeaModel):
    def __init__(
        self,
        alert_rule_id: str = None,
        app_type: str = None,
        current_page: int = None,
        page_size: int = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        system_region_id: str = None,
        tags: List[SearchAlertRulesRequestTags] = None,
        title: str = None,
        type: str = None,
    ):
        # The id of AlertRule.
        self.alert_rule_id = alert_rule_id
        # The type of the application that is associated with the alert rule. Valid values:
        # 
        # *   `TRACE`: application
        # *   `RETCODE`: browser
        self.app_type = app_type
        # The page number of the page to return. Default value: `1`.
        self.current_page = current_page
        # The number of entries to return per page. Default value: `10`.
        self.page_size = page_size
        # The process identifier (PID) of the application that is associated with the alert rule. For more information about how to obtain the PID, see [Obtain the PID of an application](https://help.aliyun.com/document_detail/186100.html?spm=a2c4g.11186623.6.792.1b50654cqcDPyk#title-imy-7gj-qhr).
        self.pid = pid
        # The region ID of the alert data. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
        self.resource_group_id = resource_group_id
        # The region ID of the alert rule. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.
        self.system_region_id = system_region_id
        # The list of tags.
        self.tags = tags
        # The alert rule name.
        self.title = title
        # The alert rule type. Valid values:
        # 
        # *   `1`: custom alert rules that are used to monitor drill-down data sets
        # *   `3`: custom alert rules that are used to monitor tiled data sets
        # *   `4`: alert rules that are used to monitor the browser, including the default frontend alert rules
        # *   `5`: alert rules that are used to monitor applications, including the default application alert rules
        # *   `6`: the default browser alert rules
        # *   `7`: the default application alert rules
        # *   `8`: Tracing Analysis alert rules
        # *   `101`: Prometheus alert rules
        self.type = type

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_rule_id is not None:
            result['AlertRuleId'] = self.alert_rule_id
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.system_region_id is not None:
            result['SystemRegionId'] = self.system_region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertRuleId') is not None:
            self.alert_rule_id = m.get('AlertRuleId')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SystemRegionId') is not None:
            self.system_region_id = m.get('SystemRegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchAlertRulesRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext(TeaModel):
    def __init__(
        self,
        alarm_content_sub_title: str = None,
        alarm_content_template: str = None,
        content: str = None,
        sub_title: str = None,
    ):
        # The sub-title of the alert notification content.
        self.alarm_content_sub_title = alarm_content_sub_title
        # The template of the alert notification.
        self.alarm_content_template = alarm_content_template
        # The content of the alert notification.
        self.content = content
        # The sub-title of the alert notification.
        self.sub_title = sub_title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_content_sub_title is not None:
            result['AlarmContentSubTitle'] = self.alarm_content_sub_title
        if self.alarm_content_template is not None:
            result['AlarmContentTemplate'] = self.alarm_content_template
        if self.content is not None:
            result['Content'] = self.content
        if self.sub_title is not None:
            result['SubTitle'] = self.sub_title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmContentSubTitle') is not None:
            self.alarm_content_sub_title = m.get('AlarmContentSubTitle')
        if m.get('AlarmContentTemplate') is not None:
            self.alarm_content_template = m.get('AlarmContentTemplate')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('SubTitle') is not None:
            self.sub_title = m.get('SubTitle')
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules(TeaModel):
    def __init__(
        self,
        aggregates: str = None,
        alias: str = None,
        measure: str = None,
        nvalue: int = None,
        operator: str = None,
        value: float = None,
    ):
        # The aggregation logic of the metric data of the alert rule. Valid values:
        # 
        # *   `AVG`: calculates the average value for each minute
        # *   `SUM`: calculates the total value for each minute
        # *   `MAX`: calculates the maximum value for each minute
        # *   `MIN`: calculates the minimum value for each minute
        self.aggregates = aggregates
        # The displayed description of the alert metric.
        self.alias = alias
        # The metric based on which alerts are triggered. For more information, see the "[Alert metrics](https://help.aliyun.com/document_detail/175825.html#h2-url-4)" section in this topic.
        self.measure = measure
        # The time range when data is requested. Unit: minutes. For example, a value of 5 indicates that the alert rule applies to the data in the last 5 minutes.
        self.nvalue = nvalue
        # The operation logic of the condition. Valid values:
        # 
        # *   CURRENT_GTE: greater than or equal to
        # *   CURRENT_LTE: less than or equal to
        # *   PREVIOUS_UP: the increase percentage compared with the last period
        # *   PREVIOUS_DOWN: the decrease percentage compared with the last period
        # *   HOH_UP: the increase percentage compared with the last hour
        # *   HOH_DOWN: the decrease percentage compared with the last hour
        # *   DOD_UP: the increase percentage compared with the last day
        # *   DOD_DOWN: the decrease percentage compared with the last day
        self.operator = operator
        # The threshold of the condition.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregates is not None:
            result['Aggregates'] = self.aggregates
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.measure is not None:
            result['Measure'] = self.measure
        if self.nvalue is not None:
            result['NValue'] = self.nvalue
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Aggregates') is not None:
            self.aggregates = m.get('Aggregates')
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Measure') is not None:
            self.measure = m.get('Measure')
        if m.get('NValue') is not None:
            self.nvalue = m.get('NValue')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule(TeaModel):
    def __init__(
        self,
        operator: str = None,
        rules: List[SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules] = None,
    ):
        # The logical operator between conditions. Valid values: `&`: AND. `|`: OR.
        self.operator = operator
        # The condition of the alert rule.
        self.rules = rules

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules()
                self.rules.append(temp_model.from_map(k))
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions(TeaModel):
    def __init__(
        self,
        key: str = None,
        type: str = None,
        value: str = None,
    ):
        # The key of the dimension. Valid values:
        # 
        # *   `rpc`: the name of the API
        # *   `rpcType`: the type of the API call, such as HTTP or DUBBO
        # *   `endpoint`: the name of the database
        # *   `rootIp`: the IP address of the host
        self.key = key
        # The type of the dimension. Valid values:
        # 
        # *   `STATIC`: checks only the value of this dimension. In this case, you must set the **dimensions.value** parameter.
        # *   `ALL`: checks the values of all dimensions. The metrics of all API calls are checked. If an API call triggers an alert, the name of the API is displayed in the alert notification. In this case, you do not need to set the **dimensions.value** parameter.
        # *   `DISABLE`: aggregates the values of all dimensions. In this case, you do not need to set the **dimensions.value** parameter.
        self.type = type
        # The value of the dimension.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam(TeaModel):
    def __init__(
        self,
        app_group_id: str = None,
        app_id: str = None,
        dimensions: List[SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions] = None,
        pid: str = None,
        type: str = None,
    ):
        # The ID of the application group that is associated with the alert rule. This parameter is applicable to Enterprise Distributed Application Service (EDAS) applications.
        self.app_group_id = app_group_id
        # The auto-increment ID of the ARMS application. You can ignore this ID.
        self.app_id = app_id
        # The dimensions in the condition.
        self.dimensions = dimensions
        # The PID of the application that is associated with the alert rule.
        self.pid = pid
        # The type of the metric. Valid values:
        # 
        # *   `txn`: the number of API calls during application monitoring
        # *   `txn_type`: the types of API calls during application monitoring
        # *   `db`: database metrics
        # *   `jvm`: Java virtual machine (JVM) metrics
        # *   `host`: host metrics
        # *   `exception`: API call errors
        self.type = type

    def validate(self):
        if self.dimensions:
            for k in self.dimensions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_group_id is not None:
            result['AppGroupId'] = self.app_group_id
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Dimensions'] = []
        if self.dimensions is not None:
            for k in self.dimensions:
                result['Dimensions'].append(k.to_map() if k else None)
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppGroupId') is not None:
            self.app_group_id = m.get('AppGroupId')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.dimensions = []
        if m.get('Dimensions') is not None:
            for k in m.get('Dimensions'):
                temp_model = SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions()
                self.dimensions.append(temp_model.from_map(k))
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRulesNotice(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        notice_end_time: int = None,
        notice_start_time: int = None,
        start_time: int = None,
    ):
        # The end of the time range when the alert rule takes effect within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
        self.end_time = end_time
        # The end of the time range when alert notifications are sent based on the alert rule within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
        self.notice_end_time = notice_end_time
        # The beginning of the time range when alert notifications are sent based on the alert rule within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
        self.notice_start_time = notice_start_time
        # The beginning of the time range when the alert rule takes effect within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.notice_end_time is not None:
            result['NoticeEndTime'] = self.notice_end_time
        if self.notice_start_time is not None:
            result['NoticeStartTime'] = self.notice_start_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NoticeEndTime') is not None:
            self.notice_end_time = m.get('NoticeEndTime')
        if m.get('NoticeStartTime') is not None:
            self.notice_start_time = m.get('NoticeStartTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SearchAlertRulesResponseBodyPageBeanAlertRules(TeaModel):
    def __init__(
        self,
        alarm_context: SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext = None,
        alert_level: str = None,
        alert_rule: SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule = None,
        alert_title: str = None,
        alert_type: int = None,
        alert_version: int = None,
        alert_ways: List[str] = None,
        config: str = None,
        contact_group_id_list: str = None,
        contact_group_ids: str = None,
        create_time: int = None,
        host_by_alert_manager: bool = None,
        id: int = None,
        metric_param: SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam = None,
        notice: SearchAlertRulesResponseBodyPageBeanAlertRulesNotice = None,
        region_id: str = None,
        resource_group_id: str = None,
        status: str = None,
        task_id: int = None,
        task_status: str = None,
        title: str = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The format of the alert notification.
        self.alarm_context = alarm_context
        # The severity of the alerts. Only the value `WARN` is supported.
        self.alert_level = alert_level
        # The conditions of the alert rule. Multiple conditions are separated by the AND or OR logical operators.
        self.alert_rule = alert_rule
        # The name of the alert rule.
        self.alert_title = alert_title
        # The type of the alert rule. Valid values:
        # 
        # *   `1`: custom alert rules that are used to monitor drill-down data sets
        # *   `3`: custom alert rules that are used to monitor tiled data sets
        # *   `4`: alert rules that are used to monitor the browser, including the default frontend alert rules
        # *   `5`: alert rules that are used to monitor applications, including the default application alert rules
        # *   `6`: the default browser alert rules
        # *   `7`: the default application alert rules
        # *   `8`: Tracing Analysis alert rules
        # *   `101`: Prometheus alert rules
        self.alert_type = alert_type
        # The version of the alert rule. Default value: `1`.
        self.alert_version = alert_version
        # Sending method of alarm notification.
        self.alert_ways = alert_ways
        # The configuration items of the alert rule. The value is a JSON string.
        # 
        # The configuration item **continuous** indicates whether alert notifications are continuously sent. Valid values:
        # 
        # *   `true`: Alert notifications are sent every minute.
        # *   `false`: The alert silence feature is enabled.
        # 
        # The configuration item **dataRevision** indicates the data revision policy that is used if no data is obtained or the data is null. Default value: 2. Valid values:
        # 
        # *   `0`: overwrites the data by using the value 0
        # *   `1`: overwrites the data by using the value 1
        # *   `2`: overwrites the data by using the value null. This value indicates that no alert is triggered if no data exists
        self.config = config
        # The ID of the contact group. Multiple IDs are separated by commas (,).
        self.contact_group_id_list = contact_group_id_list
        # The IDs of the alert contact groups. The value is a JSON array.
        self.contact_group_ids = contact_group_ids
        # The timestamp that shows when the alert rule was created.
        self.create_time = create_time
        # Indicates whether the alert is sent through the alert center. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.host_by_alert_manager = host_by_alert_manager
        # The ID of the alert rule.
        self.id = id
        # The information about the application that is associated with the alert rule.
        self.metric_param = metric_param
        # The time ranges when the alert rule takes effect and when alert notifications are sent.
        self.notice = notice
        # The ID of the region to which the alert rule belongs.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The status of the alert rule. `RUNNING`: The alert rule is enabled. `STOPPED`: The alert rule is disabled.
        self.status = status
        # The ID of the Application Real-Time Monitoring Service (ARMS) task that is associated with the alert rule.
        self.task_id = task_id
        # The status of the task. This parameter is hidden from users.
        self.task_status = task_status
        # The name of the alert.
        self.title = title
        # The timestamp that shows when the alert rule was updated.
        self.update_time = update_time
        # The ID of the user to which the alert rule belongs.
        self.user_id = user_id

    def validate(self):
        if self.alarm_context:
            self.alarm_context.validate()
        if self.alert_rule:
            self.alert_rule.validate()
        if self.metric_param:
            self.metric_param.validate()
        if self.notice:
            self.notice.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_context is not None:
            result['AlarmContext'] = self.alarm_context.to_map()
        if self.alert_level is not None:
            result['AlertLevel'] = self.alert_level
        if self.alert_rule is not None:
            result['AlertRule'] = self.alert_rule.to_map()
        if self.alert_title is not None:
            result['AlertTitle'] = self.alert_title
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.alert_version is not None:
            result['AlertVersion'] = self.alert_version
        if self.alert_ways is not None:
            result['AlertWays'] = self.alert_ways
        if self.config is not None:
            result['Config'] = self.config
        if self.contact_group_id_list is not None:
            result['ContactGroupIdList'] = self.contact_group_id_list
        if self.contact_group_ids is not None:
            result['ContactGroupIds'] = self.contact_group_ids
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.host_by_alert_manager is not None:
            result['HostByAlertManager'] = self.host_by_alert_manager
        if self.id is not None:
            result['Id'] = self.id
        if self.metric_param is not None:
            result['MetricParam'] = self.metric_param.to_map()
        if self.notice is not None:
            result['Notice'] = self.notice.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.title is not None:
            result['Title'] = self.title
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlarmContext') is not None:
            temp_model = SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext()
            self.alarm_context = temp_model.from_map(m['AlarmContext'])
        if m.get('AlertLevel') is not None:
            self.alert_level = m.get('AlertLevel')
        if m.get('AlertRule') is not None:
            temp_model = SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule()
            self.alert_rule = temp_model.from_map(m['AlertRule'])
        if m.get('AlertTitle') is not None:
            self.alert_title = m.get('AlertTitle')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('AlertVersion') is not None:
            self.alert_version = m.get('AlertVersion')
        if m.get('AlertWays') is not None:
            self.alert_ways = m.get('AlertWays')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('ContactGroupIdList') is not None:
            self.contact_group_id_list = m.get('ContactGroupIdList')
        if m.get('ContactGroupIds') is not None:
            self.contact_group_ids = m.get('ContactGroupIds')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('HostByAlertManager') is not None:
            self.host_by_alert_manager = m.get('HostByAlertManager')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MetricParam') is not None:
            temp_model = SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam()
            self.metric_param = temp_model.from_map(m['MetricParam'])
        if m.get('Notice') is not None:
            temp_model = SearchAlertRulesResponseBodyPageBeanAlertRulesNotice()
            self.notice = temp_model.from_map(m['Notice'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchAlertRulesResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        alert_rules: List[SearchAlertRulesResponseBodyPageBeanAlertRules] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The details of the alert rules.
        self.alert_rules = alert_rules
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.alert_rules:
            for k in self.alert_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertRules'] = []
        if self.alert_rules is not None:
            for k in self.alert_rules:
                result['AlertRules'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.alert_rules = []
        if m.get('AlertRules') is not None:
            for k in m.get('AlertRules'):
                temp_model = SearchAlertRulesResponseBodyPageBeanAlertRules()
                self.alert_rules.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchAlertRulesResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: SearchAlertRulesResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = SearchAlertRulesResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchAlertRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchAlertRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchAlertRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchEventsRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_type: int = None,
        app_type: str = None,
        current_page: int = None,
        end_time: int = None,
        is_trigger: int = None,
        page_size: int = None,
        pid: str = None,
        region_id: str = None,
        start_time: int = None,
    ):
        # The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
        self.alert_id = alert_id
        # The type of the alert rule. Valid values:
        # 
        # *   `1`: custom alert rules to monitor drill-down data sets
        # *   `3`: custom alert rules to monitor tiled data sets
        # *   `4`: alert rules to monitor the frontend, including the default frontend alert rules
        # *   `5`: alert rules to monitor applications, including the default application alert rules
        # *   `6`: the default frontend alert rules
        # *   `7`: the default application alert rules
        # *   `8`: Tracing Analysis alert rules
        # *   `101`: Prometheus alert rules
        self.alert_type = alert_type
        # The type of the application that is associated with the alert rule. Valid values:
        # 
        # *   `TRACE`: application monitoring
        # *   `RETCODE`: frontend monitoring
        self.app_type = app_type
        # The number of the page to return. Default value: `1`.
        self.current_page = current_page
        # The end of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is the current time.
        self.end_time = end_time
        # Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:
        # 
        # *   `1`: The event is triggered.
        # *   `0`: The event is not triggered.
        self.is_trigger = is_trigger
        # The number of entries to return on each page. Default value: `10`.
        self.page_size = page_size
        # The process identifier (PID) of the application that is associated with the alert rule.
        self.pid = pid
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The beginning of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is 10 minutes before the current time.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.is_trigger is not None:
            result['IsTrigger'] = self.is_trigger
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IsTrigger') is not None:
            self.is_trigger = m.get('IsTrigger')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class SearchEventsResponseBodyPageBeanEvent(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_name: str = None,
        alert_rule: str = None,
        alert_type: int = None,
        event_level: str = None,
        event_time: int = None,
        id: int = None,
        links: List[str] = None,
        message: str = None,
    ):
        # The ID of the alert rule that is associated with the event.
        self.alert_id = alert_id
        # The name of the alert rule that is associated with the event.
        self.alert_name = alert_name
        # The condition of the alert rule.
        self.alert_rule = alert_rule
        # The type of the alert rule. This parameter is not returned. Valid values:
        # 
        # *   `1`: custom alert rules to monitor drill-down data sets
        # *   `3`: custom alert rules to monitor tiled data sets
        # *   `4`: alert rules to monitor the frontend, including the default frontend alert rules
        # *   `5`: alert rules to monitor applications, including the default application alert rules
        # *   `6`: the default frontend alert rules
        # *   `7`: the default application alert rules
        # *   `8`: Tracing Analysis alert rules
        # *   `101`: Prometheus alert rules
        self.alert_type = alert_type
        # The severity of the event.
        self.event_level = event_level
        # The timestamp when the event occurred.
        self.event_time = event_time
        # The ID of the event record.
        self.id = id
        # The list of event URLs.
        self.links = links
        # The event content. The parameter value is a JSON string. Each key indicates a dimension and each value indicates the alert content in the dimension.
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.alert_rule is not None:
            result['AlertRule'] = self.alert_rule
        if self.alert_type is not None:
            result['AlertType'] = self.alert_type
        if self.event_level is not None:
            result['EventLevel'] = self.event_level
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        if self.id is not None:
            result['Id'] = self.id
        if self.links is not None:
            result['Links'] = self.links
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('AlertRule') is not None:
            self.alert_rule = m.get('AlertRule')
        if m.get('AlertType') is not None:
            self.alert_type = m.get('AlertType')
        if m.get('EventLevel') is not None:
            self.event_level = m.get('EventLevel')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Links') is not None:
            self.links = m.get('Links')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class SearchEventsResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        event: List[SearchEventsResponseBodyPageBeanEvent] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # The information about the alert events.
        self.event = event
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count

    def validate(self):
        if self.event:
            for k in self.event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Event'] = []
        if self.event is not None:
            for k in self.event:
                result['Event'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event = []
        if m.get('Event') is not None:
            for k in m.get('Event'):
                temp_model = SearchEventsResponseBodyPageBeanEvent()
                self.event.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchEventsResponseBody(TeaModel):
    def __init__(
        self,
        is_trigger: int = None,
        page_bean: SearchEventsResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:
        # 
        # *   `1`: The event is triggered.
        # *   `0`: The event is not triggered.
        self.is_trigger = is_trigger
        # The struct returned.
        self.page_bean = page_bean
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_trigger is not None:
            result['IsTrigger'] = self.is_trigger
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsTrigger') is not None:
            self.is_trigger = m.get('IsTrigger')
        if m.get('PageBean') is not None:
            temp_model = SearchEventsResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchEventsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchEventsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchRetcodeAppByPageRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchRetcodeAppByPageRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        resource_group_id: str = None,
        retcode_app_id: str = None,
        retcode_app_name: str = None,
        tags: List[SearchRetcodeAppByPageRequestTags] = None,
    ):
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page.
        self.page_size = page_size
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
        self.resource_group_id = resource_group_id
        # The application ID.
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the browser address bar contains the pid of this application in the format of `pid=xxx`. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `xxx%4074xxx`, you must replace **%40** with the at sign (@). The actual PID is `xxx@74xxx`.
        self.retcode_app_id = retcode_app_id
        # The name of the application.
        self.retcode_app_name = retcode_app_name
        # The tag.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retcode_app_id is not None:
            result['RetcodeAppId'] = self.retcode_app_id
        if self.retcode_app_name is not None:
            result['RetcodeAppName'] = self.retcode_app_name
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetcodeAppId') is not None:
            self.retcode_app_id = m.get('RetcodeAppId')
        if m.get('RetcodeAppName') is not None:
            self.retcode_app_name = m.get('RetcodeAppName')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchRetcodeAppByPageRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        app_name: str = None,
        create_time: int = None,
        nick_name: str = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        retcode_app_type: str = None,
        tags: List[SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags] = None,
        type: str = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The ID of the application. The parameter is an auto-increment parameter.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The time when the task was created.
        self.create_time = create_time
        # The alias of the application.
        self.nick_name = nick_name
        # The process identifier (PID) of the application.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The type of the application. Valid values:
        # 
        # *   `web`: web application
        # *   `weex`: Weex mobile app
        # *   `mini_dd`: DingTalk mini program
        # *   `mini_alipay`: Alipay mini program
        # *   `mini_wx`: WeChat mini program
        # *   `mini_common`: mini program on other platforms
        self.retcode_app_type = retcode_app_type
        # The tag.
        self.tags = tags
        # The type of the monitoring task. Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: Browser Monitoring
        self.type = type
        # The time when the task was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retcode_app_type is not None:
            result['RetcodeAppType'] = self.retcode_app_type
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetcodeAppType') is not None:
            self.retcode_app_type = m.get('RetcodeAppType')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchRetcodeAppByPageResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        retcode_apps: List[SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps] = None,
        total_count: int = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The browser monitoring tasks that are returned.
        self.retcode_apps = retcode_apps
        # The total number of returned entries.
        self.total_count = total_count

    def validate(self):
        if self.retcode_apps:
            for k in self.retcode_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RetcodeApps'] = []
        if self.retcode_apps is not None:
            for k in self.retcode_apps:
                result['RetcodeApps'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.retcode_apps = []
        if m.get('RetcodeApps') is not None:
            for k in m.get('RetcodeApps'):
                temp_model = SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps()
                self.retcode_apps.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchRetcodeAppByPageResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: SearchRetcodeAppByPageResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned page information.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = SearchRetcodeAppByPageResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchRetcodeAppByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchRetcodeAppByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchRetcodeAppByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTraceAppByNameRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTraceAppByNameRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        tags: List[SearchTraceAppByNameRequestTags] = None,
        trace_app_name: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The list of tags.
        self.tags = tags
        # The name of the application.
        # 
        # > If you do not specify this parameter, all application monitoring tasks in the specified region are queried.
        self.trace_app_name = trace_app_name

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.trace_app_name is not None:
            result['TraceAppName'] = self.trace_app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchTraceAppByNameRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TraceAppName') is not None:
            self.trace_app_name = m.get('TraceAppName')
        return self


class SearchTraceAppByNameResponseBodyTraceAppsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTraceAppByNameResponseBodyTraceApps(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        app_name: str = None,
        create_time: int = None,
        labels: List[str] = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        show: bool = None,
        tags: List[SearchTraceAppByNameResponseBodyTraceAppsTags] = None,
        type: str = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The timestamp generated when the task was created.
        self.create_time = create_time
        # The aliases of the application.
        self.labels = labels
        # The process identifier (PID) of the application.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
        # 
        # *   `true`: yes
        # *   `false`: no
        self.show = show
        # A list of tags.
        self.tags = tags
        # The type of the monitoring task. Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: Browser Monitoring
        self.type = type
        # The timestamp generated when the task information was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.show is not None:
            result['Show'] = self.show
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchTraceAppByNameResponseBodyTraceAppsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchTraceAppByNameResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        trace_apps: List[SearchTraceAppByNameResponseBodyTraceApps] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The information about the monitoring task.
        self.trace_apps = trace_apps

    def validate(self):
        if self.trace_apps:
            for k in self.trace_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TraceApps'] = []
        if self.trace_apps is not None:
            for k in self.trace_apps:
                result['TraceApps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.trace_apps = []
        if m.get('TraceApps') is not None:
            for k in m.get('TraceApps'):
                temp_model = SearchTraceAppByNameResponseBodyTraceApps()
                self.trace_apps.append(temp_model.from_map(k))
        return self


class SearchTraceAppByNameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTraceAppByNameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTraceAppByNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTraceAppByPageRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTraceAppByPageRequest(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[SearchTraceAppByPageRequestTags] = None,
        trace_app_name: str = None,
    ):
        # The number of the page to return. Default value: `1`.
        self.page_number = page_number
        # The number of entries to return on each page. Default value: `10`.
        self.page_size = page_size
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # A list of tags.
        self.tags = tags
        # The name of the application.
        self.trace_app_name = trace_app_name

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.trace_app_name is not None:
            result['TraceAppName'] = self.trace_app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchTraceAppByPageRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TraceAppName') is not None:
            self.trace_app_name = m.get('TraceAppName')
        return self


class SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTraceAppByPageResponseBodyPageBeanTraceApps(TeaModel):
    def __init__(
        self,
        app_id: int = None,
        app_name: str = None,
        create_time: int = None,
        labels: List[str] = None,
        pid: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        show: bool = None,
        tags: List[SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags] = None,
        type: str = None,
        update_time: int = None,
        user_id: str = None,
    ):
        # The application ID.
        self.app_id = app_id
        # The name of the application.
        self.app_name = app_name
        # The timestamp generated when the task was created.
        self.create_time = create_time
        # The aliases of the application.
        self.labels = labels
        # The process identifier (PID) of the application.
        self.pid = pid
        # The region ID.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
        # 
        # *   `true`: yes
        # *   `false`: no
        self.show = show
        # A list of tags.
        self.tags = tags
        # The type of the monitoring task. Valid values:
        # 
        # *   `TRACE`: Application Monitoring
        # *   `RETCODE`: Browser Monitoring
        self.type = type
        # The timestamp generated when the task information was updated.
        self.update_time = update_time
        # The user ID.
        self.user_id = user_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.show is not None:
            result['Show'] = self.show
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Show') is not None:
            self.show = m.get('Show')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class SearchTraceAppByPageResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
        trace_apps: List[SearchTraceAppByPageResponseBodyPageBeanTraceApps] = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total_count = total_count
        # The information about the monitoring task.
        self.trace_apps = trace_apps

    def validate(self):
        if self.trace_apps:
            for k in self.trace_apps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['TraceApps'] = []
        if self.trace_apps is not None:
            for k in self.trace_apps:
                result['TraceApps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.trace_apps = []
        if m.get('TraceApps') is not None:
            for k in m.get('TraceApps'):
                temp_model = SearchTraceAppByPageResponseBodyPageBeanTraceApps()
                self.trace_apps.append(temp_model.from_map(k))
        return self


class SearchTraceAppByPageResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: SearchTraceAppByPageResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The information about the array object.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = SearchTraceAppByPageResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchTraceAppByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTraceAppByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTraceAppByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTracesRequestExclusionFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key that is used to filter the query results.
        self.key = key
        # The value of the key that is used to filter the query results.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTracesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key. The following system preset fields are provided:
        # 
        # *   serverApp: the name of the server application.
        # *   clientApp: the name of the client application.
        # *   service: the name of the operation.
        # *   rpc: the type of the call.
        # *   msOfSpan: the duration exceeds a specific value.
        # *   clientIp: the IP address of the client.
        # *   serverIp: the IP address of the server.
        # *   isError: specifies whether the call is abnormal.
        # *   hasTprof: contains only thread profiling.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTracesRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        exclusion_filters: List[SearchTracesRequestExclusionFilters] = None,
        min_duration: int = None,
        operation_name: str = None,
        pid: str = None,
        region_id: str = None,
        reverse: bool = None,
        service_ip: str = None,
        service_name: str = None,
        start_time: int = None,
        tag: List[SearchTracesRequestTag] = None,
    ):
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter conditions.
        self.exclusion_filters = exclusion_filters
        # The minimum amount of time consumed by traces. Unit: milliseconds.
        self.min_duration = min_duration
        # The name of the traced span.
        self.operation_name = operation_name
        # The application ID.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
        # 
        # *   `true`: sorts the query results in reverse chronological order.
        # *   `false`: sorts the query results in chronological order.
        self.reverse = reverse
        # The IP address of the host where the application resides.
        self.service_ip = service_ip
        # The name of the application.
        self.service_name = service_name
        # The beginning of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The list of tags.
        self.tag = tag

    def validate(self):
        if self.exclusion_filters:
            for k in self.exclusion_filters:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['ExclusionFilters'] = []
        if self.exclusion_filters is not None:
            for k in self.exclusion_filters:
                result['ExclusionFilters'].append(k.to_map() if k else None)
        if self.min_duration is not None:
            result['MinDuration'] = self.min_duration
        if self.operation_name is not None:
            result['OperationName'] = self.operation_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.exclusion_filters = []
        if m.get('ExclusionFilters') is not None:
            for k in m.get('ExclusionFilters'):
                temp_model = SearchTracesRequestExclusionFilters()
                self.exclusion_filters.append(temp_model.from_map(k))
        if m.get('MinDuration') is not None:
            self.min_duration = m.get('MinDuration')
        if m.get('OperationName') is not None:
            self.operation_name = m.get('OperationName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = SearchTracesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class SearchTracesResponseBodyTraceInfos(TeaModel):
    def __init__(
        self,
        duration: int = None,
        operation_name: str = None,
        service_ip: str = None,
        service_name: str = None,
        span_id: str = None,
        timestamp: int = None,
        trace_id: str = None,
    ):
        # The amount of time consumed by the trace. Unit: milliseconds.
        self.duration = duration
        # The name of the traced span.
        self.operation_name = operation_name
        # The IP address of the host where the application resides.
        self.service_ip = service_ip
        # The name of the application.
        self.service_name = service_name
        self.span_id = span_id
        # The timestamp.
        self.timestamp = timestamp
        # The trace ID.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.operation_name is not None:
            result['OperationName'] = self.operation_name
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.span_id is not None:
            result['SpanID'] = self.span_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OperationName') is not None:
            self.operation_name = m.get('OperationName')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('SpanID') is not None:
            self.span_id = m.get('SpanID')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class SearchTracesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        trace_infos: List[SearchTracesResponseBodyTraceInfos] = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The details of the returned traces.
        self.trace_infos = trace_infos

    def validate(self):
        if self.trace_infos:
            for k in self.trace_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TraceInfos'] = []
        if self.trace_infos is not None:
            for k in self.trace_infos:
                result['TraceInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.trace_infos = []
        if m.get('TraceInfos') is not None:
            for k in m.get('TraceInfos'):
                temp_model = SearchTracesResponseBodyTraceInfos()
                self.trace_infos.append(temp_model.from_map(k))
        return self


class SearchTracesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTracesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTracesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchTracesByPageRequestExclusionFilters(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key that is used to filter the query results.
        self.key = key
        # The value of the key that is used to filter the query results.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTracesByPageRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag. The following system preset fields are provided:
        # 
        # *   traceId: the ID of the trace.
        # *   serverApp: the name of the server application.
        # *   clientApp: the name of the client application.
        # *   service: the name of the interface.
        # *   rpc: the type of the call.
        # *   msOfSpan: the duration exceeds a specific value.
        # *   clientIp: the IP address of the client.
        # *   serverIp: the IP address of the server.
        # *   isError: specifies whether the call is abnormal.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class SearchTracesByPageRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        exclusion_filters: List[SearchTracesByPageRequestExclusionFilters] = None,
        is_error: bool = None,
        min_duration: int = None,
        operation_name: str = None,
        page_number: int = None,
        page_size: int = None,
        pid: str = None,
        region_id: str = None,
        reverse: bool = None,
        service_ip: str = None,
        service_name: str = None,
        start_time: int = None,
        tags: List[SearchTracesByPageRequestTags] = None,
    ):
        # The end of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.end_time = end_time
        # The filter conditions.
        self.exclusion_filters = exclusion_filters
        # Specifies whether to include the traces of abnormal calls.
        # 
        # *   `true`: No
        # *   `false` (default): Yes
        self.is_error = is_error
        # The minimum amount of time consumed by traces. Unit: milliseconds.
        self.min_duration = min_duration
        # The name of the traced span.
        self.operation_name = operation_name
        # The number of the page to return.
        self.page_number = page_number
        # The number of entries to return on each page. Maximum value: 100.
        self.page_size = page_size
        # The application ID.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
        # 
        # *   `true`: sorts the query results in reverse chronological order.
        # *   `false`: sorts the query results in chronological order.
        self.reverse = reverse
        # The IP address of the host where the application resides.
        self.service_ip = service_ip
        # The name of the application.
        self.service_name = service_name
        # The beginning of the time range to query. Unit: milliseconds.
        # 
        # This parameter is required.
        self.start_time = start_time
        # The list of tags.
        self.tags = tags

    def validate(self):
        if self.exclusion_filters:
            for k in self.exclusion_filters:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['ExclusionFilters'] = []
        if self.exclusion_filters is not None:
            for k in self.exclusion_filters:
                result['ExclusionFilters'].append(k.to_map() if k else None)
        if self.is_error is not None:
            result['IsError'] = self.is_error
        if self.min_duration is not None:
            result['MinDuration'] = self.min_duration
        if self.operation_name is not None:
            result['OperationName'] = self.operation_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reverse is not None:
            result['Reverse'] = self.reverse
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.exclusion_filters = []
        if m.get('ExclusionFilters') is not None:
            for k in m.get('ExclusionFilters'):
                temp_model = SearchTracesByPageRequestExclusionFilters()
                self.exclusion_filters.append(temp_model.from_map(k))
        if m.get('IsError') is not None:
            self.is_error = m.get('IsError')
        if m.get('MinDuration') is not None:
            self.min_duration = m.get('MinDuration')
        if m.get('OperationName') is not None:
            self.operation_name = m.get('OperationName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Reverse') is not None:
            self.reverse = m.get('Reverse')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = SearchTracesByPageRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class SearchTracesByPageResponseBodyPageBeanTraceInfos(TeaModel):
    def __init__(
        self,
        duration: int = None,
        operation_name: str = None,
        service_ip: str = None,
        service_name: str = None,
        span_id: str = None,
        timestamp: int = None,
        trace_id: str = None,
    ):
        # The amount of time consumed by the trace. Unit: milliseconds.
        self.duration = duration
        # The name of the traced span.
        self.operation_name = operation_name
        # The IP address of the host where the application resides.
        self.service_ip = service_ip
        # The name of the application.
        self.service_name = service_name
        self.span_id = span_id
        # The timestamp.
        self.timestamp = timestamp
        # The trace ID.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.operation_name is not None:
            result['OperationName'] = self.operation_name
        if self.service_ip is not None:
            result['ServiceIp'] = self.service_ip
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        if self.span_id is not None:
            result['SpanID'] = self.span_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.trace_id is not None:
            result['TraceID'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OperationName') is not None:
            self.operation_name = m.get('OperationName')
        if m.get('ServiceIp') is not None:
            self.service_ip = m.get('ServiceIp')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        if m.get('SpanID') is not None:
            self.span_id = m.get('SpanID')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TraceID') is not None:
            self.trace_id = m.get('TraceID')
        return self


class SearchTracesByPageResponseBodyPageBean(TeaModel):
    def __init__(
        self,
        page_number: int = None,
        page_size: int = None,
        total: int = None,
        trace_infos: List[SearchTracesByPageResponseBodyPageBeanTraceInfos] = None,
    ):
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of returned entries.
        self.total = total
        # The details of the returned traces.
        self.trace_infos = trace_infos

    def validate(self):
        if self.trace_infos:
            for k in self.trace_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        result['TraceInfos'] = []
        if self.trace_infos is not None:
            for k in self.trace_infos:
                result['TraceInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        self.trace_infos = []
        if m.get('TraceInfos') is not None:
            for k in m.get('TraceInfos'):
                temp_model = SearchTracesByPageResponseBodyPageBeanTraceInfos()
                self.trace_infos.append(temp_model.from_map(k))
        return self


class SearchTracesByPageResponseBody(TeaModel):
    def __init__(
        self,
        page_bean: SearchTracesByPageResponseBodyPageBean = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.page_bean = page_bean
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.page_bean:
            self.page_bean.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_bean is not None:
            result['PageBean'] = self.page_bean.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageBean') is not None:
            temp_model = SearchTracesByPageResponseBodyPageBean()
            self.page_bean = temp_model.from_map(m['PageBean'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SearchTracesByPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SearchTracesByPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchTracesByPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendTTSVerifyLinkRequest(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
        phone: str = None,
    ):
        # The ID of the alert contact.
        # 
        # This parameter is required.
        self.contact_id = contact_id
        # The mobile number of the alert contact.
        # 
        # This parameter is required.
        self.phone = phone

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.phone is not None:
            result['Phone'] = self.phone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('Phone') is not None:
            self.phone = m.get('Phone')
        return self


class SendTTSVerifyLinkResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the text message was sent.
        # 
        # *   `true`
        # *   `false`
        self.is_success = is_success
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendTTSVerifyLinkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SendTTSVerifyLinkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendTTSVerifyLinkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetRetcodeShareStatusRequest(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        pid: str = None,
        status: bool = None,
    ):
        # The name of the application that is monitored by Browser Monitoring.
        self.app_name = app_name
        # The process identifier (PID) of the application. 
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the `pid=xxx` format. The PID is usually percent encoded as `xxx%40xxx`. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `eb4zdose6v%409781be0f44d****`, you must replace `%40` with @ to obtain `eb4zdose6v@9781be0f44d****`.
        self.pid = pid
        # Specifies whether to turn on or turn off the logon-free sharing switch. Valid values:
        # 
        # *   `true`: Turn on the switch.
        # *   `false`: Turn off the switch.
        # 
        # This parameter is required.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetRetcodeShareStatusResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call is successful. Valid values:
        # 
        # *   `true`: The call is successful.
        # *   `false`: The call fails.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetRetcodeShareStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetRetcodeShareStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetRetcodeShareStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartAlertRequest(TeaModel):
    def __init__(
        self,
        alert_id: str = None,
        region_id: str = None,
    ):
        # The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
        # 
        # This parameter is required.
        self.alert_id = alert_id
        # The ID of the region. Set the value to `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StartAlertResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartAlertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartAlertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartAlertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartTimingSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_ids: List[str] = None,
    ):
        # The region ID. Default value: cn-hangzhou.
        self.region_id = region_id
        # The task IDs.
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class StartTimingSyntheticTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_ids_shrink: str = None,
    ):
        # The region ID. Default value: cn-hangzhou.
        self.region_id = region_id
        # The task IDs.
        self.task_ids_shrink = task_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        return self


class StartTimingSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # Indicates whether the request was successful. Valid values: true and false.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartTimingSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartTimingSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartTimingSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopAlertRequest(TeaModel):
    def __init__(
        self,
        alert_id: str = None,
        region_id: str = None,
    ):
        # The ID of the alert rule.
        # 
        # This parameter is required.
        self.alert_id = alert_id
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StopAlertResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the request is successful. Valid values:
        # 
        # *   `true`: The request is successful.
        # *   `false`: The request fails.
        self.is_success = is_success
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopAlertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopAlertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopAlertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopTimingSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_ids: List[str] = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The task IDs.
        # 
        # This parameter is required.
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class StopTimingSyntheticTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        task_ids_shrink: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The task IDs.
        # 
        # This parameter is required.
        self.task_ids_shrink = task_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        return self


class StopTimingSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # Indicates whether the request was successful. Valid values: true and false.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopTimingSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopTimingSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopTimingSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SwitchSyntheticTaskStatusRequest(TeaModel):
    def __init__(
        self,
        switch_status: int = None,
        task_ids: List[int] = None,
    ):
        # Specifies whether to start or stop the task. Valid values:
        # 
        # *   **0**: stops the task
        # *   **1**: starts the task
        self.switch_status = switch_status
        # The task IDs. You can specify up to 30 task IDs at a time.
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.switch_status is not None:
            result['SwitchStatus'] = self.switch_status
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SwitchStatus') is not None:
            self.switch_status = m.get('SwitchStatus')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class SwitchSyntheticTaskStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class SwitchSyntheticTaskStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SwitchSyntheticTaskStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SwitchSyntheticTaskStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncRecordingRulesRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        region_id: str = None,
        target_clusters: str = None,
    ):
        # The ID of the cluster whose aggregation rule you want to synchronize.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The ID of the region. The destination region can be the same as the source region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The IDs of clusters to which you want to synchronize the aggregation rule.
        # 
        # This parameter is required.
        self.target_clusters = target_clusters

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.target_clusters is not None:
            result['TargetClusters'] = self.target_clusters
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TargetClusters') is not None:
            self.target_clusters = m.get('TargetClusters')
        return self


class SyncRecordingRulesResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # 200
        self.code = code
        # The struct returned.
        self.data = data
        # 
        self.message = message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SyncRecordingRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncRecordingRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncRecordingRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagResourcesRequest(TeaModel):
    def __init__(
        self,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag: List[TagResourcesRequestTag] = None,
    ):
        # The resource IDs. You can specify a maximum of 50 resource IDs.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the ARMS resources for which you want to modify tags. Valid values:
        # 
        # *   WEB: Browser Monitoring
        # *   APPLICATION: Application Monitoring
        # *   PROMETHEUS: Managed Service for Prometheus
        # *   SYNTHETICTASK: Synthetic Monitoring
        # *   ALERTRULE: Application Monitoring alert rule
        # *   PROMETHEUSALERTRULE: Managed Service for Prometheus alert rule
        # *   XTRACEAPP: Managed Service for OpenTelemetry
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tags to add to the resource. You can specify a maximum of 20 tags.
        # 
        # This parameter is required.
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The returned message.
        self.data = data
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallManagedPrometheusRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        cluster_type: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        vpc_id: str = None,
    ):
        # The ID of the Container Service for Kubernetes (ACK) cluster. This parameter is required when the ClusterType parameter is set to ask or one.
        self.cluster_id = cluster_id
        # The cluster type. Valid values: ask, ecs, and one.
        # 
        # This parameter is required.
        self.cluster_type = cluster_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group to which the Prometheus instance belongs.
        self.resource_group_id = resource_group_id
        # The ID of the virtual private cloud (VPC) where the cluster resides.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cluster_type is not None:
            result['ClusterType'] = self.cluster_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ClusterType') is not None:
            self.cluster_type = m.get('ClusterType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UninstallManagedPrometheusResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
        self.code = code
        # The response content. The status of the Prometheus instance is returned.
        self.data = data
        # The error message that is returned if the request fails.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the Prometheus instance was removed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UninstallManagedPrometheusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UninstallManagedPrometheusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallManagedPrometheusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallPromClusterRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        cluster_id: str = None,
        region_id: str = None,
    ):
        # Language environment(If left blank, defaults to zh):
        # - zh
        # - en
        self.aliyun_lang = aliyun_lang
        # The cluster ID.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UninstallPromClusterResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # Indicates whether the request was successful.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID. You can use the ID to find logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UninstallPromClusterResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UninstallPromClusterResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallPromClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(
        self,
        all: bool = None,
        resource_id: List[str] = None,
        resource_type: str = None,
        tag_key: List[str] = None,
        tags: List[UntagResourcesRequestTags] = None,
    ):
        # Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
        # 
        # *   true
        # *   false
        # 
        # Default value: false.
        self.all = all
        # The resource IDs. You can specify a maximum of 50 resource IDs.
        # 
        # This parameter is required.
        self.resource_id = resource_id
        # The type of the ARMS resources for which you want to modify tags. Valid values:
        # 
        # *   WEB: Browser Monitoring
        # *   APPLICATION: Application Monitoring
        # *   PROMETHEUS: Managed Service for Prometheus
        # *   SYNTHETICTASK: Synthetic Monitoring
        # *   ALERTRULE: Application Monitoring alert rule
        # *   PROMETHEUSALERTRULE: Managed Service for Prometheus alert rule
        # *   XTRACEAPP: Managed Service for OpenTelemetry
        # 
        # This parameter is required.
        self.resource_type = resource_type
        # The tag keys. You can specify a maximum of 20 tag keys.
        self.tag_key = tag_key
        # The list of tags.
        self.tags = tags

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UntagResourcesRequestTags()
                self.tags.append(temp_model.from_map(k))
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(
        self,
        data: str = None,
        request_id: str = None,
    ):
        # The returned struct.
        self.data = data
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UntagResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertContactRequest(TeaModel):
    def __init__(
        self,
        contact_id: int = None,
        contact_name: str = None,
        ding_robot_webhook_url: str = None,
        email: str = None,
        phone_num: str = None,
        region_id: str = None,
        system_noc: bool = None,
    ):
        # The ID of the alert contact to be updated. You can call the SearchAlertContact operation to query the contact ID. For more information, see [SearchAlertContact](https://help.aliyun.com/document_detail/130703.html).
        # 
        # This parameter is required.
        self.contact_id = contact_id
        # The new name of the alert contact.
        self.contact_name = contact_name
        # The new webhook URL of the DingTalk chatbot. For more information, see [Configure a DingTalk chatbot to send alert notifications](https://help.aliyun.com/document_detail/106247.html). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
        # 
        # >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
        self.ding_robot_webhook_url = ding_robot_webhook_url
        # The new email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
        # 
        # >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
        self.email = email
        # The new mobile phone number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
        # 
        # >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
        self.phone_num = phone_num
        # The ID of the region. Set the value to `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether the alert contact receives system notifications. Valid values:
        # 
        # *   `true`: The alert contact receives system notifications.
        # *   `false`: The alert contact does not receive system notifications.
        self.system_noc = system_noc

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.ding_robot_webhook_url is not None:
            result['DingRobotWebhookUrl'] = self.ding_robot_webhook_url
        if self.email is not None:
            result['Email'] = self.email
        if self.phone_num is not None:
            result['PhoneNum'] = self.phone_num
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.system_noc is not None:
            result['SystemNoc'] = self.system_noc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('DingRobotWebhookUrl') is not None:
            self.ding_robot_webhook_url = m.get('DingRobotWebhookUrl')
        if m.get('Email') is not None:
            self.email = m.get('Email')
        if m.get('PhoneNum') is not None:
            self.phone_num = m.get('PhoneNum')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SystemNoc') is not None:
            self.system_noc = m.get('SystemNoc')
        return self


class UpdateAlertContactResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the alert contact was updated. Valid values:
        # 
        # *   true: The alert contact was updated.
        # *   false: The alert contact failed to be updated.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAlertContactResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertContactResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertContactGroupRequest(TeaModel):
    def __init__(
        self,
        contact_group_id: int = None,
        contact_group_name: str = None,
        contact_ids: str = None,
        region_id: str = None,
    ):
        # The ID of the alert contact group.
        # 
        # This parameter is required.
        self.contact_group_id = contact_group_id
        # The name of the alert contact group.
        # 
        # This parameter is required.
        self.contact_group_name = contact_group_name
        # The ID of the alert contact.
        self.contact_ids = contact_ids
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_id is not None:
            result['ContactGroupId'] = self.contact_group_id
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.contact_ids is not None:
            result['ContactIds'] = self.contact_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContactGroupId') is not None:
            self.contact_group_id = m.get('ContactGroupId')
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('ContactIds') is not None:
            self.contact_ids = m.get('ContactIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateAlertContactGroupResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   `true`: The call was successful.
        # *   `false`: The call failed.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAlertContactGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertContactGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        contact_group_ids: str = None,
        is_auto_start: bool = None,
        region_id: str = None,
        templage_alert_config: str = None,
    ):
        # The ID of the alert rule.
        # 
        # This parameter is required.
        self.alert_id = alert_id
        # The IDs of the alert contact groups. The value must be a JSON array.
        self.contact_group_ids = contact_group_ids
        # Specifies whether to enable the alert rule after it is created. Default value: `false`.
        # 
        # *   `true`: enables the alert rule.
        # *   `false`: disables the alert rule.
        self.is_auto_start = is_auto_start
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.
        # 
        # This parameter is required.
        self.templage_alert_config = templage_alert_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.contact_group_ids is not None:
            result['ContactGroupIds'] = self.contact_group_ids
        if self.is_auto_start is not None:
            result['IsAutoStart'] = self.is_auto_start
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.templage_alert_config is not None:
            result['TemplageAlertConfig'] = self.templage_alert_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('ContactGroupIds') is not None:
            self.contact_group_ids = m.get('ContactGroupIds')
        if m.get('IsAutoStart') is not None:
            self.is_auto_start = m.get('IsAutoStart')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplageAlertConfig') is not None:
            self.templage_alert_config = m.get('TemplageAlertConfig')
        return self


class UpdateAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        data: str = None,
        request_id: str = None,
    ):
        # The ID of the alert rule.
        self.alert_id = alert_id
        # The struct returned.
        self.data = data
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDispatchRuleRequest(TeaModel):
    def __init__(
        self,
        dispatch_rule: str = None,
        region_id: str = None,
    ):
        # The dispatch rule configuration. The value is a JSON string. For more information about this parameter, see the following **additional information about the DispatchRule parameter**.
        # 
        # This parameter is required.
        self.dispatch_rule = dispatch_rule
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dispatch_rule is not None:
            result['DispatchRule'] = self.dispatch_rule
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DispatchRule') is not None:
            self.dispatch_rule = m.get('DispatchRule')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateDispatchRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   `true`: The request was successful.
        # *   `false`: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDispatchRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDispatchRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDispatchRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEnvCustomJobRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config_yaml: str = None,
        custom_job_name: str = None,
        environment_id: str = None,
        region_id: str = None,
        status: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The YAML configuration string.
        self.config_yaml = config_yaml
        # The name of the custom job.
        # 
        # This parameter is required.
        self.custom_job_name = custom_job_name
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The status of the custom job. Valid values: run and stop.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.custom_job_name is not None:
            result['CustomJobName'] = self.custom_job_name
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('CustomJobName') is not None:
            self.custom_job_name = m.get('CustomJobName')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdateEnvCustomJobResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code or error code.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEnvCustomJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEnvCustomJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEnvCustomJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEnvPodMonitorRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config_yaml: str = None,
        dry_run: bool = None,
        environment_id: str = None,
        namespace: str = None,
        pod_monitor_name: str = None,
        region_id: str = None,
    ):
        # The language. Valid values:
        # 
        # *   zh (default value): Chinese
        # *   en: English
        self.aliyun_lang = aliyun_lang
        # The YAML configuration file of the ServiceMonitor.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # Checks whether the format is valid and whether targets are matched.
        self.dry_run = dry_run
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The namespace where the PodMonitor resides.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The name of the PodMonitor.
        # 
        # This parameter is required.
        self.pod_monitor_name = pod_monitor_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.pod_monitor_name is not None:
            result['PodMonitorName'] = self.pod_monitor_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PodMonitorName') is not None:
            self.pod_monitor_name = m.get('PodMonitorName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateEnvPodMonitorResponseBodyData(TeaModel):
    def __init__(
        self,
        matched_msg: str = None,
        matched_target_count: str = None,
    ):
        # Indicates whether targets are matched.
        self.matched_msg = matched_msg
        # The number of matched targets.
        self.matched_target_count = matched_target_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.matched_msg is not None:
            result['MatchedMsg'] = self.matched_msg
        if self.matched_target_count is not None:
            result['MatchedTargetCount'] = self.matched_target_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MatchedMsg') is not None:
            self.matched_msg = m.get('MatchedMsg')
        if m.get('MatchedTargetCount') is not None:
            self.matched_target_count = m.get('MatchedTargetCount')
        return self


class UpdateEnvPodMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdateEnvPodMonitorResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The response code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateEnvPodMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEnvPodMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEnvPodMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEnvPodMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEnvServiceMonitorRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        config_yaml: str = None,
        dry_run: bool = None,
        environment_id: str = None,
        namespace: str = None,
        region_id: str = None,
        service_monitor_name: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The YAML configuration string.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # Specifies whether to perform only a dry run, without performing the actual request.
        self.dry_run = dry_run
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The namespace where the ServiceMonitor is located.
        # 
        # This parameter is required.
        self.namespace = namespace
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The name of the ServiceMonitor.
        # 
        # This parameter is required.
        self.service_monitor_name = service_monitor_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.service_monitor_name is not None:
            result['ServiceMonitorName'] = self.service_monitor_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ServiceMonitorName') is not None:
            self.service_monitor_name = m.get('ServiceMonitorName')
        return self


class UpdateEnvServiceMonitorResponseBodyData(TeaModel):
    def __init__(
        self,
        matched_msg: str = None,
        matched_target_count: str = None,
    ):
        # Indicates whether targets are matched.
        self.matched_msg = matched_msg
        # The number of matched targets.
        self.matched_target_count = matched_target_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.matched_msg is not None:
            result['MatchedMsg'] = self.matched_msg
        if self.matched_target_count is not None:
            result['MatchedTargetCount'] = self.matched_target_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MatchedMsg') is not None:
            self.matched_msg = m.get('MatchedMsg')
        if m.get('MatchedTargetCount') is not None:
            self.matched_target_count = m.get('MatchedTargetCount')
        return self


class UpdateEnvServiceMonitorResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdateEnvServiceMonitorResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateEnvServiceMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEnvServiceMonitorResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEnvServiceMonitorResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEnvServiceMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEnvironmentRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_id: str = None,
        environment_name: str = None,
        fee_package: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The name of the environment instance.
        self.environment_name = environment_name
        # The payable resource plan. Valid values:
        # 
        # *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
        # *   Otherwise, leave the parameter empty.
        self.fee_package = fee_package
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.environment_name is not None:
            result['EnvironmentName'] = self.environment_name
        if self.fee_package is not None:
            result['FeePackage'] = self.fee_package
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('EnvironmentName') is not None:
            self.environment_name = m.get('EnvironmentName')
        if m.get('FeePackage') is not None:
            self.fee_package = m.get('FeePackage')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateEnvironmentResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEnvironmentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEnvironmentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEnvironmentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGrafanaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        description: str = None,
        grafana_workspace_id: str = None,
        grafana_workspace_name: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The description of the workspace.
        self.description = description
        # The ID of the workspace.
        # 
        # This parameter is required.
        self.grafana_workspace_id = grafana_workspace_id
        # The workspace name.
        self.grafana_workspace_name = grafana_workspace_name
        # The region ID. Default value: `cn-hangzhou`.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.description is not None:
            result['Description'] = self.description
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.grafana_workspace_name is not None:
            result['GrafanaWorkspaceName'] = self.grafana_workspace_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('GrafanaWorkspaceName') is not None:
            self.grafana_workspace_name = m.get('GrafanaWorkspaceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateGrafanaWorkspaceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   `2XX`: The request is successful.
        # *   `3XX`: A redirection message is returned.
        # *   `4XX`: The request is invalid.
        # *   `5XX`: A server error occurs.
        self.code = code
        # Indicates whether the update is successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.data = data
        # The error message returned for the request.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   `true`
        # *   `false`
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateGrafanaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGrafanaWorkspaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGrafanaWorkspaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGrafanaWorkspaceVersionRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        grafana_version: str = None,
        grafana_workspace_id: str = None,
        region_id: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The Grafana version.
        # 
        # This parameter is required.
        self.grafana_version = grafana_version
        # The ID of the workspace.
        # 
        # This parameter is required.
        self.grafana_workspace_id = grafana_workspace_id
        # The region ID. Default value: cn-hangzhou.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.grafana_version is not None:
            result['GrafanaVersion'] = self.grafana_version
        if self.grafana_workspace_id is not None:
            result['GrafanaWorkspaceId'] = self.grafana_workspace_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('GrafanaVersion') is not None:
            self.grafana_version = m.get('GrafanaVersion')
        if m.get('GrafanaWorkspaceId') is not None:
            self.grafana_workspace_id = m.get('GrafanaWorkspaceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateGrafanaWorkspaceVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: bool = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
        trace_id: str = None,
    ):
        # The HTTP status code returned for the request. Valid values:
        # 
        # *   `2XX`: The request is successful.
        # *   `3XX`: A redirection message is returned.
        # *   `4XX`: The request is invalid.
        # *   `5XX`: A server error occurs.
        self.code = code
        # Indicates whether the update is successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.data = data
        # The error message returned for the request.
        self.message = message
        # Id of the request
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success
        # The ID of the trace. The ID is used to query the details of a request.
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class UpdateGrafanaWorkspaceVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGrafanaWorkspaceVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGrafanaWorkspaceVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateIntegrationRequest(TeaModel):
    def __init__(
        self,
        auto_recover: bool = None,
        description: str = None,
        duplicate_key: str = None,
        extended_field_redefine_rules: str = None,
        field_redefine_rules: str = None,
        initiative_recover_field: str = None,
        initiative_recover_value: str = None,
        integration_id: int = None,
        integration_name: str = None,
        integration_product_type: str = None,
        liveness: str = None,
        recover_time: int = None,
        stat: str = None,
        state: bool = None,
    ):
        # Specifies whether to automatically clear alert events. Valid values:
        # 
        # *   true (default)
        # *   false
        self.auto_recover = auto_recover
        # The description of the alert integration.
        self.description = description
        # The fields whose values are deduplicated.
        self.duplicate_key = duplicate_key
        # The extended mapped fields are mapped to the fields of ARMS alerts. For more information, see the description of the ExtendedFieldRedefineRules parameter.
        self.extended_field_redefine_rules = extended_field_redefine_rules
        # The predefined mapped fields are mapped to the fields of ARMS alerts. The predefined mapped fields were generated when the alert integration was created. For more information, see the description of the FieldRedefineRules parameter.
        self.field_redefine_rules = field_redefine_rules
        # The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
        # 
        # > Only the Log Service alert integration supports the parameter.
        self.initiative_recover_field = initiative_recover_field
        # The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
        # 
        # > Only the Log Service alert integration supports the parameter.
        self.initiative_recover_value = initiative_recover_value
        # The ID of the alert integration.
        # 
        # This parameter is required.
        self.integration_id = integration_id
        # The name of the alert integration.
        # 
        # This parameter is required.
        self.integration_name = integration_name
        # The service of the alert integration. Valid values:
        # 
        # *   CLOUD_MONITOR: CloudMonitor
        # *   LOG_SERVICE: Log Service
        # 
        # This parameter is required.
        self.integration_product_type = integration_product_type
        # The activity of the alert integration
        self.liveness = liveness
        # The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
        self.recover_time = recover_time
        # The total number of alert events and the number of abnormal alert events in the last hour.
        self.stat = stat
        # Indicates whether the alert integration was enabled. Valid values:
        # 
        # *   true
        # *   false
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_recover is not None:
            result['AutoRecover'] = self.auto_recover
        if self.description is not None:
            result['Description'] = self.description
        if self.duplicate_key is not None:
            result['DuplicateKey'] = self.duplicate_key
        if self.extended_field_redefine_rules is not None:
            result['ExtendedFieldRedefineRules'] = self.extended_field_redefine_rules
        if self.field_redefine_rules is not None:
            result['FieldRedefineRules'] = self.field_redefine_rules
        if self.initiative_recover_field is not None:
            result['InitiativeRecoverField'] = self.initiative_recover_field
        if self.initiative_recover_value is not None:
            result['InitiativeRecoverValue'] = self.initiative_recover_value
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_product_type is not None:
            result['IntegrationProductType'] = self.integration_product_type
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.recover_time is not None:
            result['RecoverTime'] = self.recover_time
        if self.stat is not None:
            result['Stat'] = self.stat
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRecover') is not None:
            self.auto_recover = m.get('AutoRecover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DuplicateKey') is not None:
            self.duplicate_key = m.get('DuplicateKey')
        if m.get('ExtendedFieldRedefineRules') is not None:
            self.extended_field_redefine_rules = m.get('ExtendedFieldRedefineRules')
        if m.get('FieldRedefineRules') is not None:
            self.field_redefine_rules = m.get('FieldRedefineRules')
        if m.get('InitiativeRecoverField') is not None:
            self.initiative_recover_field = m.get('InitiativeRecoverField')
        if m.get('InitiativeRecoverValue') is not None:
            self.initiative_recover_value = m.get('InitiativeRecoverValue')
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationProductType') is not None:
            self.integration_product_type = m.get('IntegrationProductType')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('RecoverTime') is not None:
            self.recover_time = m.get('RecoverTime')
        if m.get('Stat') is not None:
            self.stat = m.get('Stat')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdateIntegrationResponseBodyIntegration(TeaModel):
    def __init__(
        self,
        api_endpoint: str = None,
        auto_recover: bool = None,
        description: str = None,
        duplicate_key: str = None,
        extended_field_redefine_rules: List[Dict[str, Any]] = None,
        field_redefine_rules: List[Dict[str, Any]] = None,
        initiative_recover_field: str = None,
        initiative_recover_value: str = None,
        integration_id: int = None,
        integration_name: str = None,
        integration_product_type: str = None,
        liveness: str = None,
        recover_time: int = None,
        short_token: str = None,
        stat: List[int] = None,
        state: bool = None,
    ):
        # The endpoint of the alert integration.
        self.api_endpoint = api_endpoint
        # Indicates whether alert events are automatically cleared. Valid values:
        # 
        # *   true (default)
        # *   false
        self.auto_recover = auto_recover
        # The description of the alert integration.
        self.description = description
        # The fields whose values are deduplicated.
        self.duplicate_key = duplicate_key
        # The extended mapped fields of the alert source.
        self.extended_field_redefine_rules = extended_field_redefine_rules
        # The predefined mapped fields of the alert source.
        self.field_redefine_rules = field_redefine_rules
        # The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
        # 
        # > Only Log Service supports this parameter.
        self.initiative_recover_field = initiative_recover_field
        # The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
        # 
        # > Only Log Service supports this parameter.
        self.initiative_recover_value = initiative_recover_value
        # The ID of the alert integration.
        self.integration_id = integration_id
        # The name of the alert integration.
        self.integration_name = integration_name
        # The service of the alert integration. Valid values:
        # 
        # *   CLOUD_MONITOR: CloudMonitor
        # *   LOG_SERVICE: Log Service
        self.integration_product_type = integration_product_type
        # The activity of the alert integration
        self.liveness = liveness
        # The time when alert events are automatically cleared. Unit: seconds. Default value: 300.
        self.recover_time = recover_time
        # The authentication token of the alert integration.
        self.short_token = short_token
        # The total number of alert events and the number of abnormal alert events in the last hour.
        self.stat = stat
        # Indicates whether the alert integration is enabled. Valid values:
        # 
        # *   true
        # *   false
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_endpoint is not None:
            result['ApiEndpoint'] = self.api_endpoint
        if self.auto_recover is not None:
            result['AutoRecover'] = self.auto_recover
        if self.description is not None:
            result['Description'] = self.description
        if self.duplicate_key is not None:
            result['DuplicateKey'] = self.duplicate_key
        if self.extended_field_redefine_rules is not None:
            result['ExtendedFieldRedefineRules'] = self.extended_field_redefine_rules
        if self.field_redefine_rules is not None:
            result['FieldRedefineRules'] = self.field_redefine_rules
        if self.initiative_recover_field is not None:
            result['InitiativeRecoverField'] = self.initiative_recover_field
        if self.initiative_recover_value is not None:
            result['InitiativeRecoverValue'] = self.initiative_recover_value
        if self.integration_id is not None:
            result['IntegrationId'] = self.integration_id
        if self.integration_name is not None:
            result['IntegrationName'] = self.integration_name
        if self.integration_product_type is not None:
            result['IntegrationProductType'] = self.integration_product_type
        if self.liveness is not None:
            result['Liveness'] = self.liveness
        if self.recover_time is not None:
            result['RecoverTime'] = self.recover_time
        if self.short_token is not None:
            result['ShortToken'] = self.short_token
        if self.stat is not None:
            result['Stat'] = self.stat
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiEndpoint') is not None:
            self.api_endpoint = m.get('ApiEndpoint')
        if m.get('AutoRecover') is not None:
            self.auto_recover = m.get('AutoRecover')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DuplicateKey') is not None:
            self.duplicate_key = m.get('DuplicateKey')
        if m.get('ExtendedFieldRedefineRules') is not None:
            self.extended_field_redefine_rules = m.get('ExtendedFieldRedefineRules')
        if m.get('FieldRedefineRules') is not None:
            self.field_redefine_rules = m.get('FieldRedefineRules')
        if m.get('InitiativeRecoverField') is not None:
            self.initiative_recover_field = m.get('InitiativeRecoverField')
        if m.get('InitiativeRecoverValue') is not None:
            self.initiative_recover_value = m.get('InitiativeRecoverValue')
        if m.get('IntegrationId') is not None:
            self.integration_id = m.get('IntegrationId')
        if m.get('IntegrationName') is not None:
            self.integration_name = m.get('IntegrationName')
        if m.get('IntegrationProductType') is not None:
            self.integration_product_type = m.get('IntegrationProductType')
        if m.get('Liveness') is not None:
            self.liveness = m.get('Liveness')
        if m.get('RecoverTime') is not None:
            self.recover_time = m.get('RecoverTime')
        if m.get('ShortToken') is not None:
            self.short_token = m.get('ShortToken')
        if m.get('Stat') is not None:
            self.stat = m.get('Stat')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class UpdateIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        integration: UpdateIntegrationResponseBodyIntegration = None,
        request_id: str = None,
    ):
        # The Information about the alert integration.
        self.integration = integration
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        if self.integration:
            self.integration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integration is not None:
            result['Integration'] = self.integration.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Integration') is not None:
            temp_model = UpdateIntegrationResponseBodyIntegration()
            self.integration = temp_model.from_map(m['Integration'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMetricDropRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        metric_drop: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The list of discarded metrics. Specify one metric name in each line.
        self.metric_drop = metric_drop
        # The region ID.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.metric_drop is not None:
            result['MetricDrop'] = self.metric_drop
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MetricDrop') is not None:
            self.metric_drop = m.get('MetricDrop')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdateMetricDropResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response status. Valid values: 2XX: The request is successful. 3XX: A redirection message is returned. 4XX: The request is invalid. 5XX: A server error occurs.
        self.code = code
        # Indicates whether the request was successful.
        self.data = data
        # The returned message.
        self.message = message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateMetricDropResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMetricDropResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMetricDropResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusAlertRuleRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The tag key.
        self.key = key
        # The tag value.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdatePrometheusAlertRuleRequest(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_name: str = None,
        annotations: str = None,
        cluster_id: str = None,
        dispatch_rule_id: int = None,
        duration: str = None,
        expression: str = None,
        labels: str = None,
        message: str = None,
        notify_type: str = None,
        region_id: str = None,
        tags: List[UpdatePrometheusAlertRuleRequestTags] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.alert_id = alert_id
        # This parameter is required.
        self.alert_name = alert_name
        self.annotations = annotations
        # This parameter is required.
        self.cluster_id = cluster_id
        self.dispatch_rule_id = dispatch_rule_id
        # This parameter is required.
        self.duration = duration
        # This parameter is required.
        self.expression = expression
        self.labels = labels
        # This parameter is required.
        self.message = message
        self.notify_type = notify_type
        # This parameter is required.
        self.region_id = region_id
        # The tags.
        self.tags = tags
        self.type = type

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.annotations is not None:
            result['Annotations'] = self.annotations
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('Annotations') is not None:
            self.annotations = m.get('Annotations')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UpdatePrometheusAlertRuleRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule(TeaModel):
    def __init__(
        self,
        alert_id: int = None,
        alert_name: str = None,
        annotations: List[UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations] = None,
        cluster_id: str = None,
        dispatch_rule_id: int = None,
        duration: str = None,
        expression: str = None,
        labels: List[UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels] = None,
        message: str = None,
        notify_type: str = None,
        status: int = None,
        type: str = None,
    ):
        self.alert_id = alert_id
        self.alert_name = alert_name
        self.annotations = annotations
        self.cluster_id = cluster_id
        self.dispatch_rule_id = dispatch_rule_id
        self.duration = duration
        self.expression = expression
        self.labels = labels
        self.message = message
        self.notify_type = notify_type
        self.status = status
        self.type = type

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_id is not None:
            result['AlertId'] = self.alert_id
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.dispatch_rule_id is not None:
            result['DispatchRuleId'] = self.dispatch_rule_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.expression is not None:
            result['Expression'] = self.expression
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertId') is not None:
            self.alert_id = m.get('AlertId')
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('DispatchRuleId') is not None:
            self.dispatch_rule_id = m.get('DispatchRuleId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdatePrometheusAlertRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        prometheus_alert_rule: UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The returned message.
        self.message = message
        self.prometheus_alert_rule = prometheus_alert_rule
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.prometheus_alert_rule:
            self.prometheus_alert_rule.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.prometheus_alert_rule is not None:
            result['PrometheusAlertRule'] = self.prometheus_alert_rule.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PrometheusAlertRule') is not None:
            temp_model = UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule()
            self.prometheus_alert_rule = temp_model.from_map(m['PrometheusAlertRule'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdatePrometheusAlertRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusAlertRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusAlertRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusGlobalViewRequest(TeaModel):
    def __init__(
        self,
        all_sub_clusters_success: bool = None,
        cluster_id: str = None,
        group_name: str = None,
        most_region_id: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        sub_clusters_json: str = None,
    ):
        # To edit a GlobalView aggregated instance, do you require all passed child instances to be verified successfully before creating a GlobalView instance (optional, default to false):
        # - true
        # - false
        self.all_sub_clusters_success = all_sub_clusters_success
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the global aggregation instance.
        self.group_name = group_name
        # The region ID of the global aggregation instance.
        self.most_region_id = most_region_id
        # The ID of the region in which the Prometheus instance resides.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group to which the Prometheus instance belongs.
        self.resource_group_id = resource_group_id
        # The data sources of the Prometheus instance for GlobalView.
        # 
        # This parameter is required.
        self.sub_clusters_json = sub_clusters_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_sub_clusters_success is not None:
            result['AllSubClustersSuccess'] = self.all_sub_clusters_success
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.most_region_id is not None:
            result['MostRegionId'] = self.most_region_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sub_clusters_json is not None:
            result['SubClustersJson'] = self.sub_clusters_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AllSubClustersSuccess') is not None:
            self.all_sub_clusters_success = m.get('AllSubClustersSuccess')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('MostRegionId') is not None:
            self.most_region_id = m.get('MostRegionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SubClustersJson') is not None:
            self.sub_clusters_json = m.get('SubClustersJson')
        return self


class UpdatePrometheusGlobalViewResponseBodyDataFailedInstances(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        source_name: str = None,
        source_type: str = None,
        user_id: str = None,
    ):
        # The ID of the Prometheus instance.
        self.cluster_id = cluster_id
        # The name of the data source.
        self.source_name = source_name
        # The type of the data source. AlibabaPrometheus MetricStore CustomPrometheus
        self.source_type = source_type
        # The user ID.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.source_name is not None:
            result['SourceName'] = self.source_name
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('SourceName') is not None:
            self.source_name = m.get('SourceName')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdatePrometheusGlobalViewResponseBodyData(TeaModel):
    def __init__(
        self,
        failed_instances: List[UpdatePrometheusGlobalViewResponseBodyDataFailedInstances] = None,
        success: bool = None,
    ):
        # The data sources that failed to be updated.
        self.failed_instances = failed_instances
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.failed_instances:
            for k in self.failed_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FailedInstances'] = []
        if self.failed_instances is not None:
            for k in self.failed_instances:
                result['FailedInstances'].append(k.to_map() if k else None)
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.failed_instances = []
        if m.get('FailedInstances') is not None:
            for k in m.get('FailedInstances'):
                temp_model = UpdatePrometheusGlobalViewResponseBodyDataFailedInstances()
                self.failed_instances.append(temp_model.from_map(k))
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdatePrometheusGlobalViewResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdatePrometheusGlobalViewResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The response code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned struct.
        self.data = data
        # The error message that is returned if the request failed.
        self.message = message
        # The ID of the request. You can use the ID to query logs and troubleshoot issues.
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdatePrometheusGlobalViewResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePrometheusGlobalViewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusGlobalViewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusGlobalViewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusInstanceRequest(TeaModel):
    def __init__(
        self,
        archive_duration: int = None,
        auth_free_read_policy: str = None,
        auth_free_write_policy: str = None,
        cluster_id: str = None,
        enable_auth_free_read: bool = None,
        enable_auth_free_write: bool = None,
        enable_auth_token: bool = None,
        payment_type: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        storage_duration: int = None,
    ):
        # The number of days for which data is automatically archived after the storage expires. Valid values: 60, 90, 180, and 365. 0 indicates that the data is not archived.
        self.archive_duration = archive_duration
        # The IP addresses or CIDR blocks for which password-free read is enabled. Separate multiple IP addresses with line breaks.
        self.auth_free_read_policy = auth_free_read_policy
        # The IP addresses or CIDR blocks for which password-free write is enabled. Separate multiple IP addresses with line breaks.
        self.auth_free_write_policy = auth_free_write_policy
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # Specifies whether to enable password-free read.
        self.enable_auth_free_read = enable_auth_free_read
        # Specifies whether to enable password-free write.
        self.enable_auth_free_write = enable_auth_free_write
        # Specifies whether to enable access token authentication.
        self.enable_auth_token = enable_auth_token
        # The billing mode. Valid values: POSTPAY: charges fees based on the amount of reported metric data. POSTPAY_GB: charges fees based on the amount of written metric data.
        self.payment_type = payment_type
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The ID of the resource group.
        self.resource_group_id = resource_group_id
        # The data storage duration. Unit: days.
        self.storage_duration = storage_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive_duration is not None:
            result['ArchiveDuration'] = self.archive_duration
        if self.auth_free_read_policy is not None:
            result['AuthFreeReadPolicy'] = self.auth_free_read_policy
        if self.auth_free_write_policy is not None:
            result['AuthFreeWritePolicy'] = self.auth_free_write_policy
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.enable_auth_free_read is not None:
            result['EnableAuthFreeRead'] = self.enable_auth_free_read
        if self.enable_auth_free_write is not None:
            result['EnableAuthFreeWrite'] = self.enable_auth_free_write
        if self.enable_auth_token is not None:
            result['EnableAuthToken'] = self.enable_auth_token
        if self.payment_type is not None:
            result['PaymentType'] = self.payment_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.storage_duration is not None:
            result['StorageDuration'] = self.storage_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ArchiveDuration') is not None:
            self.archive_duration = m.get('ArchiveDuration')
        if m.get('AuthFreeReadPolicy') is not None:
            self.auth_free_read_policy = m.get('AuthFreeReadPolicy')
        if m.get('AuthFreeWritePolicy') is not None:
            self.auth_free_write_policy = m.get('AuthFreeWritePolicy')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('EnableAuthFreeRead') is not None:
            self.enable_auth_free_read = m.get('EnableAuthFreeRead')
        if m.get('EnableAuthFreeWrite') is not None:
            self.enable_auth_free_write = m.get('EnableAuthFreeWrite')
        if m.get('EnableAuthToken') is not None:
            self.enable_auth_token = m.get('EnableAuthToken')
        if m.get('PaymentType') is not None:
            self.payment_type = m.get('PaymentType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('StorageDuration') is not None:
            self.storage_duration = m.get('StorageDuration')
        return self


class UpdatePrometheusInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The returned status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The result of the operation.
        self.data = data
        # The message returned.
        self.message = message
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePrometheusInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusIntegrationRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        instance_id: int = None,
        integration_type: str = None,
        param: str = None,
        region_id: str = None,
    ):
        # The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The exporter ID.
        self.instance_id = instance_id
        # The type of the integration.
        # 
        # This parameter is required.
        self.integration_type = integration_type
        # The configurations of the exporter. The value is a JSON string.
        # 
        # This parameter is required.
        self.param = param
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.integration_type is not None:
            result['IntegrationType'] = self.integration_type
        if self.param is not None:
            result['Param'] = self.param
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IntegrationType') is not None:
            self.integration_type = m.get('IntegrationType')
        if m.get('Param') is not None:
            self.param = m.get('Param')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UpdatePrometheusIntegrationResponseBodyData(TeaModel):
    def __init__(
        self,
        instance_id: int = None,
        instance_name: str = None,
    ):
        # The exporter ID.
        self.instance_id = instance_id
        # The exporter name.
        self.instance_name = instance_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        return self


class UpdatePrometheusIntegrationResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdatePrometheusIntegrationResponseBodyData = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code or error code.
        self.code = code
        # The struct returned.
        self.data = data
        # The message returned.
        self.message = message
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdatePrometheusIntegrationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePrometheusIntegrationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusIntegrationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusIntegrationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusMonitoringRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        config_yaml: str = None,
        monitoring_name: str = None,
        region_id: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The monitoring configuration. The value is a YAML string.
        # 
        # This parameter is required.
        self.config_yaml = config_yaml
        # The name of the monitoring configuration.
        # 
        # This parameter is required.
        self.monitoring_name = monitoring_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The type of the monitoring configuration. 
        # Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
        # Valid values for a Prometheus instance for ECS: customJob and probe.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.config_yaml is not None:
            result['ConfigYaml'] = self.config_yaml
        if self.monitoring_name is not None:
            result['MonitoringName'] = self.monitoring_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('ConfigYaml') is not None:
            self.config_yaml = m.get('ConfigYaml')
        if m.get('MonitoringName') is not None:
            self.monitoring_name = m.get('MonitoringName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdatePrometheusMonitoringResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePrometheusMonitoringResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusMonitoringResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePrometheusMonitoringStatusRequest(TeaModel):
    def __init__(
        self,
        cluster_id: str = None,
        monitoring_name: str = None,
        region_id: str = None,
        status: str = None,
        type: str = None,
    ):
        # The ID of the Prometheus instance.
        # 
        # This parameter is required.
        self.cluster_id = cluster_id
        # The name of the monitoring configuration.
        # 
        # This parameter is required.
        self.monitoring_name = monitoring_name
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The status of the monitoring configuration. Valid values: run and stop. The status of Probe cannot be modified.
        # 
        # This parameter is required.
        self.status = status
        # The type of the monitoring configuration. 
        # Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, and customJob. 
        # Valid value for a Prometheus instance for ECS: customJob. 
        # The status of probe cannot be modified.
        # 
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.monitoring_name is not None:
            result['MonitoringName'] = self.monitoring_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('MonitoringName') is not None:
            self.monitoring_name = m.get('MonitoringName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdatePrometheusMonitoringStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The result of the operation.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdatePrometheusMonitoringStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePrometheusMonitoringStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePrometheusMonitoringStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRumAppRequest(TeaModel):
    def __init__(
        self,
        auto_restart: bool = None,
        backend_service_trace_region: str = None,
        bonree_sdkconfig_json: str = None,
        description: str = None,
        is_subscribe: bool = None,
        nickname: str = None,
        pid: str = None,
        real_region_id: str = None,
        region_id: str = None,
        restart: bool = None,
        service_domain_operation_json: str = None,
        stop: bool = None,
    ):
        # Specifies whether to restart the application the next day. Valid values: true and false.
        self.auto_restart = auto_restart
        # The collection configurations of the mobile SDK. You can enable or disable collection configurations based on the app version.
        self.backend_service_trace_region = backend_service_trace_region
        # The collection configurations of the mobile SDK. You can enable or disable collection configurations based on the app version.
        self.bonree_sdkconfig_json = bonree_sdkconfig_json
        # The description of the application.
        self.description = description
        # Specifies whether you want to subscribe to the application. Valid values: true and false.
        self.is_subscribe = is_subscribe
        # The alias of the application.
        self.nickname = nickname
        # The application ID.
        # 
        # This parameter is required.
        self.pid = pid
        # Backend application deployment area (used in end-to-end link scenarios).
        self.real_region_id = real_region_id
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # Specifies whether to restart the application. Valid values: true and false.
        self.restart = restart
        # The service domain name of the application. You can create, modify, and delete service domain name configurations.
        self.service_domain_operation_json = service_domain_operation_json
        # Specifies whether to stop the application. Valid values: true and false.
        self.stop = stop

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_restart is not None:
            result['AutoRestart'] = self.auto_restart
        if self.backend_service_trace_region is not None:
            result['BackendServiceTraceRegion'] = self.backend_service_trace_region
        if self.bonree_sdkconfig_json is not None:
            result['BonreeSDKConfigJson'] = self.bonree_sdkconfig_json
        if self.description is not None:
            result['Description'] = self.description
        if self.is_subscribe is not None:
            result['IsSubscribe'] = self.is_subscribe
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.real_region_id is not None:
            result['RealRegionId'] = self.real_region_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.restart is not None:
            result['Restart'] = self.restart
        if self.service_domain_operation_json is not None:
            result['ServiceDomainOperationJson'] = self.service_domain_operation_json
        if self.stop is not None:
            result['Stop'] = self.stop
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoRestart') is not None:
            self.auto_restart = m.get('AutoRestart')
        if m.get('BackendServiceTraceRegion') is not None:
            self.backend_service_trace_region = m.get('BackendServiceTraceRegion')
        if m.get('BonreeSDKConfigJson') is not None:
            self.bonree_sdkconfig_json = m.get('BonreeSDKConfigJson')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IsSubscribe') is not None:
            self.is_subscribe = m.get('IsSubscribe')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RealRegionId') is not None:
            self.real_region_id = m.get('RealRegionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Restart') is not None:
            self.restart = m.get('Restart')
        if m.get('ServiceDomainOperationJson') is not None:
            self.service_domain_operation_json = m.get('ServiceDomainOperationJson')
        if m.get('Stop') is not None:
            self.stop = m.get('Stop')
        return self


class UpdateRumAppResponseBodyData(TeaModel):
    def __init__(
        self,
        config: str = None,
        limit: int = None,
        limited: bool = None,
        usage: int = None,
    ):
        # The user configurations. This is a reserved parameter.
        self.config = config
        # The QPS limit. Unit: bytes.
        self.limit = limit
        # Indicates whether the request is throttled due to the QPS limit. Valid values: true and false.
        self.limited = limited
        # The usage. Unit: bytes.
        self.usage = usage

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.limited is not None:
            result['Limited'] = self.limited
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('Limited') is not None:
            self.limited = m.get('Limited')
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class UpdateRumAppResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: UpdateRumAppResponseBodyData = None,
        http_status_code: str = None,
        message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        # The HTTP status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The details of the returned results.
        self.data = data
        # The HTTP status code.
        self.http_status_code = http_status_code
        # The error message returned if the request failed.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateRumAppResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateRumAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRumAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRumAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRumFileStatusRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        pid: str = None,
        region_id: str = None,
        size: str = None,
        status: str = None,
        uuid: str = None,
        version_id: str = None,
    ):
        # The file name.
        self.file_name = file_name
        # The application ID.
        self.pid = pid
        # The region ID.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The size of the file. Unit: bytes.
        self.size = size
        # The status of the file. Valid values: SUCCESS and INIT.
        self.status = status
        # The unique ID of the file. If you do not set this parameter, the system automatically sets a UUID for you.
        self.uuid = uuid
        # The version number of the file.
        self.version_id = version_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.version_id is not None:
            result['VersionId'] = self.version_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('VersionId') is not None:
            self.version_id = m.get('VersionId')
        return self


class UpdateRumFileStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # The request ID.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateRumFileStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRumFileStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRumFileStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTimingSyntheticTaskRequestAvailableAssertions(TeaModel):
    def __init__(
        self,
        expect: str = None,
        operator: str = None,
        target: str = None,
        type: str = None,
    ):
        # The expected value.
        self.expect = expect
        # The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
        self.operator = operator
        # The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
        self.target = target
        # The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect is not None:
            result['Expect'] = self.expect
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.target is not None:
            result['Target'] = self.target
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expect') is not None:
            self.expect = m.get('Expect')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Target') is not None:
            self.target = m.get('Target')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts(TeaModel):
    def __init__(
        self,
        domain: str = None,
        ip_type: int = None,
        ips: List[str] = None,
    ):
        # The domain name.
        self.domain = domain
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4
        # *   2: IPv6
        self.ip_type = ip_type
        # The list of IP addresses.
        self.ips = ips

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.ips is not None:
            result['Ips'] = self.ips
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('Ips') is not None:
            self.ips = m.get('Ips')
        return self


class UpdateTimingSyntheticTaskRequestCommonSettingCustomHost(TeaModel):
    def __init__(
        self,
        hosts: List[UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts] = None,
        select_type: int = None,
    ):
        # The list of hosts.
        self.hosts = hosts
        # The selection mode. Valid values:
        # 
        # *   0: random
        # *   1: polling
        self.select_type = select_type

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['Hosts'].append(k.to_map() if k else None)
        if self.select_type is not None:
            result['SelectType'] = self.select_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.hosts = []
        if m.get('Hosts') is not None:
            for k in m.get('Hosts'):
                temp_model = UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts()
                self.hosts.append(temp_model.from_map(k))
        if m.get('SelectType') is not None:
            self.select_type = m.get('SelectType')
        return self


class UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting(TeaModel):
    def __init__(
        self,
        prometheus_cluster_id: str = None,
        prometheus_cluster_region: str = None,
        prometheus_labels: Dict[str, str] = None,
    ):
        # A reserved parameter.
        self.prometheus_cluster_id = prometheus_cluster_id
        # A reserved parameter.
        self.prometheus_cluster_region = prometheus_cluster_region
        # The reserved parameters.
        self.prometheus_labels = prometheus_labels

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prometheus_cluster_id is not None:
            result['PrometheusClusterId'] = self.prometheus_cluster_id
        if self.prometheus_cluster_region is not None:
            result['PrometheusClusterRegion'] = self.prometheus_cluster_region
        if self.prometheus_labels is not None:
            result['PrometheusLabels'] = self.prometheus_labels
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PrometheusClusterId') is not None:
            self.prometheus_cluster_id = m.get('PrometheusClusterId')
        if m.get('PrometheusClusterRegion') is not None:
            self.prometheus_cluster_region = m.get('PrometheusClusterRegion')
        if m.get('PrometheusLabels') is not None:
            self.prometheus_labels = m.get('PrometheusLabels')
        return self


class UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        secure_group_id: str = None,
        v_switch_id: str = None,
        vpc_id: str = None,
    ):
        # The region ID.
        self.region_id = region_id
        # The ID of the security group to which the client belongs. The security group specifies the inbound and outbound rules of the client for the VPC. You need to allow the security group to which the client belongs to access the security group to which the VPC belongs. Otherwise, the client cannot access resources in the VPC.
        self.secure_group_id = secure_group_id
        # The vSwitch ID.
        self.v_switch_id = v_switch_id
        # VPC ID.
        self.vpc_id = vpc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.secure_group_id is not None:
            result['SecureGroupId'] = self.secure_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecureGroupId') is not None:
            self.secure_group_id = m.get('SecureGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class UpdateTimingSyntheticTaskRequestCommonSetting(TeaModel):
    def __init__(
        self,
        custom_host: UpdateTimingSyntheticTaskRequestCommonSettingCustomHost = None,
        custom_prometheus_setting: UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting = None,
        custom_vpcsetting: UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting = None,
        ip_type: int = None,
        is_open_trace: bool = None,
        monitor_samples: int = None,
        trace_client_type: int = None,
        xtrace_region: str = None,
    ):
        # The custom host settings.
        self.custom_host = custom_host
        # The reserved parameters.
        self.custom_prometheus_setting = custom_prometheus_setting
        # The information about the virtual private cloud (VPC). If the destination URL is an Alibaba Cloud internal endpoint, you need to configure a VPC.
        self.custom_vpcsetting = custom_vpcsetting
        # The IP version. Valid values:
        # 
        # *   0: A version is automatically selected.
        # *   1: IPv4
        # *   2: IPv6
        self.ip_type = ip_type
        # Specifies whether to enable tracing.
        self.is_open_trace = is_open_trace
        # Specifies whether to evenly distribute monitoring samples. Valid values:
        # 
        # *   0: no
        # *   1: yes
        self.monitor_samples = monitor_samples
        # The type of the client for tracing. Valid values:
        # 
        # *   0: ARMS agent
        # *   1: OpenTelemetry
        # *   2: Jaeger
        self.trace_client_type = trace_client_type
        # The region to which trace data is reported.
        self.xtrace_region = xtrace_region

    def validate(self):
        if self.custom_host:
            self.custom_host.validate()
        if self.custom_prometheus_setting:
            self.custom_prometheus_setting.validate()
        if self.custom_vpcsetting:
            self.custom_vpcsetting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_host is not None:
            result['CustomHost'] = self.custom_host.to_map()
        if self.custom_prometheus_setting is not None:
            result['CustomPrometheusSetting'] = self.custom_prometheus_setting.to_map()
        if self.custom_vpcsetting is not None:
            result['CustomVPCSetting'] = self.custom_vpcsetting.to_map()
        if self.ip_type is not None:
            result['IpType'] = self.ip_type
        if self.is_open_trace is not None:
            result['IsOpenTrace'] = self.is_open_trace
        if self.monitor_samples is not None:
            result['MonitorSamples'] = self.monitor_samples
        if self.trace_client_type is not None:
            result['TraceClientType'] = self.trace_client_type
        if self.xtrace_region is not None:
            result['XtraceRegion'] = self.xtrace_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHost') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestCommonSettingCustomHost()
            self.custom_host = temp_model.from_map(m['CustomHost'])
        if m.get('CustomPrometheusSetting') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting()
            self.custom_prometheus_setting = temp_model.from_map(m['CustomPrometheusSetting'])
        if m.get('CustomVPCSetting') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting()
            self.custom_vpcsetting = temp_model.from_map(m['CustomVPCSetting'])
        if m.get('IpType') is not None:
            self.ip_type = m.get('IpType')
        if m.get('IsOpenTrace') is not None:
            self.is_open_trace = m.get('IsOpenTrace')
        if m.get('MonitorSamples') is not None:
            self.monitor_samples = m.get('MonitorSamples')
        if m.get('TraceClientType') is not None:
            self.trace_client_type = m.get('TraceClientType')
        if m.get('XtraceRegion') is not None:
            self.xtrace_region = m.get('XtraceRegion')
        return self


class UpdateTimingSyntheticTaskRequestCustomPeriod(TeaModel):
    def __init__(
        self,
        end_hour: int = None,
        start_hour: int = None,
    ):
        # The hour at which the test ends. Valid values: 0 to 24.
        self.end_hour = end_hour
        # The hour at which the test starts. Valid values: 0 to 24.
        self.start_hour = start_hour

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_hour is not None:
            result['EndHour'] = self.end_hour
        if self.start_hour is not None:
            result['StartHour'] = self.start_hour
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndHour') is not None:
            self.end_hour = m.get('EndHour')
        if m.get('StartHour') is not None:
            self.start_hour = m.get('StartHour')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody(TeaModel):
    def __init__(
        self,
        content: str = None,
        type: str = None,
    ):
        # The content of the request body. Format: JSON string. The parameter is required if the Type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
        self.content = content
        # The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP(TeaModel):
    def __init__(
        self,
        check_cert: bool = None,
        connect_timeout: int = None,
        method: str = None,
        protocol_alpn_protocol: int = None,
        request_body: UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody = None,
        request_headers: Dict[str, str] = None,
        target_url: str = None,
        timeout: int = None,
    ):
        # Specifies whether to verify the certificate. Default value: false.
        self.check_cert = check_cert
        # The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
        self.connect_timeout = connect_timeout
        # The request method. Valid values:
        # 
        # *   POST
        # *   GET
        self.method = method
        # The ALPN protocol version. You can configure this parameter when you perform an HTTPS synthetic test on a WAP mobile client. Valid values:
        # 
        # 0: default
        # 
        # 1-http/1.1
        # 
        # 2-h2
        # 
        # 3: disables the ALPN protocol
        self.protocol_alpn_protocol = protocol_alpn_protocol
        # The HTTP request body.
        self.request_body = request_body
        # The custom header field.
        self.request_headers = request_headers
        # The URL or request path for synthetic monitoring.
        self.target_url = target_url
        # The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
        self.timeout = timeout

    def validate(self):
        if self.request_body:
            self.request_body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_cert is not None:
            result['CheckCert'] = self.check_cert
        if self.connect_timeout is not None:
            result['ConnectTimeout'] = self.connect_timeout
        if self.method is not None:
            result['Method'] = self.method
        if self.protocol_alpn_protocol is not None:
            result['ProtocolAlpnProtocol'] = self.protocol_alpn_protocol
        if self.request_body is not None:
            result['RequestBody'] = self.request_body.to_map()
        if self.request_headers is not None:
            result['RequestHeaders'] = self.request_headers
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckCert') is not None:
            self.check_cert = m.get('CheckCert')
        if m.get('ConnectTimeout') is not None:
            self.connect_timeout = m.get('ConnectTimeout')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('ProtocolAlpnProtocol') is not None:
            self.protocol_alpn_protocol = m.get('ProtocolAlpnProtocol')
        if m.get('RequestBody') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody()
            self.request_body = temp_model.from_map(m['RequestBody'])
        if m.get('RequestHeaders') is not None:
            self.request_headers = m.get('RequestHeaders')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfFileDownload(TeaModel):
    def __init__(
        self,
        connection_timeout: int = None,
        custom_header_content: Dict[str, str] = None,
        download_kernel: int = None,
        ignore_certificate_auth_error: int = None,
        ignore_certificate_canceled_error: int = None,
        ignore_certificate_out_of_date_error: int = None,
        ignore_certificate_status_error: int = None,
        ignore_certificate_untrustworthy_error: int = None,
        ignore_certificate_using_error: int = None,
        ignore_invalid_host_error: int = None,
        monitor_timeout: int = None,
        quick_protocol: int = None,
        redirection: int = None,
        target_url: str = None,
        transmission_size: int = None,
        validate_keywords: str = None,
        verify_way: int = None,
        white_list: str = None,
    ):
        # Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
        self.connection_timeout = connection_timeout
        # The content of the custom request header. Format: JSON map.
        self.custom_header_content = custom_header_content
        # The kernel type. Valid values:
        # 
        # *   1: curl
        # *   0: WinInet
        self.download_kernel = download_kernel
        # Specifies whether to ignore CA certificate authentication errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_auth_error = ignore_certificate_auth_error
        # Specifies whether to ignore certificate revocation errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_canceled_error = ignore_certificate_canceled_error
        # Specifies whether to ignore certificate invalidity. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_out_of_date_error = ignore_certificate_out_of_date_error
        # Specifies whether to ignore certificate status errors. 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_status_error = ignore_certificate_status_error
        # Specifies whether to ignore certificate incredibility. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_untrustworthy_error = ignore_certificate_untrustworthy_error
        # Specifies whether to ignore certificate usage errors. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_using_error = ignore_certificate_using_error
        # Specifies whether to ignore host invalidity. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_invalid_host_error = ignore_invalid_host_error
        # The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
        self.monitor_timeout = monitor_timeout
        # The QUIC protocol type. Valid values:
        # 
        # *   1: HTTP/1
        # *   2: HTTP/2
        # *   3: http3
        self.quick_protocol = quick_protocol
        # Specifies whether to support redirection. Valid values: 0: no. 1: yes. Default value: 1.
        self.redirection = redirection
        # The URL that is used to download the file.
        self.target_url = target_url
        # The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
        self.transmission_size = transmission_size
        # The keyword that is used in verification.
        self.validate_keywords = validate_keywords
        # The verification method. Valid values:
        # 
        # *   0: no verification
        # *   1: string verification
        # *   2: MD5 verification
        self.verify_way = verify_way
        # The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_timeout is not None:
            result['ConnectionTimeout'] = self.connection_timeout
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.download_kernel is not None:
            result['DownloadKernel'] = self.download_kernel
        if self.ignore_certificate_auth_error is not None:
            result['IgnoreCertificateAuthError'] = self.ignore_certificate_auth_error
        if self.ignore_certificate_canceled_error is not None:
            result['IgnoreCertificateCanceledError'] = self.ignore_certificate_canceled_error
        if self.ignore_certificate_out_of_date_error is not None:
            result['IgnoreCertificateOutOfDateError'] = self.ignore_certificate_out_of_date_error
        if self.ignore_certificate_status_error is not None:
            result['IgnoreCertificateStatusError'] = self.ignore_certificate_status_error
        if self.ignore_certificate_untrustworthy_error is not None:
            result['IgnoreCertificateUntrustworthyError'] = self.ignore_certificate_untrustworthy_error
        if self.ignore_certificate_using_error is not None:
            result['IgnoreCertificateUsingError'] = self.ignore_certificate_using_error
        if self.ignore_invalid_host_error is not None:
            result['IgnoreInvalidHostError'] = self.ignore_invalid_host_error
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.quick_protocol is not None:
            result['QuickProtocol'] = self.quick_protocol
        if self.redirection is not None:
            result['Redirection'] = self.redirection
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.transmission_size is not None:
            result['TransmissionSize'] = self.transmission_size
        if self.validate_keywords is not None:
            result['ValidateKeywords'] = self.validate_keywords
        if self.verify_way is not None:
            result['VerifyWay'] = self.verify_way
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectionTimeout') is not None:
            self.connection_timeout = m.get('ConnectionTimeout')
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('DownloadKernel') is not None:
            self.download_kernel = m.get('DownloadKernel')
        if m.get('IgnoreCertificateAuthError') is not None:
            self.ignore_certificate_auth_error = m.get('IgnoreCertificateAuthError')
        if m.get('IgnoreCertificateCanceledError') is not None:
            self.ignore_certificate_canceled_error = m.get('IgnoreCertificateCanceledError')
        if m.get('IgnoreCertificateOutOfDateError') is not None:
            self.ignore_certificate_out_of_date_error = m.get('IgnoreCertificateOutOfDateError')
        if m.get('IgnoreCertificateStatusError') is not None:
            self.ignore_certificate_status_error = m.get('IgnoreCertificateStatusError')
        if m.get('IgnoreCertificateUntrustworthyError') is not None:
            self.ignore_certificate_untrustworthy_error = m.get('IgnoreCertificateUntrustworthyError')
        if m.get('IgnoreCertificateUsingError') is not None:
            self.ignore_certificate_using_error = m.get('IgnoreCertificateUsingError')
        if m.get('IgnoreInvalidHostError') is not None:
            self.ignore_invalid_host_error = m.get('IgnoreInvalidHostError')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('QuickProtocol') is not None:
            self.quick_protocol = m.get('QuickProtocol')
        if m.get('Redirection') is not None:
            self.redirection = m.get('Redirection')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('TransmissionSize') is not None:
            self.transmission_size = m.get('TransmissionSize')
        if m.get('ValidateKeywords') is not None:
            self.validate_keywords = m.get('ValidateKeywords')
        if m.get('VerifyWay') is not None:
            self.verify_way = m.get('VerifyWay')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfNetDNS(TeaModel):
    def __init__(
        self,
        dig: int = None,
        dns_server_ip_type: int = None,
        ns_server: str = None,
        query_method: int = None,
        target_url: str = None,
        timeout: int = None,
    ):
        # Specifies whether to use the dig command to display the data. Valid values: 0: no. 1: yes.
        self.dig = dig
        # The IP version of the DNS server. Valid values: 0: IPv4. 1: IPv6. 2: A version is automatically selected. Default value: 0.
        self.dns_server_ip_type = dns_server_ip_type
        # The IP address of the DNS server. Default value: 114.114.114.114.
        self.ns_server = ns_server
        # The DNS query method. Valid values: 0: recursive. 1: iterative. Default value: 0.
        self.query_method = query_method
        # The domain name.
        self.target_url = target_url
        # The timeout period for the DNS synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 45000. Default value: 5000.
        self.timeout = timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dig is not None:
            result['Dig'] = self.dig
        if self.dns_server_ip_type is not None:
            result['DnsServerIpType'] = self.dns_server_ip_type
        if self.ns_server is not None:
            result['NsServer'] = self.ns_server
        if self.query_method is not None:
            result['QueryMethod'] = self.query_method
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Dig') is not None:
            self.dig = m.get('Dig')
        if m.get('DnsServerIpType') is not None:
            self.dns_server_ip_type = m.get('DnsServerIpType')
        if m.get('NsServer') is not None:
            self.ns_server = m.get('NsServer')
        if m.get('QueryMethod') is not None:
            self.query_method = m.get('QueryMethod')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfNetICMP(TeaModel):
    def __init__(
        self,
        interval: int = None,
        package_num: int = None,
        package_size: int = None,
        split_package: bool = None,
        target_url: str = None,
        timeout: int = None,
        tracert_enable: bool = None,
        tracert_num_max: int = None,
        tracert_timeout: int = None,
    ):
        # The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 10000.
        self.interval = interval
        # The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
        self.package_num = package_num
        # The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024, 1080, and 1450.
        self.package_size = package_size
        # Specifies whether to split ICMP packets. Default value: true.
        self.split_package = split_package
        # The IP address or domain name of the destination host. The value cannot contain port numbers, protocol headers, or request paths.
        self.target_url = target_url
        # The timeout period for the ICMP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
        self.timeout = timeout
        # Specifies whether to enable the tracert command. Default value: true.
        self.tracert_enable = tracert_enable
        # The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
        self.tracert_num_max = tracert_num_max
        # The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
        self.tracert_timeout = tracert_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.package_num is not None:
            result['PackageNum'] = self.package_num
        if self.package_size is not None:
            result['PackageSize'] = self.package_size
        if self.split_package is not None:
            result['SplitPackage'] = self.split_package
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.tracert_enable is not None:
            result['TracertEnable'] = self.tracert_enable
        if self.tracert_num_max is not None:
            result['TracertNumMax'] = self.tracert_num_max
        if self.tracert_timeout is not None:
            result['TracertTimeout'] = self.tracert_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('PackageNum') is not None:
            self.package_num = m.get('PackageNum')
        if m.get('PackageSize') is not None:
            self.package_size = m.get('PackageSize')
        if m.get('SplitPackage') is not None:
            self.split_package = m.get('SplitPackage')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TracertEnable') is not None:
            self.tracert_enable = m.get('TracertEnable')
        if m.get('TracertNumMax') is not None:
            self.tracert_num_max = m.get('TracertNumMax')
        if m.get('TracertTimeout') is not None:
            self.tracert_timeout = m.get('TracertTimeout')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfNetTCP(TeaModel):
    def __init__(
        self,
        connect_times: int = None,
        interval: int = None,
        target_url: str = None,
        timeout: int = None,
        tracert_enable: bool = None,
        tracert_num_max: int = None,
        tracert_timeout: int = None,
    ):
        # The number of TCP connections that are established. Minimum value: 1. Maximum value: 16. Default value: 4.
        self.connect_times = connect_times
        # The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
        self.interval = interval
        # The IP address of the destination host.
        self.target_url = target_url
        # The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
        self.timeout = timeout
        # Specifies whether to enable the tracert command. Default value: true.
        self.tracert_enable = tracert_enable
        # The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
        self.tracert_num_max = tracert_num_max
        # The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
        self.tracert_timeout = tracert_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_times is not None:
            result['ConnectTimes'] = self.connect_times
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.tracert_enable is not None:
            result['TracertEnable'] = self.tracert_enable
        if self.tracert_num_max is not None:
            result['TracertNumMax'] = self.tracert_num_max
        if self.tracert_timeout is not None:
            result['TracertTimeout'] = self.tracert_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnectTimes') is not None:
            self.connect_times = m.get('ConnectTimes')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('TracertEnable') is not None:
            self.tracert_enable = m.get('TracertEnable')
        if m.get('TracertNumMax') is not None:
            self.tracert_num_max = m.get('TracertNumMax')
        if m.get('TracertTimeout') is not None:
            self.tracert_timeout = m.get('TracertTimeout')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfStream(TeaModel):
    def __init__(
        self,
        custom_header_content: Dict[str, str] = None,
        player_type: int = None,
        stream_address_type: int = None,
        stream_monitor_timeout: int = None,
        stream_type: int = None,
        target_url: str = None,
        white_list: str = None,
    ):
        # The custom header. Format: JSON map.
        self.custom_header_content = custom_header_content
        # The player. Default value: 12. Valid values:
        # 
        # *   12: VLC
        # *   2: Flash Player
        self.player_type = player_type
        # The address type of the resource. Valid values:
        # 
        # *   1: resource URL.
        # *   0: page URL. Default value: 0.
        self.stream_address_type = stream_address_type
        # The monitoring duration. Unit: seconds. Maximum and default value: 60.
        self.stream_monitor_timeout = stream_monitor_timeout
        # Specifies whether the resource is a video or audio. Valid values: 0: video. 1: audio.
        self.stream_type = stream_type
        # The resource URL of the streaming media.
        self.target_url = target_url
        # The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.player_type is not None:
            result['PlayerType'] = self.player_type
        if self.stream_address_type is not None:
            result['StreamAddressType'] = self.stream_address_type
        if self.stream_monitor_timeout is not None:
            result['StreamMonitorTimeout'] = self.stream_monitor_timeout
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.white_list is not None:
            result['WhiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('PlayerType') is not None:
            self.player_type = m.get('PlayerType')
        if m.get('StreamAddressType') is not None:
            self.stream_address_type = m.get('StreamAddressType')
        if m.get('StreamMonitorTimeout') is not None:
            self.stream_monitor_timeout = m.get('StreamMonitorTimeout')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('WhiteList') is not None:
            self.white_list = m.get('WhiteList')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConfWebsite(TeaModel):
    def __init__(
        self,
        automatic_scrolling: int = None,
        custom_header: int = None,
        custom_header_content: Dict[str, str] = None,
        dnshijack_whitelist: str = None,
        disable_cache: int = None,
        disable_compression: int = None,
        element_blacklist: str = None,
        filter_invalid_ip: int = None,
        flow_hijack_jump_times: int = None,
        flow_hijack_logo: str = None,
        ignore_certificate_error: int = None,
        monitor_timeout: int = None,
        page_tamper: str = None,
        redirection: int = None,
        slow_element_threshold: int = None,
        target_url: str = None,
        verify_string_blacklist: str = None,
        verify_string_whitelist: str = None,
        wait_completion_time: int = None,
    ):
        # Specifies whether to automatically scroll up and down the screen to load a page. Valid values: 0: no. 1: yes. Default value: 0.
        self.automatic_scrolling = automatic_scrolling
        # Specifies whether to create a custom header. Valid values: 0: no. 1: The first packet is modified. 2: All packets are modified. Default value: 0.
        self.custom_header = custom_header
        # The custom header. Format: JSON map.
        self.custom_header_content = custom_header_content
        # If the IP address or CNAME record resolved from a domain name is not included in the DNS whitelist, you cannot access the domain name, or an IP address that belongs to a different domain name is returned. If the IP address or CNAME record is included in the DNS whitelist, DNS hijacking does not occur.
        # 
        # Format: \\<domain name>:\\<objects>. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
        self.dnshijack_whitelist = dnshijack_whitelist
        # Specifies whether to disable the cache. Valid values: 0: no. 1: yes. Default value: 1.
        self.disable_cache = disable_cache
        # Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. Valid values: 0: no. 1: yes. Default value: 0.
        self.disable_compression = disable_compression
        # The elements not to be loaded in the page loading process.
        self.element_blacklist = element_blacklist
        # Specifies whether to exclude invalid IP addresses. Valid values:
        # 
        # *   1: no
        # *   0: yes
        self.filter_invalid_ip = filter_invalid_ip
        # The total number of elements on the page.
        self.flow_hijack_jump_times = flow_hijack_jump_times
        # The keyword that is used to identify hijacking. Asterisks (\\*) are allowed.
        self.flow_hijack_logo = flow_hijack_logo
        # Specifies whether to ignore SSL certificate errors during browsing. Valid values: 0: no. 1: yes. Default value: 1.
        self.ignore_certificate_error = ignore_certificate_error
        # The monitoring timeout period. Unit: milliseconds. Minimum value: 5000. Maximum value: 300000. Default value: 40000.
        self.monitor_timeout = monitor_timeout
        # Elements that are not included in the whitelist and appear on the page are manipulated. These elements can be pop-up ads, floating ads, and page redirection.
        self.page_tamper = page_tamper
        # Specifies whether to continue browsing after redirection. Valid values: 0: no. 1: yes. Default value: 1.
        self.redirection = redirection
        # The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
        self.slow_element_threshold = slow_element_threshold
        # The URL of the website.
        self.target_url = target_url
        # An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is in the blacklist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
        self.verify_string_blacklist = verify_string_blacklist
        # An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is not in the whitelist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
        self.verify_string_whitelist = verify_string_whitelist
        # The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
        self.wait_completion_time = wait_completion_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.automatic_scrolling is not None:
            result['AutomaticScrolling'] = self.automatic_scrolling
        if self.custom_header is not None:
            result['CustomHeader'] = self.custom_header
        if self.custom_header_content is not None:
            result['CustomHeaderContent'] = self.custom_header_content
        if self.dnshijack_whitelist is not None:
            result['DNSHijackWhitelist'] = self.dnshijack_whitelist
        if self.disable_cache is not None:
            result['DisableCache'] = self.disable_cache
        if self.disable_compression is not None:
            result['DisableCompression'] = self.disable_compression
        if self.element_blacklist is not None:
            result['ElementBlacklist'] = self.element_blacklist
        if self.filter_invalid_ip is not None:
            result['FilterInvalidIP'] = self.filter_invalid_ip
        if self.flow_hijack_jump_times is not None:
            result['FlowHijackJumpTimes'] = self.flow_hijack_jump_times
        if self.flow_hijack_logo is not None:
            result['FlowHijackLogo'] = self.flow_hijack_logo
        if self.ignore_certificate_error is not None:
            result['IgnoreCertificateError'] = self.ignore_certificate_error
        if self.monitor_timeout is not None:
            result['MonitorTimeout'] = self.monitor_timeout
        if self.page_tamper is not None:
            result['PageTamper'] = self.page_tamper
        if self.redirection is not None:
            result['Redirection'] = self.redirection
        if self.slow_element_threshold is not None:
            result['SlowElementThreshold'] = self.slow_element_threshold
        if self.target_url is not None:
            result['TargetUrl'] = self.target_url
        if self.verify_string_blacklist is not None:
            result['VerifyStringBlacklist'] = self.verify_string_blacklist
        if self.verify_string_whitelist is not None:
            result['VerifyStringWhitelist'] = self.verify_string_whitelist
        if self.wait_completion_time is not None:
            result['WaitCompletionTime'] = self.wait_completion_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutomaticScrolling') is not None:
            self.automatic_scrolling = m.get('AutomaticScrolling')
        if m.get('CustomHeader') is not None:
            self.custom_header = m.get('CustomHeader')
        if m.get('CustomHeaderContent') is not None:
            self.custom_header_content = m.get('CustomHeaderContent')
        if m.get('DNSHijackWhitelist') is not None:
            self.dnshijack_whitelist = m.get('DNSHijackWhitelist')
        if m.get('DisableCache') is not None:
            self.disable_cache = m.get('DisableCache')
        if m.get('DisableCompression') is not None:
            self.disable_compression = m.get('DisableCompression')
        if m.get('ElementBlacklist') is not None:
            self.element_blacklist = m.get('ElementBlacklist')
        if m.get('FilterInvalidIP') is not None:
            self.filter_invalid_ip = m.get('FilterInvalidIP')
        if m.get('FlowHijackJumpTimes') is not None:
            self.flow_hijack_jump_times = m.get('FlowHijackJumpTimes')
        if m.get('FlowHijackLogo') is not None:
            self.flow_hijack_logo = m.get('FlowHijackLogo')
        if m.get('IgnoreCertificateError') is not None:
            self.ignore_certificate_error = m.get('IgnoreCertificateError')
        if m.get('MonitorTimeout') is not None:
            self.monitor_timeout = m.get('MonitorTimeout')
        if m.get('PageTamper') is not None:
            self.page_tamper = m.get('PageTamper')
        if m.get('Redirection') is not None:
            self.redirection = m.get('Redirection')
        if m.get('SlowElementThreshold') is not None:
            self.slow_element_threshold = m.get('SlowElementThreshold')
        if m.get('TargetUrl') is not None:
            self.target_url = m.get('TargetUrl')
        if m.get('VerifyStringBlacklist') is not None:
            self.verify_string_blacklist = m.get('VerifyStringBlacklist')
        if m.get('VerifyStringWhitelist') is not None:
            self.verify_string_whitelist = m.get('VerifyStringWhitelist')
        if m.get('WaitCompletionTime') is not None:
            self.wait_completion_time = m.get('WaitCompletionTime')
        return self


class UpdateTimingSyntheticTaskRequestMonitorConf(TeaModel):
    def __init__(
        self,
        api_http: UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP = None,
        file_download: UpdateTimingSyntheticTaskRequestMonitorConfFileDownload = None,
        net_dns: UpdateTimingSyntheticTaskRequestMonitorConfNetDNS = None,
        net_icmp: UpdateTimingSyntheticTaskRequestMonitorConfNetICMP = None,
        net_tcp: UpdateTimingSyntheticTaskRequestMonitorConfNetTCP = None,
        stream: UpdateTimingSyntheticTaskRequestMonitorConfStream = None,
        website: UpdateTimingSyntheticTaskRequestMonitorConfWebsite = None,
    ):
        # The parameters of the HTTP(S) synthetic test.
        self.api_http = api_http
        # The parameters of file downloading.
        self.file_download = file_download
        # The parameters of the DNS synthetic test.
        self.net_dns = net_dns
        # The parameters of the ICMP synthetic test.
        self.net_icmp = net_icmp
        # The parameters of the TCP synthetic test.
        self.net_tcp = net_tcp
        # The parameters of the streaming-media synthetic test.
        self.stream = stream
        # The parameters of the website speed measurement.
        self.website = website

    def validate(self):
        if self.api_http:
            self.api_http.validate()
        if self.file_download:
            self.file_download.validate()
        if self.net_dns:
            self.net_dns.validate()
        if self.net_icmp:
            self.net_icmp.validate()
        if self.net_tcp:
            self.net_tcp.validate()
        if self.stream:
            self.stream.validate()
        if self.website:
            self.website.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_http is not None:
            result['ApiHTTP'] = self.api_http.to_map()
        if self.file_download is not None:
            result['FileDownload'] = self.file_download.to_map()
        if self.net_dns is not None:
            result['NetDNS'] = self.net_dns.to_map()
        if self.net_icmp is not None:
            result['NetICMP'] = self.net_icmp.to_map()
        if self.net_tcp is not None:
            result['NetTCP'] = self.net_tcp.to_map()
        if self.stream is not None:
            result['Stream'] = self.stream.to_map()
        if self.website is not None:
            result['Website'] = self.website.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiHTTP') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP()
            self.api_http = temp_model.from_map(m['ApiHTTP'])
        if m.get('FileDownload') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfFileDownload()
            self.file_download = temp_model.from_map(m['FileDownload'])
        if m.get('NetDNS') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfNetDNS()
            self.net_dns = temp_model.from_map(m['NetDNS'])
        if m.get('NetICMP') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfNetICMP()
            self.net_icmp = temp_model.from_map(m['NetICMP'])
        if m.get('NetTCP') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfNetTCP()
            self.net_tcp = temp_model.from_map(m['NetTCP'])
        if m.get('Stream') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfStream()
            self.stream = temp_model.from_map(m['Stream'])
        if m.get('Website') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConfWebsite()
            self.website = temp_model.from_map(m['Website'])
        return self


class UpdateTimingSyntheticTaskRequestMonitors(TeaModel):
    def __init__(
        self,
        city_code: str = None,
        client_type: int = None,
        operator_code: str = None,
    ):
        # The city code.
        self.city_code = city_code
        # The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
        self.client_type = client_type
        # The carrier code.
        self.operator_code = operator_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city_code is not None:
            result['CityCode'] = self.city_code
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.operator_code is not None:
            result['OperatorCode'] = self.operator_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CityCode') is not None:
            self.city_code = m.get('CityCode')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('OperatorCode') is not None:
            self.operator_code = m.get('OperatorCode')
        return self


class UpdateTimingSyntheticTaskRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateTimingSyntheticTaskRequest(TeaModel):
    def __init__(
        self,
        available_assertions: List[UpdateTimingSyntheticTaskRequestAvailableAssertions] = None,
        common_setting: UpdateTimingSyntheticTaskRequestCommonSetting = None,
        custom_period: UpdateTimingSyntheticTaskRequestCustomPeriod = None,
        frequency: str = None,
        monitor_conf: UpdateTimingSyntheticTaskRequestMonitorConf = None,
        monitors: List[UpdateTimingSyntheticTaskRequestMonitors] = None,
        name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags: List[UpdateTimingSyntheticTaskRequestTags] = None,
        task_id: str = None,
    ):
        # The list of assertions.
        self.available_assertions = available_assertions
        # The general settings.
        self.common_setting = common_setting
        # The custom cycle.
        self.custom_period = custom_period
        # The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
        self.frequency = frequency
        # The monitoring configurations.
        self.monitor_conf = monitor_conf
        # The list of monitoring points.
        self.monitors = monitors
        # The name of the task.
        self.name = name
        # The region ID.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The list of tags.
        self.tags = tags
        # The ID of the synthetic monitoring task.
        self.task_id = task_id

    def validate(self):
        if self.available_assertions:
            for k in self.available_assertions:
                if k:
                    k.validate()
        if self.common_setting:
            self.common_setting.validate()
        if self.custom_period:
            self.custom_period.validate()
        if self.monitor_conf:
            self.monitor_conf.validate()
        if self.monitors:
            for k in self.monitors:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableAssertions'] = []
        if self.available_assertions is not None:
            for k in self.available_assertions:
                result['AvailableAssertions'].append(k.to_map() if k else None)
        if self.common_setting is not None:
            result['CommonSetting'] = self.common_setting.to_map()
        if self.custom_period is not None:
            result['CustomPeriod'] = self.custom_period.to_map()
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.monitor_conf is not None:
            result['MonitorConf'] = self.monitor_conf.to_map()
        result['Monitors'] = []
        if self.monitors is not None:
            for k in self.monitors:
                result['Monitors'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.available_assertions = []
        if m.get('AvailableAssertions') is not None:
            for k in m.get('AvailableAssertions'):
                temp_model = UpdateTimingSyntheticTaskRequestAvailableAssertions()
                self.available_assertions.append(temp_model.from_map(k))
        if m.get('CommonSetting') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestCommonSetting()
            self.common_setting = temp_model.from_map(m['CommonSetting'])
        if m.get('CustomPeriod') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestCustomPeriod()
            self.custom_period = temp_model.from_map(m['CustomPeriod'])
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('MonitorConf') is not None:
            temp_model = UpdateTimingSyntheticTaskRequestMonitorConf()
            self.monitor_conf = temp_model.from_map(m['MonitorConf'])
        self.monitors = []
        if m.get('Monitors') is not None:
            for k in m.get('Monitors'):
                temp_model = UpdateTimingSyntheticTaskRequestMonitors()
                self.monitors.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UpdateTimingSyntheticTaskRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateTimingSyntheticTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        available_assertions_shrink: str = None,
        common_setting_shrink: str = None,
        custom_period_shrink: str = None,
        frequency: str = None,
        monitor_conf_shrink: str = None,
        monitors_shrink: str = None,
        name: str = None,
        region_id: str = None,
        resource_group_id: str = None,
        tags_shrink: str = None,
        task_id: str = None,
    ):
        # The list of assertions.
        self.available_assertions_shrink = available_assertions_shrink
        # The general settings.
        self.common_setting_shrink = common_setting_shrink
        # The custom cycle.
        self.custom_period_shrink = custom_period_shrink
        # The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
        self.frequency = frequency
        # The monitoring configurations.
        self.monitor_conf_shrink = monitor_conf_shrink
        # The list of monitoring points.
        self.monitors_shrink = monitors_shrink
        # The name of the task.
        self.name = name
        # The region ID.
        self.region_id = region_id
        # The resource group ID.
        self.resource_group_id = resource_group_id
        # The list of tags.
        self.tags_shrink = tags_shrink
        # The ID of the synthetic monitoring task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_assertions_shrink is not None:
            result['AvailableAssertions'] = self.available_assertions_shrink
        if self.common_setting_shrink is not None:
            result['CommonSetting'] = self.common_setting_shrink
        if self.custom_period_shrink is not None:
            result['CustomPeriod'] = self.custom_period_shrink
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.monitor_conf_shrink is not None:
            result['MonitorConf'] = self.monitor_conf_shrink
        if self.monitors_shrink is not None:
            result['Monitors'] = self.monitors_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags_shrink is not None:
            result['Tags'] = self.tags_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableAssertions') is not None:
            self.available_assertions_shrink = m.get('AvailableAssertions')
        if m.get('CommonSetting') is not None:
            self.common_setting_shrink = m.get('CommonSetting')
        if m.get('CustomPeriod') is not None:
            self.custom_period_shrink = m.get('CustomPeriod')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('MonitorConf') is not None:
            self.monitor_conf_shrink = m.get('MonitorConf')
        if m.get('Monitors') is not None:
            self.monitors_shrink = m.get('Monitors')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            self.tags_shrink = m.get('Tags')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateTimingSyntheticTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        task_id: str = None,
    ):
        # The task ID.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateTimingSyntheticTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: UpdateTimingSyntheticTaskResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code
        # The struct returned.
        self.data = data
        # The message returned.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = UpdateTimingSyntheticTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTimingSyntheticTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTimingSyntheticTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTimingSyntheticTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWebhookRequest(TeaModel):
    def __init__(
        self,
        body: str = None,
        contact_id: int = None,
        contact_name: str = None,
        http_headers: str = None,
        http_params: str = None,
        method: str = None,
        recover_body: str = None,
        region_id: str = None,
        url: str = None,
    ):
        # The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
        # 
        # This parameter is required.
        self.body = body
        # The ID of the webhook alert contact. You can call the **SearchAlertContact** operation to obtain the ID.
        # 
        # This parameter is required.
        self.contact_id = contact_id
        # The name of the webhook alert contact.
        # 
        # This parameter is required.
        self.contact_name = contact_name
        # The HTTP request headers.
        self.http_headers = http_headers
        # The parameters in the HTTP request.
        self.http_params = http_params
        # The HTTP request method. Valid values:
        # 
        # *   `Get`
        # *   `Post`
        # 
        # This parameter is required.
        self.method = method
        # The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
        self.recover_body = recover_body
        # The ID of the region.
        # 
        # This parameter is required.
        self.region_id = region_id
        # The URL of the HTTP request method.
        # 
        # This parameter is required.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.body is not None:
            result['Body'] = self.body
        if self.contact_id is not None:
            result['ContactId'] = self.contact_id
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.http_headers is not None:
            result['HttpHeaders'] = self.http_headers
        if self.http_params is not None:
            result['HttpParams'] = self.http_params
        if self.method is not None:
            result['Method'] = self.method
        if self.recover_body is not None:
            result['RecoverBody'] = self.recover_body
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Body') is not None:
            self.body = m.get('Body')
        if m.get('ContactId') is not None:
            self.contact_id = m.get('ContactId')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('HttpHeaders') is not None:
            self.http_headers = m.get('HttpHeaders')
        if m.get('HttpParams') is not None:
            self.http_params = m.get('HttpParams')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('RecoverBody') is not None:
            self.recover_body = m.get('RecoverBody')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class UpdateWebhookResponseBody(TeaModel):
    def __init__(
        self,
        is_success: bool = None,
        request_id: str = None,
    ):
        # The result returned. Valid values:
        # 
        # *   `true`: The modification is successful.
        # *   `false`: The modification fails.
        self.is_success = is_success
        # The ID of the request.
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_success is not None:
            result['IsSuccess'] = self.is_success
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsSuccess') is not None:
            self.is_success = m.get('IsSuccess')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeAddonReleaseRequest(TeaModel):
    def __init__(
        self,
        addon_version: str = None,
        dry_run: bool = None,
        environment_id: str = None,
        region_id: str = None,
        release_name: str = None,
        values: str = None,
    ):
        # The version of the add-on.
        # 
        # This parameter is required.
        self.addon_version = addon_version
        # Specifies whether to perform only a dry run, without performing the actual request.
        self.dry_run = dry_run
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The region ID.
        self.region_id = region_id
        # The name of the release.
        # 
        # This parameter is required.
        self.release_name = release_name
        # The metadata information.
        # 
        # This parameter is required.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addon_version is not None:
            result['AddonVersion'] = self.addon_version
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.release_name is not None:
            result['ReleaseName'] = self.release_name
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AddonVersion') is not None:
            self.addon_version = m.get('AddonVersion')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReleaseName') is not None:
            self.release_name = m.get('ReleaseName')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class UpgradeAddonReleaseResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The returned message.
        self.data = data
        # The error message returned if the request parameters are invalid.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpgradeAddonReleaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeAddonReleaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeAddonReleaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpgradeEnvironmentFeatureRequest(TeaModel):
    def __init__(
        self,
        aliyun_lang: str = None,
        environment_id: str = None,
        feature_name: str = None,
        feature_version: str = None,
        region_id: str = None,
        values: str = None,
    ):
        # The language. Valid values: zh and en. Default value: zh.
        self.aliyun_lang = aliyun_lang
        # The environment ID.
        # 
        # This parameter is required.
        self.environment_id = environment_id
        # The feature name. Valid values: app-agent-pilot, metric-agent, ebpf-agent, and service-check.
        # 
        # This parameter is required.
        self.feature_name = feature_name
        # The version of the feature.
        self.feature_version = feature_version
        # The region ID.
        self.region_id = region_id
        # Specifies whether to enable service discovery. For PodAnnotation, set the value to run or mini. For PodMonitor and ServiceMonitor, set the value to true or false.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_lang is not None:
            result['AliyunLang'] = self.aliyun_lang
        if self.environment_id is not None:
            result['EnvironmentId'] = self.environment_id
        if self.feature_name is not None:
            result['FeatureName'] = self.feature_name
        if self.feature_version is not None:
            result['FeatureVersion'] = self.feature_version
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunLang') is not None:
            self.aliyun_lang = m.get('AliyunLang')
        if m.get('EnvironmentId') is not None:
            self.environment_id = m.get('EnvironmentId')
        if m.get('FeatureName') is not None:
            self.feature_name = m.get('FeatureName')
        if m.get('FeatureVersion') is not None:
            self.feature_version = m.get('FeatureVersion')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class UpgradeEnvironmentFeatureResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: Dict[str, str] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The status code. The status code 200 indicates that the request was successful.
        self.code = code
        # The status of the job.
        self.data = data
        # The returned message.
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpgradeEnvironmentFeatureResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpgradeEnvironmentFeatureResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpgradeEnvironmentFeatureResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadRequest(TeaModel):
    def __init__(
        self,
        edition: str = None,
        file: str = None,
        file_name: str = None,
        pid: str = None,
        region_id: str = None,
        version: str = None,
    ):
        # The version of the SourceMap file.
        self.edition = edition
        # The string of the SourceMap file.
        self.file = file
        # The name of the SourceMap file.
        # 
        # This parameter is required.
        self.file_name = file_name
        # The application ID.
        # 
        # Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with @ to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
        # 
        # This parameter is required.
        self.pid = pid
        # The ID of the region to which the SourceMap file is uploaded.
        # 
        # This parameter is required.
        self.region_id = region_id
        # We recommend that you do not specify this parameter.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.edition is not None:
            result['Edition'] = self.edition
        if self.file is not None:
            result['File'] = self.file
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.pid is not None:
            result['Pid'] = self.pid
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Edition') is not None:
            self.edition = m.get('Edition')
        if m.get('File') is not None:
            self.file = m.get('File')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Pid') is not None:
            self.pid = m.get('Pid')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class UploadResponseBodyUploadResult(TeaModel):
    def __init__(
        self,
        fid: str = None,
        file_name: str = None,
        upload_time: str = None,
    ):
        # The ID of the SourceMap file.
        self.fid = fid
        # The name of the SourceMap file.
        self.file_name = file_name
        # The time when the file was uploaded.
        self.upload_time = upload_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fid is not None:
            result['Fid'] = self.fid
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.upload_time is not None:
            result['UploadTime'] = self.upload_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Fid') is not None:
            self.fid = m.get('Fid')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('UploadTime') is not None:
            self.upload_time = m.get('UploadTime')
        return self


class UploadResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        upload_result: UploadResponseBodyUploadResult = None,
    ):
        # The request ID.
        self.request_id = request_id
        # The returned data.
        self.upload_result = upload_result

    def validate(self):
        if self.upload_result:
            self.upload_result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_result is not None:
            result['UploadResult'] = self.upload_result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadResult') is not None:
            temp_model = UploadResponseBodyUploadResult()
            self.upload_result = temp_model.from_map(m['UploadResult'])
        return self


class UploadResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UploadResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


