# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from __future__ import annotations

from typing import List

from alibabacloud_gpdb20160503 import models as main_models
from darabonba.model import DaraModel

class ListSlowSQLRecordsResponseBody(DaraModel):
    def __init__(
        self,
        items: List[main_models.ListSlowSQLRecordsResponseBodyItems] = None,
        page_number: int = None,
        page_record_count: int = None,
        request_id: str = None,
        total_record_count: int = None,
    ):
        # List of slow queries.
        self.items = items
        # The page number of the returned page.
        self.page_number = page_number
        # The number of entries per page.
        self.page_record_count = page_record_count
        # The unique ID of the request.
        self.request_id = request_id
        # The total number of log entries returned.
        self.total_record_count = total_record_count

    def validate(self):
        if self.items:
            for v1 in self.items:
                 if v1:
                    v1.validate()

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        result['Items'] = []
        if self.items is not None:
            for k1 in self.items:
                result['Items'].append(k1.to_map() if k1 else None)

        if self.page_number is not None:
            result['PageNumber'] = self.page_number

        if self.page_record_count is not None:
            result['PageRecordCount'] = self.page_record_count

        if self.request_id is not None:
            result['RequestId'] = self.request_id

        if self.total_record_count is not None:
            result['TotalRecordCount'] = self.total_record_count

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k1 in m.get('Items'):
                temp_model = main_models.ListSlowSQLRecordsResponseBodyItems()
                self.items.append(temp_model.from_map(k1))

        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')

        if m.get('PageRecordCount') is not None:
            self.page_record_count = m.get('PageRecordCount')

        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')

        if m.get('TotalRecordCount') is not None:
            self.total_record_count = m.get('TotalRecordCount')

        return self

class ListSlowSQLRecordsResponseBodyItems(DaraModel):
    def __init__(
        self,
        cpu_time_ms: int = None,
        dbname: str = None,
        duration_time: int = None,
        lock_wait_time: int = None,
        mem_bytes: int = None,
        optimizer: str = None,
        query_end_time: str = None,
        query_id: str = None,
        query_start_time: str = None,
        queue_wait_time: int = None,
        spill_bytes: int = None,
        sql_text: str = None,
        sql_truncated: str = None,
        sql_truncated_threshold: int = None,
        user_name: str = None,
    ):
        # The total CPU time (in milliseconds) consumed by the query execution.
        self.cpu_time_ms = cpu_time_ms
        # The name of the database.
        self.dbname = dbname
        # Total execution time in milliseconds.
        self.duration_time = duration_time
        # The total lock wait time (in milliseconds).
        self.lock_wait_time = lock_wait_time
        # The total memory (in bytes) occupied by the query execution.
        self.mem_bytes = mem_bytes
        # Execution optimizer.
        self.optimizer = optimizer
        # The end time of the query.
        self.query_end_time = query_end_time
        # The query ID. It is a unique identifier of the query.
        self.query_id = query_id
        # The start time of the query.
        self.query_start_time = query_start_time
        # The query queueing time (in milliseconds) in resource groups/queues.
        self.queue_wait_time = queue_wait_time
        # The total size (in bytes) of the files generated by the query.
        self.spill_bytes = spill_bytes
        # SQL statements in audit logs.
        self.sql_text = sql_text
        # Indicates whether the SQL statement is truncated. Valid values:
        # 
        # *   true: Truncated.
        # *   false: Not truncated.
        self.sql_truncated = sql_truncated
        # The threshold that is used to truncate the SQL statement.
        self.sql_truncated_threshold = sql_truncated_threshold
        # The account that initiates the query.
        self.user_name = user_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        _map = super().to_map()
        if _map is not None:
            result = _map
        if self.cpu_time_ms is not None:
            result['CpuTimeMs'] = self.cpu_time_ms

        if self.dbname is not None:
            result['DBName'] = self.dbname

        if self.duration_time is not None:
            result['DurationTime'] = self.duration_time

        if self.lock_wait_time is not None:
            result['LockWaitTime'] = self.lock_wait_time

        if self.mem_bytes is not None:
            result['MemBytes'] = self.mem_bytes

        if self.optimizer is not None:
            result['Optimizer'] = self.optimizer

        if self.query_end_time is not None:
            result['QueryEndTime'] = self.query_end_time

        if self.query_id is not None:
            result['QueryID'] = self.query_id

        if self.query_start_time is not None:
            result['QueryStartTime'] = self.query_start_time

        if self.queue_wait_time is not None:
            result['QueueWaitTime'] = self.queue_wait_time

        if self.spill_bytes is not None:
            result['SpillBytes'] = self.spill_bytes

        if self.sql_text is not None:
            result['SqlText'] = self.sql_text

        if self.sql_truncated is not None:
            result['SqlTruncated'] = self.sql_truncated

        if self.sql_truncated_threshold is not None:
            result['SqlTruncatedThreshold'] = self.sql_truncated_threshold

        if self.user_name is not None:
            result['UserName'] = self.user_name

        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuTimeMs') is not None:
            self.cpu_time_ms = m.get('CpuTimeMs')

        if m.get('DBName') is not None:
            self.dbname = m.get('DBName')

        if m.get('DurationTime') is not None:
            self.duration_time = m.get('DurationTime')

        if m.get('LockWaitTime') is not None:
            self.lock_wait_time = m.get('LockWaitTime')

        if m.get('MemBytes') is not None:
            self.mem_bytes = m.get('MemBytes')

        if m.get('Optimizer') is not None:
            self.optimizer = m.get('Optimizer')

        if m.get('QueryEndTime') is not None:
            self.query_end_time = m.get('QueryEndTime')

        if m.get('QueryID') is not None:
            self.query_id = m.get('QueryID')

        if m.get('QueryStartTime') is not None:
            self.query_start_time = m.get('QueryStartTime')

        if m.get('QueueWaitTime') is not None:
            self.queue_wait_time = m.get('QueueWaitTime')

        if m.get('SpillBytes') is not None:
            self.spill_bytes = m.get('SpillBytes')

        if m.get('SqlText') is not None:
            self.sql_text = m.get('SqlText')

        if m.get('SqlTruncated') is not None:
            self.sql_truncated = m.get('SqlTruncated')

        if m.get('SqlTruncatedThreshold') is not None:
            self.sql_truncated_threshold = m.get('SqlTruncatedThreshold')

        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')

        return self

