# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class AddRecordTemplateRequestBackgrounds(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class AddRecordTemplateRequestClockWidgets(TeaModel):
    def __init__(
        self,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class AddRecordTemplateRequestWatermarks(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class AddRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        background_color: int = None,
        backgrounds: List[AddRecordTemplateRequestBackgrounds] = None,
        clock_widgets: List[AddRecordTemplateRequestClockWidgets] = None,
        delay_stop_time: int = None,
        enable_m3u_8date_time: bool = None,
        file_split_interval: int = None,
        formats: List[str] = None,
        http_callback_url: str = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        mns_queue: str = None,
        name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_file_prefix: str = None,
        owner_id: int = None,
        task_profile: str = None,
        watermarks: List[AddRecordTemplateRequestWatermarks] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.background_color = background_color
        self.backgrounds = backgrounds
        self.clock_widgets = clock_widgets
        self.delay_stop_time = delay_stop_time
        self.enable_m3u_8date_time = enable_m3u_8date_time
        # This parameter is required.
        self.file_split_interval = file_split_interval
        # This parameter is required.
        self.formats = formats
        self.http_callback_url = http_callback_url
        # This parameter is required.
        self.layout_ids = layout_ids
        # This parameter is required.
        self.media_encode = media_encode
        self.mns_queue = mns_queue
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.oss_bucket = oss_bucket
        self.oss_endpoint = oss_endpoint
        # This parameter is required.
        self.oss_file_prefix = oss_file_prefix
        self.owner_id = owner_id
        # This parameter is required.
        self.task_profile = task_profile
        self.watermarks = watermarks

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.watermarks:
            for k in self.watermarks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.background_color is not None:
            result['BackgroundColor'] = self.background_color
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.delay_stop_time is not None:
            result['DelayStopTime'] = self.delay_stop_time
        if self.enable_m3u_8date_time is not None:
            result['EnableM3u8DateTime'] = self.enable_m3u_8date_time
        if self.file_split_interval is not None:
            result['FileSplitInterval'] = self.file_split_interval
        if self.formats is not None:
            result['Formats'] = self.formats
        if self.http_callback_url is not None:
            result['HttpCallbackUrl'] = self.http_callback_url
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.mns_queue is not None:
            result['MnsQueue'] = self.mns_queue
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_file_prefix is not None:
            result['OssFilePrefix'] = self.oss_file_prefix
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.task_profile is not None:
            result['TaskProfile'] = self.task_profile
        result['Watermarks'] = []
        if self.watermarks is not None:
            for k in self.watermarks:
                result['Watermarks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BackgroundColor') is not None:
            self.background_color = m.get('BackgroundColor')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = AddRecordTemplateRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = AddRecordTemplateRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('DelayStopTime') is not None:
            self.delay_stop_time = m.get('DelayStopTime')
        if m.get('EnableM3u8DateTime') is not None:
            self.enable_m3u_8date_time = m.get('EnableM3u8DateTime')
        if m.get('FileSplitInterval') is not None:
            self.file_split_interval = m.get('FileSplitInterval')
        if m.get('Formats') is not None:
            self.formats = m.get('Formats')
        if m.get('HttpCallbackUrl') is not None:
            self.http_callback_url = m.get('HttpCallbackUrl')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('MnsQueue') is not None:
            self.mns_queue = m.get('MnsQueue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssFilePrefix') is not None:
            self.oss_file_prefix = m.get('OssFilePrefix')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TaskProfile') is not None:
            self.task_profile = m.get('TaskProfile')
        self.watermarks = []
        if m.get('Watermarks') is not None:
            for k in m.get('Watermarks'):
                temp_model = AddRecordTemplateRequestWatermarks()
                self.watermarks.append(temp_model.from_map(k))
        return self


class AddRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class AddRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAppAgentTemplateRequestAgentSilenceConfig(TeaModel):
    def __init__(
        self,
        alert_timeout: int = None,
        content: str = None,
        strategy: int = None,
        webhook_trigger_timeout: int = None,
    ):
        self.alert_timeout = alert_timeout
        self.content = content
        self.strategy = strategy
        self.webhook_trigger_timeout = webhook_trigger_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_timeout is not None:
            result['AlertTimeout'] = self.alert_timeout
        if self.content is not None:
            result['Content'] = self.content
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.webhook_trigger_timeout is not None:
            result['WebhookTriggerTimeout'] = self.webhook_trigger_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertTimeout') is not None:
            self.alert_timeout = m.get('AlertTimeout')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('WebhookTriggerTimeout') is not None:
            self.webhook_trigger_timeout = m.get('WebhookTriggerTimeout')
        return self


class CreateAppAgentTemplateRequestAsrConfigVadConfig(TeaModel):
    def __init__(
        self,
        interrupt_speech_duration: int = None,
    ):
        self.interrupt_speech_duration = interrupt_speech_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interrupt_speech_duration is not None:
            result['InterruptSpeechDuration'] = self.interrupt_speech_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InterruptSpeechDuration') is not None:
            self.interrupt_speech_duration = m.get('InterruptSpeechDuration')
        return self


class CreateAppAgentTemplateRequestAsrConfigWordWeights(TeaModel):
    def __init__(
        self,
        lang: str = None,
        weight: int = None,
        word: str = None,
    ):
        self.lang = lang
        # This parameter is required.
        self.weight = weight
        # This parameter is required.
        self.word = word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.weight is not None:
            result['Weight'] = self.weight
        if self.word is not None:
            result['Word'] = self.word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        return self


class CreateAppAgentTemplateRequestAsrConfig(TeaModel):
    def __init__(
        self,
        max_sentence_silence: int = None,
        name: str = None,
        vad_config: CreateAppAgentTemplateRequestAsrConfigVadConfig = None,
        word_weights: List[CreateAppAgentTemplateRequestAsrConfigWordWeights] = None,
    ):
        self.max_sentence_silence = max_sentence_silence
        # This parameter is required.
        self.name = name
        self.vad_config = vad_config
        self.word_weights = word_weights

    def validate(self):
        if self.vad_config:
            self.vad_config.validate()
        if self.word_weights:
            for k in self.word_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_sentence_silence is not None:
            result['MaxSentenceSilence'] = self.max_sentence_silence
        if self.name is not None:
            result['Name'] = self.name
        if self.vad_config is not None:
            result['VadConfig'] = self.vad_config.to_map()
        result['WordWeights'] = []
        if self.word_weights is not None:
            for k in self.word_weights:
                result['WordWeights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxSentenceSilence') is not None:
            self.max_sentence_silence = m.get('MaxSentenceSilence')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VadConfig') is not None:
            temp_model = CreateAppAgentTemplateRequestAsrConfigVadConfig()
            self.vad_config = temp_model.from_map(m['VadConfig'])
        self.word_weights = []
        if m.get('WordWeights') is not None:
            for k in m.get('WordWeights'):
                temp_model = CreateAppAgentTemplateRequestAsrConfigWordWeights()
                self.word_weights.append(temp_model.from_map(k))
        return self


class CreateAppAgentTemplateRequestLlmConfig(TeaModel):
    def __init__(
        self,
        agent_app_id: str = None,
        api_key: str = None,
        history_depth: int = None,
        max_token: int = None,
        name: str = None,
        prompt: str = None,
        temperature: float = None,
        top_p: float = None,
        url: str = None,
        vendor: str = None,
    ):
        self.agent_app_id = agent_app_id
        # This parameter is required.
        self.api_key = api_key
        self.history_depth = history_depth
        self.max_token = max_token
        # This parameter is required.
        self.name = name
        self.prompt = prompt
        self.temperature = temperature
        self.top_p = top_p
        self.url = url
        # This parameter is required.
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_app_id is not None:
            result['AgentAppId'] = self.agent_app_id
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.history_depth is not None:
            result['HistoryDepth'] = self.history_depth
        if self.max_token is not None:
            result['MaxToken'] = self.max_token
        if self.name is not None:
            result['Name'] = self.name
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.temperature is not None:
            result['Temperature'] = self.temperature
        if self.top_p is not None:
            result['TopP'] = self.top_p
        if self.url is not None:
            result['Url'] = self.url
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentAppId') is not None:
            self.agent_app_id = m.get('AgentAppId')
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('HistoryDepth') is not None:
            self.history_depth = m.get('HistoryDepth')
        if m.get('MaxToken') is not None:
            self.max_token = m.get('MaxToken')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Temperature') is not None:
            self.temperature = m.get('Temperature')
        if m.get('TopP') is not None:
            self.top_p = m.get('TopP')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class CreateAppAgentTemplateRequestTtsConfig(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        filter_brackets: List[int] = None,
        name: str = None,
        pitch: float = None,
        rate: float = None,
        vendor: str = None,
        voice: str = None,
        volume: int = None,
    ):
        # This parameter is required.
        self.api_key = api_key
        self.filter_brackets = filter_brackets
        # This parameter is required.
        self.name = name
        self.pitch = pitch
        self.rate = rate
        self.vendor = vendor
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.filter_brackets is not None:
            result['FilterBrackets'] = self.filter_brackets
        if self.name is not None:
            result['Name'] = self.name
        if self.pitch is not None:
            result['Pitch'] = self.pitch
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('FilterBrackets') is not None:
            self.filter_brackets = m.get('FilterBrackets')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pitch') is not None:
            self.pitch = m.get('Pitch')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class CreateAppAgentTemplateRequest(TeaModel):
    def __init__(
        self,
        agent_silence_config: CreateAppAgentTemplateRequestAgentSilenceConfig = None,
        app_id: str = None,
        asr_config: CreateAppAgentTemplateRequestAsrConfig = None,
        chat_mode: int = None,
        greeting: str = None,
        interrupt_mode: int = None,
        llm_config: CreateAppAgentTemplateRequestLlmConfig = None,
        name: str = None,
        tts_config: CreateAppAgentTemplateRequestTtsConfig = None,
        type: int = None,
    ):
        self.agent_silence_config = agent_silence_config
        # This parameter is required.
        self.app_id = app_id
        self.asr_config = asr_config
        self.chat_mode = chat_mode
        self.greeting = greeting
        self.interrupt_mode = interrupt_mode
        self.llm_config = llm_config
        # This parameter is required.
        self.name = name
        self.tts_config = tts_config
        self.type = type

    def validate(self):
        if self.agent_silence_config:
            self.agent_silence_config.validate()
        if self.asr_config:
            self.asr_config.validate()
        if self.llm_config:
            self.llm_config.validate()
        if self.tts_config:
            self.tts_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_silence_config is not None:
            result['AgentSilenceConfig'] = self.agent_silence_config.to_map()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.asr_config is not None:
            result['AsrConfig'] = self.asr_config.to_map()
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        if self.llm_config is not None:
            result['LlmConfig'] = self.llm_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.tts_config is not None:
            result['TtsConfig'] = self.tts_config.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentSilenceConfig') is not None:
            temp_model = CreateAppAgentTemplateRequestAgentSilenceConfig()
            self.agent_silence_config = temp_model.from_map(m['AgentSilenceConfig'])
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AsrConfig') is not None:
            temp_model = CreateAppAgentTemplateRequestAsrConfig()
            self.asr_config = temp_model.from_map(m['AsrConfig'])
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        if m.get('LlmConfig') is not None:
            temp_model = CreateAppAgentTemplateRequestLlmConfig()
            self.llm_config = temp_model.from_map(m['LlmConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TtsConfig') is not None:
            temp_model = CreateAppAgentTemplateRequestTtsConfig()
            self.tts_config = temp_model.from_map(m['TtsConfig'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateAppAgentTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_silence_config_shrink: str = None,
        app_id: str = None,
        asr_config_shrink: str = None,
        chat_mode: int = None,
        greeting: str = None,
        interrupt_mode: int = None,
        llm_config_shrink: str = None,
        name: str = None,
        tts_config_shrink: str = None,
        type: int = None,
    ):
        self.agent_silence_config_shrink = agent_silence_config_shrink
        # This parameter is required.
        self.app_id = app_id
        self.asr_config_shrink = asr_config_shrink
        self.chat_mode = chat_mode
        self.greeting = greeting
        self.interrupt_mode = interrupt_mode
        self.llm_config_shrink = llm_config_shrink
        # This parameter is required.
        self.name = name
        self.tts_config_shrink = tts_config_shrink
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_silence_config_shrink is not None:
            result['AgentSilenceConfig'] = self.agent_silence_config_shrink
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.asr_config_shrink is not None:
            result['AsrConfig'] = self.asr_config_shrink
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        if self.llm_config_shrink is not None:
            result['LlmConfig'] = self.llm_config_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.tts_config_shrink is not None:
            result['TtsConfig'] = self.tts_config_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentSilenceConfig') is not None:
            self.agent_silence_config_shrink = m.get('AgentSilenceConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AsrConfig') is not None:
            self.asr_config_shrink = m.get('AsrConfig')
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        if m.get('LlmConfig') is not None:
            self.llm_config_shrink = m.get('LlmConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TtsConfig') is not None:
            self.tts_config_shrink = m.get('TtsConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateAppAgentTemplateResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAppAgentTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAppAgentTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAppAgentTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAppLayoutRequestLayoutPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class CreateAppLayoutRequestLayout(TeaModel):
    def __init__(
        self,
        name: str = None,
        panes: List[CreateAppLayoutRequestLayoutPanes] = None,
    ):
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = CreateAppLayoutRequestLayoutPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class CreateAppLayoutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        layout: CreateAppLayoutRequestLayout = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.layout = layout

    def validate(self):
        if self.layout:
            self.layout.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.layout is not None:
            result['Layout'] = self.layout.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Layout') is not None:
            temp_model = CreateAppLayoutRequestLayout()
            self.layout = temp_model.from_map(m['Layout'])
        return self


class CreateAppLayoutShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        layout_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.layout_shrink = layout_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.layout_shrink is not None:
            result['Layout'] = self.layout_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Layout') is not None:
            self.layout_shrink = m.get('Layout')
        return self


class CreateAppLayoutResponseBody(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        request_id: str = None,
    ):
        self.layout_id = layout_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAppLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAppLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAppLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAppRecordTemplateRequestRecordTemplate(TeaModel):
    def __init__(
        self,
        delay_stop_time: int = None,
        file_prefix: str = None,
        file_split_interval: int = None,
        formats: List[str] = None,
        layout_ids: List[str] = None,
        media_encode: int = None,
        name: str = None,
    ):
        self.delay_stop_time = delay_stop_time
        # This parameter is required.
        self.file_prefix = file_prefix
        # This parameter is required.
        self.file_split_interval = file_split_interval
        # This parameter is required.
        self.formats = formats
        self.layout_ids = layout_ids
        # This parameter is required.
        self.media_encode = media_encode
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay_stop_time is not None:
            result['DelayStopTime'] = self.delay_stop_time
        if self.file_prefix is not None:
            result['FilePrefix'] = self.file_prefix
        if self.file_split_interval is not None:
            result['FileSplitInterval'] = self.file_split_interval
        if self.formats is not None:
            result['Formats'] = self.formats
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DelayStopTime') is not None:
            self.delay_stop_time = m.get('DelayStopTime')
        if m.get('FilePrefix') is not None:
            self.file_prefix = m.get('FilePrefix')
        if m.get('FileSplitInterval') is not None:
            self.file_split_interval = m.get('FileSplitInterval')
        if m.get('Formats') is not None:
            self.formats = m.get('Formats')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateAppRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        record_template: CreateAppRecordTemplateRequestRecordTemplate = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.record_template = record_template

    def validate(self):
        if self.record_template:
            self.record_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.record_template is not None:
            result['RecordTemplate'] = self.record_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('RecordTemplate') is not None:
            temp_model = CreateAppRecordTemplateRequestRecordTemplate()
            self.record_template = temp_model.from_map(m['RecordTemplate'])
        return self


class CreateAppRecordTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        record_template_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.record_template_shrink = record_template_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.record_template_shrink is not None:
            result['RecordTemplate'] = self.record_template_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('RecordTemplate') is not None:
            self.record_template_shrink = m.get('RecordTemplate')
        return self


class CreateAppRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateAppRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAppRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAppRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAppStreamingOutTemplateRequestStreamingOutTemplate(TeaModel):
    def __init__(
        self,
        layout_ids: List[str] = None,
        media_encode: int = None,
        name: str = None,
    ):
        # This parameter is required.
        self.layout_ids = layout_ids
        # This parameter is required.
        self.media_encode = media_encode
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateAppStreamingOutTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        streaming_out_template: CreateAppStreamingOutTemplateRequestStreamingOutTemplate = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.streaming_out_template = streaming_out_template

    def validate(self):
        if self.streaming_out_template:
            self.streaming_out_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.streaming_out_template is not None:
            result['StreamingOutTemplate'] = self.streaming_out_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('StreamingOutTemplate') is not None:
            temp_model = CreateAppStreamingOutTemplateRequestStreamingOutTemplate()
            self.streaming_out_template = temp_model.from_map(m['StreamingOutTemplate'])
        return self


class CreateAppStreamingOutTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        streaming_out_template_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.streaming_out_template_shrink = streaming_out_template_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.streaming_out_template_shrink is not None:
            result['StreamingOutTemplate'] = self.streaming_out_template_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('StreamingOutTemplate') is not None:
            self.streaming_out_template_shrink = m.get('StreamingOutTemplate')
        return self


class CreateAppStreamingOutTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateAppStreamingOutTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAppStreamingOutTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAppStreamingOutTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAutoLiveStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        call_back: str = None,
        channel_id_prefixes: List[str] = None,
        channel_ids: List[str] = None,
        media_encode: int = None,
        owner_id: int = None,
        play_domain: str = None,
        rule_name: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.call_back = call_back
        self.channel_id_prefixes = channel_id_prefixes
        self.channel_ids = channel_ids
        self.media_encode = media_encode
        self.owner_id = owner_id
        # This parameter is required.
        self.play_domain = play_domain
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.channel_id_prefixes is not None:
            result['ChannelIdPrefixes'] = self.channel_id_prefixes
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.play_domain is not None:
            result['PlayDomain'] = self.play_domain
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('ChannelIdPrefixes') is not None:
            self.channel_id_prefixes = m.get('ChannelIdPrefixes')
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PlayDomain') is not None:
            self.play_domain = m.get('PlayDomain')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class CreateAutoLiveStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rule_id: int = None,
    ):
        self.request_id = request_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class CreateAutoLiveStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateAutoLiveStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAutoLiveStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCloudNotePhrasesRequestPhraseWordWeights(TeaModel):
    def __init__(
        self,
        weight: int = None,
        word: str = None,
    ):
        # This parameter is required.
        self.weight = weight
        # This parameter is required.
        self.word = word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.weight is not None:
            result['Weight'] = self.weight
        if self.word is not None:
            result['Word'] = self.word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        return self


class CreateCloudNotePhrasesRequestPhrase(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        word_weights: List[CreateCloudNotePhrasesRequestPhraseWordWeights] = None,
    ):
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.word_weights = word_weights

    def validate(self):
        if self.word_weights:
            for k in self.word_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        result['WordWeights'] = []
        if self.word_weights is not None:
            for k in self.word_weights:
                result['WordWeights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.word_weights = []
        if m.get('WordWeights') is not None:
            for k in m.get('WordWeights'):
                temp_model = CreateCloudNotePhrasesRequestPhraseWordWeights()
                self.word_weights.append(temp_model.from_map(k))
        return self


class CreateCloudNotePhrasesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        phrase: CreateCloudNotePhrasesRequestPhrase = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.phrase = phrase

    def validate(self):
        if self.phrase:
            self.phrase.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.phrase is not None:
            result['Phrase'] = self.phrase.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Phrase') is not None:
            temp_model = CreateCloudNotePhrasesRequestPhrase()
            self.phrase = temp_model.from_map(m['Phrase'])
        return self


class CreateCloudNotePhrasesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        phrase_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.phrase_shrink = phrase_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.phrase_shrink is not None:
            result['Phrase'] = self.phrase_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Phrase') is not None:
            self.phrase_shrink = m.get('Phrase')
        return self


class CreateCloudNotePhrasesResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCloudNotePhrasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCloudNotePhrasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCloudNotePhrasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEventSubscribeRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_url: str = None,
        channel_id: str = None,
        client_token: str = None,
        events: List[str] = None,
        need_callback_auth: bool = None,
        owner_id: int = None,
        role: int = None,
        users: List[str] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback_url = callback_url
        self.channel_id = channel_id
        # This parameter is required.
        self.client_token = client_token
        # This parameter is required.
        self.events = events
        self.need_callback_auth = need_callback_auth
        self.owner_id = owner_id
        self.role = role
        self.users = users

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_url is not None:
            result['CallbackUrl'] = self.callback_url
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.events is not None:
            result['Events'] = self.events
        if self.need_callback_auth is not None:
            result['NeedCallbackAuth'] = self.need_callback_auth
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.role is not None:
            result['Role'] = self.role
        if self.users is not None:
            result['Users'] = self.users
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallbackUrl') is not None:
            self.callback_url = m.get('CallbackUrl')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Events') is not None:
            self.events = m.get('Events')
        if m.get('NeedCallbackAuth') is not None:
            self.need_callback_auth = m.get('NeedCallbackAuth')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Users') is not None:
            self.users = m.get('Users')
        return self


class CreateEventSubscribeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        subscribe_id: str = None,
    ):
        self.request_id = request_id
        self.subscribe_id = subscribe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.subscribe_id is not None:
            result['SubscribeId'] = self.subscribe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubscribeId') is not None:
            self.subscribe_id = m.get('SubscribeId')
        return self


class CreateEventSubscribeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEventSubscribeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEventSubscribeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMPULayoutRequestPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        major_pane: int = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        self.major_pane = major_pane
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.major_pane is not None:
            result['MajorPane'] = self.major_pane
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MajorPane') is not None:
            self.major_pane = m.get('MajorPane')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class CreateMPULayoutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        audio_mix_count: int = None,
        name: str = None,
        owner_id: int = None,
        panes: List[CreateMPULayoutRequestPanes] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.audio_mix_count = audio_mix_count
        self.name = name
        self.owner_id = owner_id
        # This parameter is required.
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.audio_mix_count is not None:
            result['AudioMixCount'] = self.audio_mix_count
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AudioMixCount') is not None:
            self.audio_mix_count = m.get('AudioMixCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = CreateMPULayoutRequestPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class CreateMPULayoutResponseBody(TeaModel):
    def __init__(
        self,
        layout_id: int = None,
        request_id: str = None,
    ):
        self.layout_id = layout_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateMPULayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMPULayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMPULayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAppAgentTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteAppAgentTemplateResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAppAgentTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAppAgentTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAppAgentTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAppLayoutRequestLayout(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
    ):
        # This parameter is required.
        self.layout_id = layout_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        return self


class DeleteAppLayoutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        layout: DeleteAppLayoutRequestLayout = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        self.layout = layout

    def validate(self):
        if self.layout:
            self.layout.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.layout is not None:
            result['Layout'] = self.layout.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Layout') is not None:
            temp_model = DeleteAppLayoutRequestLayout()
            self.layout = temp_model.from_map(m['Layout'])
        return self


class DeleteAppLayoutShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        layout_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        self.layout_shrink = layout_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.layout_shrink is not None:
            result['Layout'] = self.layout_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Layout') is not None:
            self.layout_shrink = m.get('Layout')
        return self


class DeleteAppLayoutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAppLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAppLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAppLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAppRecordTemplateRequestTemplate(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteAppRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        template: DeleteAppRecordTemplateRequestTemplate = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.template = template

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Template') is not None:
            temp_model = DeleteAppRecordTemplateRequestTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class DeleteAppRecordTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        template_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.template_shrink = template_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.template_shrink is not None:
            result['Template'] = self.template_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Template') is not None:
            self.template_shrink = m.get('Template')
        return self


class DeleteAppRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAppRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAppRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAppRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAppStreamingOutTemplateRequestStreamingOutTemplate(TeaModel):
    def __init__(
        self,
        template_id: str = None,
    ):
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteAppStreamingOutTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        streaming_out_template: DeleteAppStreamingOutTemplateRequestStreamingOutTemplate = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.streaming_out_template = streaming_out_template

    def validate(self):
        if self.streaming_out_template:
            self.streaming_out_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.streaming_out_template is not None:
            result['StreamingOutTemplate'] = self.streaming_out_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('StreamingOutTemplate') is not None:
            temp_model = DeleteAppStreamingOutTemplateRequestStreamingOutTemplate()
            self.streaming_out_template = temp_model.from_map(m['StreamingOutTemplate'])
        return self


class DeleteAppStreamingOutTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        streaming_out_template_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.streaming_out_template_shrink = streaming_out_template_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.streaming_out_template_shrink is not None:
            result['StreamingOutTemplate'] = self.streaming_out_template_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('StreamingOutTemplate') is not None:
            self.streaming_out_template_shrink = m.get('StreamingOutTemplate')
        return self


class DeleteAppStreamingOutTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAppStreamingOutTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAppStreamingOutTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAppStreamingOutTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAutoLiveStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        rule_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DeleteAutoLiveStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAutoLiveStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteAutoLiveStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAutoLiveStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteChannelRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DeleteChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudNotePhrasesRequestPhrase(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # This parameter is required.
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DeleteCloudNotePhrasesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        phrase: DeleteCloudNotePhrasesRequestPhrase = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.phrase = phrase

    def validate(self):
        if self.phrase:
            self.phrase.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.phrase is not None:
            result['Phrase'] = self.phrase.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Phrase') is not None:
            temp_model = DeleteCloudNotePhrasesRequestPhrase()
            self.phrase = temp_model.from_map(m['Phrase'])
        return self


class DeleteCloudNotePhrasesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        phrase_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.phrase_shrink = phrase_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.phrase_shrink is not None:
            result['Phrase'] = self.phrase_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Phrase') is not None:
            self.phrase_shrink = m.get('Phrase')
        return self


class DeleteCloudNotePhrasesResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCloudNotePhrasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteCloudNotePhrasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudNotePhrasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventSubscribeRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        subscribe_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.subscribe_id = subscribe_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.subscribe_id is not None:
            result['SubscribeId'] = self.subscribe_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SubscribeId') is not None:
            self.subscribe_id = m.get('SubscribeId')
        return self


class DeleteEventSubscribeResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEventSubscribeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEventSubscribeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventSubscribeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMPULayoutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        layout_id: int = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.layout_id = layout_id
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DeleteMPULayoutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMPULayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteMPULayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMPULayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        template_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # 1
        self.owner_id = owner_id
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAllCallbackResponseBodyCallbacksSubEvent(TeaModel):
    def __init__(
        self,
        event: int = None,
        event_name: str = None,
        type: int = None,
    ):
        self.event = event
        self.event_name = event_name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event is not None:
            result['Event'] = self.event
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Event') is not None:
            self.event = m.get('Event')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAllCallbackResponseBodyCallbacks(TeaModel):
    def __init__(
        self,
        category: str = None,
        name: str = None,
        sub_event: List[DescribeAllCallbackResponseBodyCallbacksSubEvent] = None,
    ):
        self.category = category
        self.name = name
        self.sub_event = sub_event

    def validate(self):
        if self.sub_event:
            for k in self.sub_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.name is not None:
            result['Name'] = self.name
        result['SubEvent'] = []
        if self.sub_event is not None:
            for k in self.sub_event:
                result['SubEvent'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.sub_event = []
        if m.get('SubEvent') is not None:
            for k in m.get('SubEvent'):
                temp_model = DescribeAllCallbackResponseBodyCallbacksSubEvent()
                self.sub_event.append(temp_model.from_map(k))
        return self


class DescribeAllCallbackResponseBody(TeaModel):
    def __init__(
        self,
        callbacks: List[DescribeAllCallbackResponseBodyCallbacks] = None,
        request_id: str = None,
    ):
        self.callbacks = callbacks
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.callbacks:
            for k in self.callbacks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Callbacks'] = []
        if self.callbacks is not None:
            for k in self.callbacks:
                result['Callbacks'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.callbacks = []
        if m.get('Callbacks') is not None:
            for k in m.get('Callbacks'):
                temp_model = DescribeAllCallbackResponseBodyCallbacks()
                self.callbacks.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAllCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAllCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAllCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppAgentFunctionStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeAppAgentFunctionStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DescribeAppAgentFunctionStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppAgentFunctionStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppAgentFunctionStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppAgentTemplatesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        id: str = None,
        name: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.id = id
        self.name = name
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppAgentTemplatesResponseBodyTemplatesAgentSilenceConfig(TeaModel):
    def __init__(
        self,
        alert_timeout: int = None,
        content: str = None,
        strategy: int = None,
        webhook_trigger_timeout: int = None,
    ):
        self.alert_timeout = alert_timeout
        self.content = content
        self.strategy = strategy
        self.webhook_trigger_timeout = webhook_trigger_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_timeout is not None:
            result['AlertTimeout'] = self.alert_timeout
        if self.content is not None:
            result['Content'] = self.content
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.webhook_trigger_timeout is not None:
            result['WebhookTriggerTimeout'] = self.webhook_trigger_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertTimeout') is not None:
            self.alert_timeout = m.get('AlertTimeout')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('WebhookTriggerTimeout') is not None:
            self.webhook_trigger_timeout = m.get('WebhookTriggerTimeout')
        return self


class DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfigVadConfig(TeaModel):
    def __init__(
        self,
        interrupt_speech_duration: int = None,
    ):
        self.interrupt_speech_duration = interrupt_speech_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interrupt_speech_duration is not None:
            result['InterruptSpeechDuration'] = self.interrupt_speech_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InterruptSpeechDuration') is not None:
            self.interrupt_speech_duration = m.get('InterruptSpeechDuration')
        return self


class DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfigWordWeights(TeaModel):
    def __init__(
        self,
        lang: str = None,
        weight: int = None,
        word: str = None,
    ):
        self.lang = lang
        self.weight = weight
        self.word = word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.weight is not None:
            result['Weight'] = self.weight
        if self.word is not None:
            result['Word'] = self.word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        return self


class DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfig(TeaModel):
    def __init__(
        self,
        max_sentence_silence: int = None,
        name: str = None,
        vad_config: DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfigVadConfig = None,
        vocabulary_id: str = None,
        word_weights: List[DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfigWordWeights] = None,
    ):
        self.max_sentence_silence = max_sentence_silence
        self.name = name
        self.vad_config = vad_config
        self.vocabulary_id = vocabulary_id
        self.word_weights = word_weights

    def validate(self):
        if self.vad_config:
            self.vad_config.validate()
        if self.word_weights:
            for k in self.word_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_sentence_silence is not None:
            result['MaxSentenceSilence'] = self.max_sentence_silence
        if self.name is not None:
            result['Name'] = self.name
        if self.vad_config is not None:
            result['VadConfig'] = self.vad_config.to_map()
        if self.vocabulary_id is not None:
            result['VocabularyId'] = self.vocabulary_id
        result['WordWeights'] = []
        if self.word_weights is not None:
            for k in self.word_weights:
                result['WordWeights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxSentenceSilence') is not None:
            self.max_sentence_silence = m.get('MaxSentenceSilence')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VadConfig') is not None:
            temp_model = DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfigVadConfig()
            self.vad_config = temp_model.from_map(m['VadConfig'])
        if m.get('VocabularyId') is not None:
            self.vocabulary_id = m.get('VocabularyId')
        self.word_weights = []
        if m.get('WordWeights') is not None:
            for k in m.get('WordWeights'):
                temp_model = DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfigWordWeights()
                self.word_weights.append(temp_model.from_map(k))
        return self


class DescribeAppAgentTemplatesResponseBodyTemplatesLlmConfig(TeaModel):
    def __init__(
        self,
        agent_app_id: str = None,
        api_key: str = None,
        history_depth: int = None,
        max_token: int = None,
        model: str = None,
        name: str = None,
        prompt: str = None,
        temperature: float = None,
        top_p: float = None,
        url: str = None,
        vendor: str = None,
    ):
        self.agent_app_id = agent_app_id
        self.api_key = api_key
        self.history_depth = history_depth
        self.max_token = max_token
        self.model = model
        self.name = name
        self.prompt = prompt
        self.temperature = temperature
        self.top_p = top_p
        self.url = url
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_app_id is not None:
            result['AgentAppId'] = self.agent_app_id
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.history_depth is not None:
            result['HistoryDepth'] = self.history_depth
        if self.max_token is not None:
            result['MaxToken'] = self.max_token
        if self.model is not None:
            result['Model'] = self.model
        if self.name is not None:
            result['Name'] = self.name
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.temperature is not None:
            result['Temperature'] = self.temperature
        if self.top_p is not None:
            result['TopP'] = self.top_p
        if self.url is not None:
            result['Url'] = self.url
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentAppId') is not None:
            self.agent_app_id = m.get('AgentAppId')
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('HistoryDepth') is not None:
            self.history_depth = m.get('HistoryDepth')
        if m.get('MaxToken') is not None:
            self.max_token = m.get('MaxToken')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Temperature') is not None:
            self.temperature = m.get('Temperature')
        if m.get('TopP') is not None:
            self.top_p = m.get('TopP')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class DescribeAppAgentTemplatesResponseBodyTemplatesTtsConfig(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        filter_brackets: List[int] = None,
        model: str = None,
        name: str = None,
        pitch: float = None,
        rate: float = None,
        vendor: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.api_key = api_key
        self.filter_brackets = filter_brackets
        self.model = model
        self.name = name
        self.pitch = pitch
        self.rate = rate
        self.vendor = vendor
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.filter_brackets is not None:
            result['FilterBrackets'] = self.filter_brackets
        if self.model is not None:
            result['Model'] = self.model
        if self.name is not None:
            result['Name'] = self.name
        if self.pitch is not None:
            result['Pitch'] = self.pitch
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('FilterBrackets') is not None:
            self.filter_brackets = m.get('FilterBrackets')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pitch') is not None:
            self.pitch = m.get('Pitch')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class DescribeAppAgentTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        agent_silence_config: DescribeAppAgentTemplatesResponseBodyTemplatesAgentSilenceConfig = None,
        asr_config: DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfig = None,
        chat_mode: int = None,
        create_time: str = None,
        greeting: str = None,
        id: str = None,
        interrupt_mode: int = None,
        llm_config: DescribeAppAgentTemplatesResponseBodyTemplatesLlmConfig = None,
        name: str = None,
        tts_config: DescribeAppAgentTemplatesResponseBodyTemplatesTtsConfig = None,
        type: int = None,
    ):
        self.agent_silence_config = agent_silence_config
        self.asr_config = asr_config
        self.chat_mode = chat_mode
        self.create_time = create_time
        self.greeting = greeting
        self.id = id
        self.interrupt_mode = interrupt_mode
        self.llm_config = llm_config
        self.name = name
        self.tts_config = tts_config
        self.type = type

    def validate(self):
        if self.agent_silence_config:
            self.agent_silence_config.validate()
        if self.asr_config:
            self.asr_config.validate()
        if self.llm_config:
            self.llm_config.validate()
        if self.tts_config:
            self.tts_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_silence_config is not None:
            result['AgentSilenceConfig'] = self.agent_silence_config.to_map()
        if self.asr_config is not None:
            result['AsrConfig'] = self.asr_config.to_map()
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.id is not None:
            result['Id'] = self.id
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        if self.llm_config is not None:
            result['LlmConfig'] = self.llm_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.tts_config is not None:
            result['TtsConfig'] = self.tts_config.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentSilenceConfig') is not None:
            temp_model = DescribeAppAgentTemplatesResponseBodyTemplatesAgentSilenceConfig()
            self.agent_silence_config = temp_model.from_map(m['AgentSilenceConfig'])
        if m.get('AsrConfig') is not None:
            temp_model = DescribeAppAgentTemplatesResponseBodyTemplatesAsrConfig()
            self.asr_config = temp_model.from_map(m['AsrConfig'])
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        if m.get('LlmConfig') is not None:
            temp_model = DescribeAppAgentTemplatesResponseBodyTemplatesLlmConfig()
            self.llm_config = temp_model.from_map(m['LlmConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TtsConfig') is not None:
            temp_model = DescribeAppAgentTemplatesResponseBodyTemplatesTtsConfig()
            self.tts_config = temp_model.from_map(m['TtsConfig'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAppAgentTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        templates: List[DescribeAppAgentTemplatesResponseBodyTemplates] = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.templates = templates
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['Templates'].append(k.to_map() if k else None)
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.templates = []
        if m.get('Templates') is not None:
            for k in m.get('Templates'):
                temp_model = DescribeAppAgentTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeAppAgentTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppAgentTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppAgentTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppCallStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeAppCallStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DescribeAppCallStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppCallStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppCallStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppCallbackSecretKeyRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeAppCallbackSecretKeyResponseBody(TeaModel):
    def __init__(
        self,
        callback_secret_key: str = None,
        request_id: str = None,
    ):
        self.callback_secret_key = callback_secret_key
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.callback_secret_key is not None:
            result['CallbackSecretKey'] = self.callback_secret_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallbackSecretKey') is not None:
            self.callback_secret_key = m.get('CallbackSecretKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAppCallbackSecretKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppCallbackSecretKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppCallbackSecretKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppKeyRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DescribeAppKeyResponseBody(TeaModel):
    def __init__(
        self,
        app_key: str = None,
        request_id: str = None,
    ):
        # AppKey。
        self.app_key = app_key
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key is not None:
            result['AppKey'] = self.app_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKey') is not None:
            self.app_key = m.get('AppKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAppKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppLayoutsRequestCondition(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        name: str = None,
    ):
        self.layout_id = layout_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeAppLayoutsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        condition: DescribeAppLayoutsRequestCondition = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.condition = condition
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.condition is not None:
            result['Condition'] = self.condition.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Condition') is not None:
            temp_model = DescribeAppLayoutsRequestCondition()
            self.condition = temp_model.from_map(m['Condition'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppLayoutsShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        condition_shrink: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.condition_shrink = condition_shrink
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.condition_shrink is not None:
            result['Condition'] = self.condition_shrink
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Condition') is not None:
            self.condition_shrink = m.get('Condition')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppLayoutsResponseBodyLayoutsPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class DescribeAppLayoutsResponseBodyLayouts(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        name: str = None,
        panes: List[DescribeAppLayoutsResponseBodyLayoutsPanes] = None,
    ):
        self.layout_id = layout_id
        self.name = name
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = DescribeAppLayoutsResponseBodyLayoutsPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class DescribeAppLayoutsResponseBody(TeaModel):
    def __init__(
        self,
        layouts: List[DescribeAppLayoutsResponseBodyLayouts] = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.layouts = layouts
        self.request_id = request_id
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.layouts:
            for k in self.layouts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Layouts'] = []
        if self.layouts is not None:
            for k in self.layouts:
                result['Layouts'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.layouts = []
        if m.get('Layouts') is not None:
            for k in m.get('Layouts'):
                temp_model = DescribeAppLayoutsResponseBodyLayouts()
                self.layouts.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeAppLayoutsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppLayoutsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppLayoutsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppLiveStreamStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeAppLiveStreamStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DescribeAppLiveStreamStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppLiveStreamStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppLiveStreamStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppRecordStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class DescribeAppRecordStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        result: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DescribeAppRecordStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppRecordStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppRecordStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppRecordTemplatesRequestCondition(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_id: str = None,
    ):
        self.name = name
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeAppRecordTemplatesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        condition: DescribeAppRecordTemplatesRequestCondition = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        self.condition = condition
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.condition is not None:
            result['Condition'] = self.condition.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Condition') is not None:
            temp_model = DescribeAppRecordTemplatesRequestCondition()
            self.condition = temp_model.from_map(m['Condition'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppRecordTemplatesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        condition_shrink: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        self.condition_shrink = condition_shrink
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.condition_shrink is not None:
            result['Condition'] = self.condition_shrink
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Condition') is not None:
            self.condition_shrink = m.get('Condition')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppRecordTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        delay_stop_time: int = None,
        file_prefix: str = None,
        file_split_interval: int = None,
        formats: List[str] = None,
        layout_ids: List[str] = None,
        media_encode: int = None,
        name: str = None,
        template_id: str = None,
    ):
        self.create_time = create_time
        self.delay_stop_time = delay_stop_time
        self.file_prefix = file_prefix
        self.file_split_interval = file_split_interval
        self.formats = formats
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.name = name
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.delay_stop_time is not None:
            result['DelayStopTime'] = self.delay_stop_time
        if self.file_prefix is not None:
            result['FilePrefix'] = self.file_prefix
        if self.file_split_interval is not None:
            result['FileSplitInterval'] = self.file_split_interval
        if self.formats is not None:
            result['Formats'] = self.formats
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DelayStopTime') is not None:
            self.delay_stop_time = m.get('DelayStopTime')
        if m.get('FilePrefix') is not None:
            self.file_prefix = m.get('FilePrefix')
        if m.get('FileSplitInterval') is not None:
            self.file_split_interval = m.get('FileSplitInterval')
        if m.get('Formats') is not None:
            self.formats = m.get('Formats')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeAppRecordTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        templates: List[DescribeAppRecordTemplatesResponseBodyTemplates] = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.templates = templates
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['Templates'].append(k.to_map() if k else None)
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.templates = []
        if m.get('Templates') is not None:
            for k in m.get('Templates'):
                temp_model = DescribeAppRecordTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeAppRecordTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppRecordTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppRecordTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppRecordingFilesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        end_ts: int = None,
        page_no: int = None,
        page_size: int = None,
        start_ts: int = None,
        task_ids: List[str] = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        self.channel_id = channel_id
        self.end_ts = end_ts
        self.page_no = page_no
        self.page_size = page_size
        self.start_ts = start_ts
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DescribeAppRecordingFilesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        end_ts: int = None,
        page_no: int = None,
        page_size: int = None,
        start_ts: int = None,
        task_ids_shrink: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        self.channel_id = channel_id
        self.end_ts = end_ts
        self.page_no = page_no
        self.page_size = page_size
        self.start_ts = start_ts
        self.task_ids_shrink = task_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        return self


class DescribeAppRecordingFilesResponseBodyItems(TeaModel):
    def __init__(
        self,
        bucket: str = None,
        channel_id: str = None,
        file_create_ts: int = None,
        file_duration: int = None,
        file_path: str = None,
        file_size: int = None,
        region: int = None,
        start_ts: int = None,
        task_id: str = None,
        vendor: int = None,
    ):
        self.bucket = bucket
        self.channel_id = channel_id
        self.file_create_ts = file_create_ts
        self.file_duration = file_duration
        self.file_path = file_path
        self.file_size = file_size
        self.region = region
        self.start_ts = start_ts
        self.task_id = task_id
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.file_create_ts is not None:
            result['FileCreateTs'] = self.file_create_ts
        if self.file_duration is not None:
            result['FileDuration'] = self.file_duration
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('FileCreateTs') is not None:
            self.file_create_ts = m.get('FileCreateTs')
        if m.get('FileDuration') is not None:
            self.file_duration = m.get('FileDuration')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class DescribeAppRecordingFilesResponseBody(TeaModel):
    def __init__(
        self,
        items: List[DescribeAppRecordingFilesResponseBodyItems] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_cnt: int = None,
    ):
        self.items = items
        self.page_no = page_no
        self.page_size = page_size
        # Id of the request
        self.request_id = request_id
        self.total_cnt = total_cnt

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = DescribeAppRecordingFilesResponseBodyItems()
                self.items.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribeAppRecordingFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppRecordingFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppRecordingFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppStreamingOutTemplatesRequestCondition(TeaModel):
    def __init__(
        self,
        name: str = None,
        template_id: str = None,
    ):
        self.name = name
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeAppStreamingOutTemplatesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        condition: DescribeAppStreamingOutTemplatesRequestCondition = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.condition = condition
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.condition is not None:
            result['Condition'] = self.condition.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Condition') is not None:
            temp_model = DescribeAppStreamingOutTemplatesRequestCondition()
            self.condition = temp_model.from_map(m['Condition'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppStreamingOutTemplatesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        condition_shrink: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.condition_shrink = condition_shrink
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.condition_shrink is not None:
            result['Condition'] = self.condition_shrink
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Condition') is not None:
            self.condition_shrink = m.get('Condition')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeAppStreamingOutTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        layout_ids: List[str] = None,
        media_encode: int = None,
        name: str = None,
        template_id: str = None,
    ):
        self.create_time = create_time
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.name = name
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeAppStreamingOutTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        templates: List[DescribeAppStreamingOutTemplatesResponseBodyTemplates] = None,
        total_num: int = None,
        total_page: int = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.templates = templates
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['Templates'].append(k.to_map() if k else None)
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.templates = []
        if m.get('Templates') is not None:
            for k in m.get('Templates'):
                temp_model = DescribeAppStreamingOutTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeAppStreamingOutTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppStreamingOutTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppStreamingOutTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAppsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_version: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        status: str = None,
    ):
        self.app_id = app_id
        self.app_version = app_version
        self.order = order
        self.owner_id = owner_id
        self.page_num = page_num
        self.page_size = page_size
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_version is not None:
            result['AppVersion'] = self.app_version
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppVersion') is not None:
            self.app_version = m.get('AppVersion')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAppsResponseBodyAppListAppServiceAreas(TeaModel):
    def __init__(
        self,
        service_area: List[str] = None,
    ):
        self.service_area = service_area

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_area is not None:
            result['ServiceArea'] = self.service_area
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ServiceArea') is not None:
            self.service_area = m.get('ServiceArea')
        return self


class DescribeAppsResponseBodyAppListApp(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        app_type: str = None,
        bill_type: str = None,
        create_time: str = None,
        service_areas: DescribeAppsResponseBodyAppListAppServiceAreas = None,
        status: int = None,
        version: str = None,
    ):
        self.app_id = app_id
        self.app_name = app_name
        self.app_type = app_type
        self.bill_type = bill_type
        self.create_time = create_time
        self.service_areas = service_areas
        self.status = status
        self.version = version

    def validate(self):
        if self.service_areas:
            self.service_areas.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.app_type is not None:
            result['AppType'] = self.app_type
        if self.bill_type is not None:
            result['BillType'] = self.bill_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.service_areas is not None:
            result['ServiceAreas'] = self.service_areas.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('AppType') is not None:
            self.app_type = m.get('AppType')
        if m.get('BillType') is not None:
            self.bill_type = m.get('BillType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ServiceAreas') is not None:
            temp_model = DescribeAppsResponseBodyAppListAppServiceAreas()
            self.service_areas = temp_model.from_map(m['ServiceAreas'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeAppsResponseBodyAppList(TeaModel):
    def __init__(
        self,
        app: List[DescribeAppsResponseBodyAppListApp] = None,
    ):
        self.app = app

    def validate(self):
        if self.app:
            for k in self.app:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['App'] = []
        if self.app is not None:
            for k in self.app:
                result['App'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app = []
        if m.get('App') is not None:
            for k in m.get('App'):
                temp_model = DescribeAppsResponseBodyAppListApp()
                self.app.append(temp_model.from_map(k))
        return self


class DescribeAppsResponseBody(TeaModel):
    def __init__(
        self,
        app_list: DescribeAppsResponseBodyAppList = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.app_list = app_list
        self.request_id = request_id
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.app_list:
            self.app_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_list is not None:
            result['AppList'] = self.app_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppList') is not None:
            temp_model = DescribeAppsResponseBodyAppList()
            self.app_list = temp_model.from_map(m['AppList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeAppsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAppsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAppsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoLiveStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DescribeAutoLiveStreamRuleResponseBodyRules(TeaModel):
    def __init__(
        self,
        call_back: str = None,
        channel_id_prefixes: List[str] = None,
        channel_ids: List[str] = None,
        create_time: str = None,
        media_encode: int = None,
        play_domain: str = None,
        rule_id: int = None,
        rule_name: str = None,
        status: str = None,
    ):
        self.call_back = call_back
        self.channel_id_prefixes = channel_id_prefixes
        self.channel_ids = channel_ids
        self.create_time = create_time
        self.media_encode = media_encode
        self.play_domain = play_domain
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.channel_id_prefixes is not None:
            result['ChannelIdPrefixes'] = self.channel_id_prefixes
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.play_domain is not None:
            result['PlayDomain'] = self.play_domain
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('ChannelIdPrefixes') is not None:
            self.channel_id_prefixes = m.get('ChannelIdPrefixes')
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('PlayDomain') is not None:
            self.play_domain = m.get('PlayDomain')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAutoLiveStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        rules: List[DescribeAutoLiveStreamRuleResponseBodyRules] = None,
    ):
        self.request_id = request_id
        self.rules = rules

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeAutoLiveStreamRuleResponseBodyRules()
                self.rules.append(temp_model.from_map(k))
        return self


class DescribeAutoLiveStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeAutoLiveStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoLiveStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCallRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        ext_data_type: str = None,
        query_exp_info: bool = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.ext_data_type = ext_data_type
        self.query_exp_info = query_exp_info

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.ext_data_type is not None:
            result['ExtDataType'] = self.ext_data_type
        if self.query_exp_info is not None:
            result['QueryExpInfo'] = self.query_exp_info
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('ExtDataType') is not None:
            self.ext_data_type = m.get('ExtDataType')
        if m.get('QueryExpInfo') is not None:
            self.query_exp_info = m.get('QueryExpInfo')
        return self


class DescribeCallResponseBodyCallInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        call_status: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
    ):
        # App ID。
        self.app_id = app_id
        self.call_status = call_status
        self.channel_id = channel_id
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.call_status is not None:
            result['CallStatus'] = self.call_status
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallStatus') is not None:
            self.call_status = m.get('CallStatus')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class DescribeCallResponseBodyUserDetailListDurMetricStatData(TeaModel):
    def __init__(
        self,
        pub_audio: int = None,
        pub_video_1080: int = None,
        pub_video_360: int = None,
        pub_video_720: int = None,
        pub_video_screen_share: int = None,
        sub_audio: int = None,
        sub_video_1080: int = None,
        sub_video_360: int = None,
        sub_video_720: int = None,
        sub_video_screen_share: int = None,
    ):
        self.pub_audio = pub_audio
        self.pub_video_1080 = pub_video_1080
        self.pub_video_360 = pub_video_360
        self.pub_video_720 = pub_video_720
        self.pub_video_screen_share = pub_video_screen_share
        self.sub_audio = sub_audio
        self.sub_video_1080 = sub_video_1080
        self.sub_video_360 = sub_video_360
        self.sub_video_720 = sub_video_720
        self.sub_video_screen_share = sub_video_screen_share

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pub_audio is not None:
            result['PubAudio'] = self.pub_audio
        if self.pub_video_1080 is not None:
            result['PubVideo1080'] = self.pub_video_1080
        if self.pub_video_360 is not None:
            result['PubVideo360'] = self.pub_video_360
        if self.pub_video_720 is not None:
            result['PubVideo720'] = self.pub_video_720
        if self.pub_video_screen_share is not None:
            result['PubVideoScreenShare'] = self.pub_video_screen_share
        if self.sub_audio is not None:
            result['SubAudio'] = self.sub_audio
        if self.sub_video_1080 is not None:
            result['SubVideo1080'] = self.sub_video_1080
        if self.sub_video_360 is not None:
            result['SubVideo360'] = self.sub_video_360
        if self.sub_video_720 is not None:
            result['SubVideo720'] = self.sub_video_720
        if self.sub_video_screen_share is not None:
            result['SubVideoScreenShare'] = self.sub_video_screen_share
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PubAudio') is not None:
            self.pub_audio = m.get('PubAudio')
        if m.get('PubVideo1080') is not None:
            self.pub_video_1080 = m.get('PubVideo1080')
        if m.get('PubVideo360') is not None:
            self.pub_video_360 = m.get('PubVideo360')
        if m.get('PubVideo720') is not None:
            self.pub_video_720 = m.get('PubVideo720')
        if m.get('PubVideoScreenShare') is not None:
            self.pub_video_screen_share = m.get('PubVideoScreenShare')
        if m.get('SubAudio') is not None:
            self.sub_audio = m.get('SubAudio')
        if m.get('SubVideo1080') is not None:
            self.sub_video_1080 = m.get('SubVideo1080')
        if m.get('SubVideo360') is not None:
            self.sub_video_360 = m.get('SubVideo360')
        if m.get('SubVideo720') is not None:
            self.sub_video_720 = m.get('SubVideo720')
        if m.get('SubVideoScreenShare') is not None:
            self.sub_video_screen_share = m.get('SubVideoScreenShare')
        return self


class DescribeCallResponseBodyUserDetailListOnlinePeriods(TeaModel):
    def __init__(
        self,
        join_ts: int = None,
        leave_ts: int = None,
    ):
        self.join_ts = join_ts
        self.leave_ts = leave_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_ts is not None:
            result['JoinTs'] = self.join_ts
        if self.leave_ts is not None:
            result['LeaveTs'] = self.leave_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTs') is not None:
            self.join_ts = m.get('JoinTs')
        if m.get('LeaveTs') is not None:
            self.leave_ts = m.get('LeaveTs')
        return self


class DescribeCallResponseBodyUserDetailList(TeaModel):
    def __init__(
        self,
        call_exp: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        dur_metric_stat_data: DescribeCallResponseBodyUserDetailListDurMetricStatData = None,
        duration: int = None,
        location: str = None,
        network: str = None,
        network_list: List[str] = None,
        online_duration: int = None,
        online_periods: List[DescribeCallResponseBodyUserDetailListOnlinePeriods] = None,
        os: str = None,
        os_list: List[str] = None,
        roles: List[str] = None,
        sdk_version: str = None,
        sdk_version_list: List[str] = None,
        user_id: str = None,
    ):
        self.call_exp = call_exp
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.dur_metric_stat_data = dur_metric_stat_data
        self.duration = duration
        self.location = location
        self.network = network
        self.network_list = network_list
        self.online_duration = online_duration
        self.online_periods = online_periods
        self.os = os
        self.os_list = os_list
        self.roles = roles
        self.sdk_version = sdk_version
        self.sdk_version_list = sdk_version_list
        self.user_id = user_id

    def validate(self):
        if self.dur_metric_stat_data:
            self.dur_metric_stat_data.validate()
        if self.online_periods:
            for k in self.online_periods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_exp is not None:
            result['CallExp'] = self.call_exp
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.dur_metric_stat_data is not None:
            result['DurMetricStatData'] = self.dur_metric_stat_data.to_map()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.location is not None:
            result['Location'] = self.location
        if self.network is not None:
            result['Network'] = self.network
        if self.network_list is not None:
            result['NetworkList'] = self.network_list
        if self.online_duration is not None:
            result['OnlineDuration'] = self.online_duration
        result['OnlinePeriods'] = []
        if self.online_periods is not None:
            for k in self.online_periods:
                result['OnlinePeriods'].append(k.to_map() if k else None)
        if self.os is not None:
            result['Os'] = self.os
        if self.os_list is not None:
            result['OsList'] = self.os_list
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.sdk_version_list is not None:
            result['SdkVersionList'] = self.sdk_version_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallExp') is not None:
            self.call_exp = m.get('CallExp')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('DurMetricStatData') is not None:
            temp_model = DescribeCallResponseBodyUserDetailListDurMetricStatData()
            self.dur_metric_stat_data = temp_model.from_map(m['DurMetricStatData'])
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('NetworkList') is not None:
            self.network_list = m.get('NetworkList')
        if m.get('OnlineDuration') is not None:
            self.online_duration = m.get('OnlineDuration')
        self.online_periods = []
        if m.get('OnlinePeriods') is not None:
            for k in m.get('OnlinePeriods'):
                temp_model = DescribeCallResponseBodyUserDetailListOnlinePeriods()
                self.online_periods.append(temp_model.from_map(k))
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsList') is not None:
            self.os_list = m.get('OsList')
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('SdkVersionList') is not None:
            self.sdk_version_list = m.get('SdkVersionList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeCallResponseBody(TeaModel):
    def __init__(
        self,
        call_info: DescribeCallResponseBodyCallInfo = None,
        request_id: str = None,
        user_detail_list: List[DescribeCallResponseBodyUserDetailList] = None,
    ):
        self.call_info = call_info
        self.request_id = request_id
        self.user_detail_list = user_detail_list

    def validate(self):
        if self.call_info:
            self.call_info.validate()
        if self.user_detail_list:
            for k in self.user_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_info is not None:
            result['CallInfo'] = self.call_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UserDetailList'] = []
        if self.user_detail_list is not None:
            for k in self.user_detail_list:
                result['UserDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallInfo') is not None:
            temp_model = DescribeCallResponseBodyCallInfo()
            self.call_info = temp_model.from_map(m['CallInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.user_detail_list = []
        if m.get('UserDetailList') is not None:
            for k in m.get('UserDetailList'):
                temp_model = DescribeCallResponseBodyUserDetailList()
                self.user_detail_list.append(temp_model.from_map(k))
        return self


class DescribeCallResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCallResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCallResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCallListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        call_status: str = None,
        channel_id: str = None,
        end_ts: int = None,
        order_by: str = None,
        page_no: int = None,
        page_size: int = None,
        query_mode: str = None,
        start_ts: int = None,
        user_id: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        self.call_status = call_status
        self.channel_id = channel_id
        # This parameter is required.
        self.end_ts = end_ts
        self.order_by = order_by
        # This parameter is required.
        self.page_no = page_no
        # This parameter is required.
        self.page_size = page_size
        self.query_mode = query_mode
        # This parameter is required.
        self.start_ts = start_ts
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.call_status is not None:
            result['CallStatus'] = self.call_status
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.query_mode is not None:
            result['QueryMode'] = self.query_mode
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallStatus') is not None:
            self.call_status = m.get('CallStatus')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('QueryMode') is not None:
            self.query_mode = m.get('QueryMode')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeCallListResponseBodyCallList(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        bad_exp_user_cnt: int = None,
        call_status: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
        user_cnt: int = None,
    ):
        # App ID。
        self.app_id = app_id
        self.bad_exp_user_cnt = bad_exp_user_cnt
        self.call_status = call_status
        self.channel_id = channel_id
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration
        self.user_cnt = user_cnt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.bad_exp_user_cnt is not None:
            result['BadExpUserCnt'] = self.bad_exp_user_cnt
        if self.call_status is not None:
            result['CallStatus'] = self.call_status
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.user_cnt is not None:
            result['UserCnt'] = self.user_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BadExpUserCnt') is not None:
            self.bad_exp_user_cnt = m.get('BadExpUserCnt')
        if m.get('CallStatus') is not None:
            self.call_status = m.get('CallStatus')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('UserCnt') is not None:
            self.user_cnt = m.get('UserCnt')
        return self


class DescribeCallListResponseBody(TeaModel):
    def __init__(
        self,
        call_list: List[DescribeCallListResponseBodyCallList] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_cnt: int = None,
    ):
        self.call_list = call_list
        self.page_no = page_no
        self.page_size = page_size
        self.request_id = request_id
        self.total_cnt = total_cnt

    def validate(self):
        if self.call_list:
            for k in self.call_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CallList'] = []
        if self.call_list is not None:
            for k in self.call_list:
                result['CallList'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.call_list = []
        if m.get('CallList') is not None:
            for k in m.get('CallList'):
                temp_model = DescribeCallListResponseBodyCallList()
                self.call_list.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribeCallListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCallListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCallListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCallbacksRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class DescribeCallbacksResponseBodyCallbacks(TeaModel):
    def __init__(
        self,
        category: str = None,
        check_status: str = None,
        code: str = None,
        conf: str = None,
        msg: str = None,
        status: int = None,
        sub_event: List[int] = None,
    ):
        self.category = category
        self.check_status = check_status
        self.code = code
        self.conf = conf
        self.msg = msg
        self.status = status
        self.sub_event = sub_event

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.check_status is not None:
            result['CheckStatus'] = self.check_status
        if self.code is not None:
            result['Code'] = self.code
        if self.conf is not None:
            result['Conf'] = self.conf
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_event is not None:
            result['SubEvent'] = self.sub_event
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CheckStatus') is not None:
            self.check_status = m.get('CheckStatus')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Conf') is not None:
            self.conf = m.get('Conf')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubEvent') is not None:
            self.sub_event = m.get('SubEvent')
        return self


class DescribeCallbacksResponseBody(TeaModel):
    def __init__(
        self,
        callbacks: List[DescribeCallbacksResponseBodyCallbacks] = None,
        request_id: str = None,
    ):
        self.callbacks = callbacks
        # Id of the request
        self.request_id = request_id

    def validate(self):
        if self.callbacks:
            for k in self.callbacks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Callbacks'] = []
        if self.callbacks is not None:
            for k in self.callbacks:
                result['Callbacks'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.callbacks = []
        if m.get('Callbacks') is not None:
            for k in m.get('Callbacks'):
                temp_model = DescribeCallbacksResponseBodyCallbacks()
                self.callbacks.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCallbacksResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCallbacksResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCallbacksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class DescribeChannelResponseBodyChannel(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        start_time: int = None,
    ):
        self.channel_id = channel_id
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeChannelResponseBody(TeaModel):
    def __init__(
        self,
        channel: DescribeChannelResponseBodyChannel = None,
        channel_exist: bool = None,
        request_id: str = None,
    ):
        # channel
        self.channel = channel
        self.channel_exist = channel_exist
        self.request_id = request_id

    def validate(self):
        if self.channel:
            self.channel.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel.to_map()
        if self.channel_exist is not None:
            result['ChannelExist'] = self.channel_exist
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Channel') is not None:
            temp_model = DescribeChannelResponseBodyChannel()
            self.channel = temp_model.from_map(m['Channel'])
        if m.get('ChannelExist') is not None:
            self.channel_exist = m.get('ChannelExist')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelAllUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class DescribeChannelAllUsersResponseBodyUsers(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeChannelAllUsersResponseBody(TeaModel):
    def __init__(
        self,
        channel_exist: bool = None,
        request_id: str = None,
        users: List[DescribeChannelAllUsersResponseBodyUsers] = None,
    ):
        self.channel_exist = channel_exist
        self.request_id = request_id
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_exist is not None:
            result['ChannelExist'] = self.channel_exist
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelExist') is not None:
            self.channel_exist = m.get('ChannelExist')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = DescribeChannelAllUsersResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class DescribeChannelAllUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelAllUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelAllUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelAreaDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        parent_area: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.parent_area = parent_area

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.parent_area is not None:
            result['ParentArea'] = self.parent_area
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('ParentArea') is not None:
            self.parent_area = m.get('ParentArea')
        return self


class DescribeChannelAreaDistributionStatDataResponseBodyAreaStatList(TeaModel):
    def __init__(
        self,
        area_name: str = None,
        call_user_count: int = None,
        high_quality_transmission_rate: str = None,
        pub_user_count: int = None,
        sub_user_count: int = None,
    ):
        self.area_name = area_name
        self.call_user_count = call_user_count
        self.high_quality_transmission_rate = high_quality_transmission_rate
        self.pub_user_count = pub_user_count
        self.sub_user_count = sub_user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area_name is not None:
            result['AreaName'] = self.area_name
        if self.call_user_count is not None:
            result['CallUserCount'] = self.call_user_count
        if self.high_quality_transmission_rate is not None:
            result['HighQualityTransmissionRate'] = self.high_quality_transmission_rate
        if self.pub_user_count is not None:
            result['PubUserCount'] = self.pub_user_count
        if self.sub_user_count is not None:
            result['SubUserCount'] = self.sub_user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AreaName') is not None:
            self.area_name = m.get('AreaName')
        if m.get('CallUserCount') is not None:
            self.call_user_count = m.get('CallUserCount')
        if m.get('HighQualityTransmissionRate') is not None:
            self.high_quality_transmission_rate = m.get('HighQualityTransmissionRate')
        if m.get('PubUserCount') is not None:
            self.pub_user_count = m.get('PubUserCount')
        if m.get('SubUserCount') is not None:
            self.sub_user_count = m.get('SubUserCount')
        return self


class DescribeChannelAreaDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        area_stat_list: List[DescribeChannelAreaDistributionStatDataResponseBodyAreaStatList] = None,
        request_id: str = None,
    ):
        self.area_stat_list = area_stat_list
        self.request_id = request_id

    def validate(self):
        if self.area_stat_list:
            for k in self.area_stat_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AreaStatList'] = []
        if self.area_stat_list is not None:
            for k in self.area_stat_list:
                result['AreaStatList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.area_stat_list = []
        if m.get('AreaStatList') is not None:
            for k in m.get('AreaStatList'):
                temp_model = DescribeChannelAreaDistributionStatDataResponseBodyAreaStatList()
                self.area_stat_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeChannelAreaDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelAreaDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelAreaDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        stat_dim: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        # This parameter is required.
        self.stat_dim = stat_dim

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.stat_dim is not None:
            result['StatDim'] = self.stat_dim
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('StatDim') is not None:
            self.stat_dim = m.get('StatDim')
        return self


class DescribeChannelDistributionStatDataResponseBodyStatList(TeaModel):
    def __init__(
        self,
        call_user_count: int = None,
        call_user_ratio: str = None,
        name: str = None,
    ):
        self.call_user_count = call_user_count
        self.call_user_ratio = call_user_ratio
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_user_count is not None:
            result['CallUserCount'] = self.call_user_count
        if self.call_user_ratio is not None:
            result['CallUserRatio'] = self.call_user_ratio
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallUserCount') is not None:
            self.call_user_count = m.get('CallUserCount')
        if m.get('CallUserRatio') is not None:
            self.call_user_ratio = m.get('CallUserRatio')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeChannelDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stat_list: List[DescribeChannelDistributionStatDataResponseBodyStatList] = None,
    ):
        self.request_id = request_id
        self.stat_list = stat_list

    def validate(self):
        if self.stat_list:
            for k in self.stat_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StatList'] = []
        if self.stat_list is not None:
            for k in self.stat_list:
                result['StatList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.stat_list = []
        if m.get('StatList') is not None:
            for k in m.get('StatList'):
                temp_model = DescribeChannelDistributionStatDataResponseBodyStatList()
                self.stat_list.append(temp_model.from_map(k))
        return self


class DescribeChannelDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelOverallDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        return self


class DescribeChannelOverallDataResponseBodyCallInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        call_status: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
    ):
        self.app_id = app_id
        self.call_status = call_status
        self.channel_id = channel_id
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.call_status is not None:
            result['CallStatus'] = self.call_status
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallStatus') is not None:
            self.call_status = m.get('CallStatus')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class DescribeChannelOverallDataResponseBodyMetricDatasNodes(TeaModel):
    def __init__(
        self,
        ext: Dict[str, Any] = None,
        x: str = None,
        y: str = None,
    ):
        self.ext = ext
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeChannelOverallDataResponseBodyMetricDatas(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeChannelOverallDataResponseBodyMetricDatasNodes] = None,
        type: str = None,
    ):
        self.nodes = nodes
        self.type = type

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeChannelOverallDataResponseBodyMetricDatasNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeChannelOverallDataResponseBodyOverallData(TeaModel):
    def __init__(
        self,
        conn_avg_time: float = None,
        five_sec_join_rate: float = None,
        total_audio_stuck_rate: float = None,
        total_video_stuck_rate: float = None,
        total_video_vague_rate: float = None,
    ):
        self.conn_avg_time = conn_avg_time
        self.five_sec_join_rate = five_sec_join_rate
        self.total_audio_stuck_rate = total_audio_stuck_rate
        self.total_video_stuck_rate = total_video_stuck_rate
        self.total_video_vague_rate = total_video_vague_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conn_avg_time is not None:
            result['ConnAvgTime'] = self.conn_avg_time
        if self.five_sec_join_rate is not None:
            result['FiveSecJoinRate'] = self.five_sec_join_rate
        if self.total_audio_stuck_rate is not None:
            result['TotalAudioStuckRate'] = self.total_audio_stuck_rate
        if self.total_video_stuck_rate is not None:
            result['TotalVideoStuckRate'] = self.total_video_stuck_rate
        if self.total_video_vague_rate is not None:
            result['TotalVideoVagueRate'] = self.total_video_vague_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConnAvgTime') is not None:
            self.conn_avg_time = m.get('ConnAvgTime')
        if m.get('FiveSecJoinRate') is not None:
            self.five_sec_join_rate = m.get('FiveSecJoinRate')
        if m.get('TotalAudioStuckRate') is not None:
            self.total_audio_stuck_rate = m.get('TotalAudioStuckRate')
        if m.get('TotalVideoStuckRate') is not None:
            self.total_video_stuck_rate = m.get('TotalVideoStuckRate')
        if m.get('TotalVideoVagueRate') is not None:
            self.total_video_vague_rate = m.get('TotalVideoVagueRate')
        return self


class DescribeChannelOverallDataResponseBody(TeaModel):
    def __init__(
        self,
        call_info: DescribeChannelOverallDataResponseBodyCallInfo = None,
        metric_datas: List[DescribeChannelOverallDataResponseBodyMetricDatas] = None,
        overall_data: DescribeChannelOverallDataResponseBodyOverallData = None,
        request_id: str = None,
    ):
        self.call_info = call_info
        self.metric_datas = metric_datas
        self.overall_data = overall_data
        self.request_id = request_id

    def validate(self):
        if self.call_info:
            self.call_info.validate()
        if self.metric_datas:
            for k in self.metric_datas:
                if k:
                    k.validate()
        if self.overall_data:
            self.overall_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_info is not None:
            result['CallInfo'] = self.call_info.to_map()
        result['MetricDatas'] = []
        if self.metric_datas is not None:
            for k in self.metric_datas:
                result['MetricDatas'].append(k.to_map() if k else None)
        if self.overall_data is not None:
            result['OverallData'] = self.overall_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallInfo') is not None:
            temp_model = DescribeChannelOverallDataResponseBodyCallInfo()
            self.call_info = temp_model.from_map(m['CallInfo'])
        self.metric_datas = []
        if m.get('MetricDatas') is not None:
            for k in m.get('MetricDatas'):
                temp_model = DescribeChannelOverallDataResponseBodyMetricDatas()
                self.metric_datas.append(temp_model.from_map(k))
        if m.get('OverallData') is not None:
            temp_model = DescribeChannelOverallDataResponseBodyOverallData()
            self.overall_data = temp_model.from_map(m['OverallData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeChannelOverallDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelOverallDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelOverallDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelParticipantsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        order: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.order = order
        self.owner_id = owner_id
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.order is not None:
            result['Order'] = self.order
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeChannelParticipantsResponseBodyUserList(TeaModel):
    def __init__(
        self,
        user: List[str] = None,
    ):
        self.user = user

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user is not None:
            result['User'] = self.user
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('User') is not None:
            self.user = m.get('User')
        return self


class DescribeChannelParticipantsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        timestamp: int = None,
        total_num: int = None,
        total_page: int = None,
        user_list: DescribeChannelParticipantsResponseBodyUserList = None,
    ):
        self.request_id = request_id
        self.timestamp = timestamp
        self.total_num = total_num
        self.total_page = total_page
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            self.user_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        if self.user_list is not None:
            result['UserList'] = self.user_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        if m.get('UserList') is not None:
            temp_model = DescribeChannelParticipantsResponseBodyUserList()
            self.user_list = temp_model.from_map(m['UserList'])
        return self


class DescribeChannelParticipantsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelParticipantsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelParticipantsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelTopPubUserListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        return self


class DescribeChannelTopPubUserListResponseBodyTopPubUserDetailListOnlinePeriods(TeaModel):
    def __init__(
        self,
        join_ts: int = None,
        leave_ts: int = None,
    ):
        self.join_ts = join_ts
        self.leave_ts = leave_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_ts is not None:
            result['JoinTs'] = self.join_ts
        if self.leave_ts is not None:
            result['LeaveTs'] = self.leave_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTs') is not None:
            self.join_ts = m.get('JoinTs')
        if m.get('LeaveTs') is not None:
            self.leave_ts = m.get('LeaveTs')
        return self


class DescribeChannelTopPubUserListResponseBodyTopPubUserDetailList(TeaModel):
    def __init__(
        self,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
        location: str = None,
        online_duration: int = None,
        online_periods: List[DescribeChannelTopPubUserListResponseBodyTopPubUserDetailListOnlinePeriods] = None,
        user_id: str = None,
    ):
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration
        self.location = location
        self.online_duration = online_duration
        self.online_periods = online_periods
        self.user_id = user_id

    def validate(self):
        if self.online_periods:
            for k in self.online_periods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.location is not None:
            result['Location'] = self.location
        if self.online_duration is not None:
            result['OnlineDuration'] = self.online_duration
        result['OnlinePeriods'] = []
        if self.online_periods is not None:
            for k in self.online_periods:
                result['OnlinePeriods'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('OnlineDuration') is not None:
            self.online_duration = m.get('OnlineDuration')
        self.online_periods = []
        if m.get('OnlinePeriods') is not None:
            for k in m.get('OnlinePeriods'):
                temp_model = DescribeChannelTopPubUserListResponseBodyTopPubUserDetailListOnlinePeriods()
                self.online_periods.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeChannelTopPubUserListResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        top_pub_user_detail_list: List[DescribeChannelTopPubUserListResponseBodyTopPubUserDetailList] = None,
    ):
        self.request_id = request_id
        self.top_pub_user_detail_list = top_pub_user_detail_list

    def validate(self):
        if self.top_pub_user_detail_list:
            for k in self.top_pub_user_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TopPubUserDetailList'] = []
        if self.top_pub_user_detail_list is not None:
            for k in self.top_pub_user_detail_list:
                result['TopPubUserDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.top_pub_user_detail_list = []
        if m.get('TopPubUserDetailList') is not None:
            for k in m.get('TopPubUserDetailList'):
                temp_model = DescribeChannelTopPubUserListResponseBodyTopPubUserDetailList()
                self.top_pub_user_detail_list.append(temp_model.from_map(k))
        return self


class DescribeChannelTopPubUserListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelTopPubUserListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelTopPubUserListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeChannelUserResponseBodySessions(TeaModel):
    def __init__(
        self,
        joined: int = None,
        session_id: str = None,
        user_id: str = None,
    ):
        self.joined = joined
        self.session_id = session_id
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.joined is not None:
            result['Joined'] = self.joined
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Joined') is not None:
            self.joined = m.get('Joined')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeChannelUserResponseBody(TeaModel):
    def __init__(
        self,
        channel_exist: bool = None,
        in_channel: bool = None,
        request_id: str = None,
        sessions: List[DescribeChannelUserResponseBodySessions] = None,
    ):
        self.channel_exist = channel_exist
        self.in_channel = in_channel
        self.request_id = request_id
        self.sessions = sessions

    def validate(self):
        if self.sessions:
            for k in self.sessions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_exist is not None:
            result['ChannelExist'] = self.channel_exist
        if self.in_channel is not None:
            result['InChannel'] = self.in_channel
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Sessions'] = []
        if self.sessions is not None:
            for k in self.sessions:
                result['Sessions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelExist') is not None:
            self.channel_exist = m.get('ChannelExist')
        if m.get('InChannel') is not None:
            self.in_channel = m.get('InChannel')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sessions = []
        if m.get('Sessions') is not None:
            for k in m.get('Sessions'):
                temp_model = DescribeChannelUserResponseBodySessions()
                self.sessions.append(temp_model.from_map(k))
        return self


class DescribeChannelUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelUserMetricsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        return self


class DescribeChannelUserMetricsResponseBodyMetricDatasNodes(TeaModel):
    def __init__(
        self,
        ext: Dict[str, Any] = None,
        x: str = None,
        y: str = None,
    ):
        self.ext = ext
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeChannelUserMetricsResponseBodyMetricDatas(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeChannelUserMetricsResponseBodyMetricDatasNodes] = None,
        type: str = None,
    ):
        self.nodes = nodes
        self.type = type

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeChannelUserMetricsResponseBodyMetricDatasNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeChannelUserMetricsResponseBodyOverallData(TeaModel):
    def __init__(
        self,
        total_bad_exp_num: int = None,
        total_join_fail_num: int = None,
        total_pub_user_num: int = None,
        total_sub_user_num: int = None,
        total_user_num: int = None,
    ):
        self.total_bad_exp_num = total_bad_exp_num
        self.total_join_fail_num = total_join_fail_num
        self.total_pub_user_num = total_pub_user_num
        self.total_sub_user_num = total_sub_user_num
        self.total_user_num = total_user_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.total_bad_exp_num is not None:
            result['TotalBadExpNum'] = self.total_bad_exp_num
        if self.total_join_fail_num is not None:
            result['TotalJoinFailNum'] = self.total_join_fail_num
        if self.total_pub_user_num is not None:
            result['TotalPubUserNum'] = self.total_pub_user_num
        if self.total_sub_user_num is not None:
            result['TotalSubUserNum'] = self.total_sub_user_num
        if self.total_user_num is not None:
            result['TotalUserNum'] = self.total_user_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TotalBadExpNum') is not None:
            self.total_bad_exp_num = m.get('TotalBadExpNum')
        if m.get('TotalJoinFailNum') is not None:
            self.total_join_fail_num = m.get('TotalJoinFailNum')
        if m.get('TotalPubUserNum') is not None:
            self.total_pub_user_num = m.get('TotalPubUserNum')
        if m.get('TotalSubUserNum') is not None:
            self.total_sub_user_num = m.get('TotalSubUserNum')
        if m.get('TotalUserNum') is not None:
            self.total_user_num = m.get('TotalUserNum')
        return self


class DescribeChannelUserMetricsResponseBody(TeaModel):
    def __init__(
        self,
        metric_datas: List[DescribeChannelUserMetricsResponseBodyMetricDatas] = None,
        overall_data: DescribeChannelUserMetricsResponseBodyOverallData = None,
        request_id: str = None,
    ):
        self.metric_datas = metric_datas
        self.overall_data = overall_data
        self.request_id = request_id

    def validate(self):
        if self.metric_datas:
            for k in self.metric_datas:
                if k:
                    k.validate()
        if self.overall_data:
            self.overall_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricDatas'] = []
        if self.metric_datas is not None:
            for k in self.metric_datas:
                result['MetricDatas'].append(k.to_map() if k else None)
        if self.overall_data is not None:
            result['OverallData'] = self.overall_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.metric_datas = []
        if m.get('MetricDatas') is not None:
            for k in m.get('MetricDatas'):
                temp_model = DescribeChannelUserMetricsResponseBodyMetricDatas()
                self.metric_datas.append(temp_model.from_map(k))
        if m.get('OverallData') is not None:
            temp_model = DescribeChannelUserMetricsResponseBodyOverallData()
            self.overall_data = temp_model.from_map(m['OverallData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeChannelUserMetricsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelUserMetricsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelUserMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class DescribeChannelUsersResponseBody(TeaModel):
    def __init__(
        self,
        channel_profile: int = None,
        comm_total_num: int = None,
        interactive_user_list: List[str] = None,
        interactive_user_num: int = None,
        is_channel_exist: bool = None,
        live_user_list: List[str] = None,
        live_user_num: int = None,
        request_id: str = None,
        timestamp: int = None,
        user_list: List[str] = None,
    ):
        self.channel_profile = channel_profile
        self.comm_total_num = comm_total_num
        self.interactive_user_list = interactive_user_list
        self.interactive_user_num = interactive_user_num
        self.is_channel_exist = is_channel_exist
        self.live_user_list = live_user_list
        self.live_user_num = live_user_num
        self.request_id = request_id
        self.timestamp = timestamp
        self.user_list = user_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_profile is not None:
            result['ChannelProfile'] = self.channel_profile
        if self.comm_total_num is not None:
            result['CommTotalNum'] = self.comm_total_num
        if self.interactive_user_list is not None:
            result['InteractiveUserList'] = self.interactive_user_list
        if self.interactive_user_num is not None:
            result['InteractiveUserNum'] = self.interactive_user_num
        if self.is_channel_exist is not None:
            result['IsChannelExist'] = self.is_channel_exist
        if self.live_user_list is not None:
            result['LiveUserList'] = self.live_user_list
        if self.live_user_num is not None:
            result['LiveUserNum'] = self.live_user_num
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.user_list is not None:
            result['UserList'] = self.user_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelProfile') is not None:
            self.channel_profile = m.get('ChannelProfile')
        if m.get('CommTotalNum') is not None:
            self.comm_total_num = m.get('CommTotalNum')
        if m.get('InteractiveUserList') is not None:
            self.interactive_user_list = m.get('InteractiveUserList')
        if m.get('InteractiveUserNum') is not None:
            self.interactive_user_num = m.get('InteractiveUserNum')
        if m.get('IsChannelExist') is not None:
            self.is_channel_exist = m.get('IsChannelExist')
        if m.get('LiveUserList') is not None:
            self.live_user_list = m.get('LiveUserList')
        if m.get('LiveUserNum') is not None:
            self.live_user_num = m.get('LiveUserNum')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('UserList') is not None:
            self.user_list = m.get('UserList')
        return self


class DescribeChannelUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeChannelsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        page_no: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.page_no = page_no
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeChannelsResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        records: List[str] = None,
        request_id: str = None,
        total_cnt: int = None,
    ):
        self.page_no = page_no
        self.page_size = page_size
        self.records = records
        self.request_id = request_id
        self.total_cnt = total_cnt

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.records is not None:
            result['Records'] = self.records
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Records') is not None:
            self.records = m.get('Records')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribeChannelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeChannelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeChannelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudNotePhrasesRequestCondition(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeCloudNotePhrasesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        condition: DescribeCloudNotePhrasesRequestCondition = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.condition = condition
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        if self.condition:
            self.condition.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.condition is not None:
            result['Condition'] = self.condition.to_map()
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Condition') is not None:
            temp_model = DescribeCloudNotePhrasesRequestCondition()
            self.condition = temp_model.from_map(m['Condition'])
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeCloudNotePhrasesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        condition_shrink: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.condition_shrink = condition_shrink
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.condition_shrink is not None:
            result['Condition'] = self.condition_shrink
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Condition') is not None:
            self.condition_shrink = m.get('Condition')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeCloudNotePhrasesResponseBodyPhrasesWordWeights(TeaModel):
    def __init__(
        self,
        weight: int = None,
        word: str = None,
    ):
        self.weight = weight
        self.word = word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.weight is not None:
            result['Weight'] = self.weight
        if self.word is not None:
            result['Word'] = self.word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        return self


class DescribeCloudNotePhrasesResponseBodyPhrases(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
        word_weights: List[DescribeCloudNotePhrasesResponseBodyPhrasesWordWeights] = None,
    ):
        self.create_time = create_time
        self.description = description
        self.id = id
        self.name = name
        # This parameter is required.
        self.word_weights = word_weights

    def validate(self):
        if self.word_weights:
            for k in self.word_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['WordWeights'] = []
        if self.word_weights is not None:
            for k in self.word_weights:
                result['WordWeights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.word_weights = []
        if m.get('WordWeights') is not None:
            for k in m.get('WordWeights'):
                temp_model = DescribeCloudNotePhrasesResponseBodyPhrasesWordWeights()
                self.word_weights.append(temp_model.from_map(k))
        return self


class DescribeCloudNotePhrasesResponseBody(TeaModel):
    def __init__(
        self,
        phrases: List[DescribeCloudNotePhrasesResponseBodyPhrases] = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.phrases = phrases
        # Id of the request。
        self.request_id = request_id
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.phrases:
            for k in self.phrases:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Phrases'] = []
        if self.phrases is not None:
            for k in self.phrases:
                result['Phrases'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.phrases = []
        if m.get('Phrases') is not None:
            for k in m.get('Phrases'):
                temp_model = DescribeCloudNotePhrasesResponseBodyPhrases()
                self.phrases.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeCloudNotePhrasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudNotePhrasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudNotePhrasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudNotesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        end_ts: int = None,
        page_no: int = None,
        page_size: int = None,
        start_ts: int = None,
        task_ids: List[str] = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        self.channel_id = channel_id
        self.end_ts = end_ts
        self.page_no = page_no
        self.page_size = page_size
        self.start_ts = start_ts
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DescribeCloudNotesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        end_ts: int = None,
        page_no: int = None,
        page_size: int = None,
        start_ts: int = None,
        task_ids_shrink: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        self.channel_id = channel_id
        self.end_ts = end_ts
        self.page_no = page_no
        self.page_size = page_size
        self.start_ts = start_ts
        self.task_ids_shrink = task_ids_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.task_ids_shrink is not None:
            result['TaskIds'] = self.task_ids_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('TaskIds') is not None:
            self.task_ids_shrink = m.get('TaskIds')
        return self


class DescribeCloudNotesResponseBodyItems(TeaModel):
    def __init__(
        self,
        auto_chapters_file_path: str = None,
        bucket: str = None,
        channel_id: str = None,
        custom_prompt_file_path: str = None,
        meeting_assistance_file_path: str = None,
        region: int = None,
        service_inspection_file_path: str = None,
        start_ts: int = None,
        summarization_file_path: str = None,
        task_id: str = None,
        text_polish_file_path: str = None,
        transcription_file_path: str = None,
        vendor: int = None,
    ):
        self.auto_chapters_file_path = auto_chapters_file_path
        self.bucket = bucket
        self.channel_id = channel_id
        self.custom_prompt_file_path = custom_prompt_file_path
        self.meeting_assistance_file_path = meeting_assistance_file_path
        self.region = region
        self.service_inspection_file_path = service_inspection_file_path
        self.start_ts = start_ts
        self.summarization_file_path = summarization_file_path
        self.task_id = task_id
        self.text_polish_file_path = text_polish_file_path
        self.transcription_file_path = transcription_file_path
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_chapters_file_path is not None:
            result['AutoChaptersFilePath'] = self.auto_chapters_file_path
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.custom_prompt_file_path is not None:
            result['CustomPromptFilePath'] = self.custom_prompt_file_path
        if self.meeting_assistance_file_path is not None:
            result['MeetingAssistanceFilePath'] = self.meeting_assistance_file_path
        if self.region is not None:
            result['Region'] = self.region
        if self.service_inspection_file_path is not None:
            result['ServiceInspectionFilePath'] = self.service_inspection_file_path
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.summarization_file_path is not None:
            result['SummarizationFilePath'] = self.summarization_file_path
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.text_polish_file_path is not None:
            result['TextPolishFilePath'] = self.text_polish_file_path
        if self.transcription_file_path is not None:
            result['TranscriptionFilePath'] = self.transcription_file_path
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AutoChaptersFilePath') is not None:
            self.auto_chapters_file_path = m.get('AutoChaptersFilePath')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CustomPromptFilePath') is not None:
            self.custom_prompt_file_path = m.get('CustomPromptFilePath')
        if m.get('MeetingAssistanceFilePath') is not None:
            self.meeting_assistance_file_path = m.get('MeetingAssistanceFilePath')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ServiceInspectionFilePath') is not None:
            self.service_inspection_file_path = m.get('ServiceInspectionFilePath')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('SummarizationFilePath') is not None:
            self.summarization_file_path = m.get('SummarizationFilePath')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TextPolishFilePath') is not None:
            self.text_polish_file_path = m.get('TextPolishFilePath')
        if m.get('TranscriptionFilePath') is not None:
            self.transcription_file_path = m.get('TranscriptionFilePath')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class DescribeCloudNotesResponseBody(TeaModel):
    def __init__(
        self,
        items: List[DescribeCloudNotesResponseBodyItems] = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_cnt: int = None,
    ):
        self.items = items
        self.page_no = page_no
        self.page_size = page_size
        # Id of the request
        self.request_id = request_id
        self.total_cnt = total_cnt

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = DescribeCloudNotesResponseBodyItems()
                self.items.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribeCloudNotesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudNotesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudNotesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudRecordStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeCloudRecordStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        status: int = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCloudRecordStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeCloudRecordStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudRecordStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEndPointEventListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        user_id_list: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        # This parameter is required.
        self.user_id_list = user_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.user_id_list is not None:
            result['UserIdList'] = self.user_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('UserIdList') is not None:
            self.user_id_list = m.get('UserIdList')
        return self


class DescribeEndPointEventListResponseBodyNodesEventDataItemsEventList(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        event_type: str = None,
        ts: int = None,
        ts_in_ms: str = None,
    ):
        self.event_name = event_name
        self.event_type = event_type
        self.ts = ts
        self.ts_in_ms = ts_in_ms

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.ts is not None:
            result['Ts'] = self.ts
        if self.ts_in_ms is not None:
            result['TsInMs'] = self.ts_in_ms
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Ts') is not None:
            self.ts = m.get('Ts')
        if m.get('TsInMs') is not None:
            self.ts_in_ms = m.get('TsInMs')
        return self


class DescribeEndPointEventListResponseBodyNodesEventDataItems(TeaModel):
    def __init__(
        self,
        event_list: List[DescribeEndPointEventListResponseBodyNodesEventDataItemsEventList] = None,
        ts: int = None,
    ):
        self.event_list = event_list
        self.ts = ts

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventList'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['EventList'].append(k.to_map() if k else None)
        if self.ts is not None:
            result['Ts'] = self.ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_list = []
        if m.get('EventList') is not None:
            for k in m.get('EventList'):
                temp_model = DescribeEndPointEventListResponseBodyNodesEventDataItemsEventList()
                self.event_list.append(temp_model.from_map(k))
        if m.get('Ts') is not None:
            self.ts = m.get('Ts')
        return self


class DescribeEndPointEventListResponseBodyNodes(TeaModel):
    def __init__(
        self,
        event_data_items: List[DescribeEndPointEventListResponseBodyNodesEventDataItems] = None,
        user_id: str = None,
    ):
        self.event_data_items = event_data_items
        self.user_id = user_id

    def validate(self):
        if self.event_data_items:
            for k in self.event_data_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventDataItems'] = []
        if self.event_data_items is not None:
            for k in self.event_data_items:
                result['EventDataItems'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_data_items = []
        if m.get('EventDataItems') is not None:
            for k in m.get('EventDataItems'):
                temp_model = DescribeEndPointEventListResponseBodyNodesEventDataItems()
                self.event_data_items.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeEndPointEventListResponseBody(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeEndPointEventListResponseBodyNodes] = None,
        request_id: str = None,
    ):
        self.nodes = nodes
        self.request_id = request_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeEndPointEventListResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEndPointEventListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEndPointEventListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEndPointEventListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEndPointMetricDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        metrics: str = None,
        pub_call_id_list: str = None,
        pub_user_id: str = None,
        sub_user_id: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        # This parameter is required.
        self.metrics = metrics
        self.pub_call_id_list = pub_call_id_list
        self.pub_user_id = pub_user_id
        self.sub_user_id = sub_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.metrics is not None:
            result['Metrics'] = self.metrics
        if self.pub_call_id_list is not None:
            result['PubCallIdList'] = self.pub_call_id_list
        if self.pub_user_id is not None:
            result['PubUserId'] = self.pub_user_id
        if self.sub_user_id is not None:
            result['SubUserId'] = self.sub_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Metrics') is not None:
            self.metrics = m.get('Metrics')
        if m.get('PubCallIdList') is not None:
            self.pub_call_id_list = m.get('PubCallIdList')
        if m.get('PubUserId') is not None:
            self.pub_user_id = m.get('PubUserId')
        if m.get('SubUserId') is not None:
            self.sub_user_id = m.get('SubUserId')
        return self


class DescribeEndPointMetricDataResponseBodyPubMetricsNodes(TeaModel):
    def __init__(
        self,
        ext: Dict[str, Any] = None,
        x: str = None,
        y: str = None,
    ):
        self.ext = ext
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeEndPointMetricDataResponseBodyPubMetrics(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeEndPointMetricDataResponseBodyPubMetricsNodes] = None,
        type: str = None,
        user_id: str = None,
    ):
        self.nodes = nodes
        self.type = type
        self.user_id = user_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeEndPointMetricDataResponseBodyPubMetricsNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeEndPointMetricDataResponseBodySubMetricsNodes(TeaModel):
    def __init__(
        self,
        ext: Dict[str, Any] = None,
        x: str = None,
        y: str = None,
    ):
        self.ext = ext
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeEndPointMetricDataResponseBodySubMetrics(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeEndPointMetricDataResponseBodySubMetricsNodes] = None,
        type: str = None,
        user_id: str = None,
    ):
        self.nodes = nodes
        self.type = type
        self.user_id = user_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeEndPointMetricDataResponseBodySubMetricsNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeEndPointMetricDataResponseBody(TeaModel):
    def __init__(
        self,
        pub_metrics: List[DescribeEndPointMetricDataResponseBodyPubMetrics] = None,
        request_id: str = None,
        sub_metrics: List[DescribeEndPointMetricDataResponseBodySubMetrics] = None,
    ):
        self.pub_metrics = pub_metrics
        self.request_id = request_id
        self.sub_metrics = sub_metrics

    def validate(self):
        if self.pub_metrics:
            for k in self.pub_metrics:
                if k:
                    k.validate()
        if self.sub_metrics:
            for k in self.sub_metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PubMetrics'] = []
        if self.pub_metrics is not None:
            for k in self.pub_metrics:
                result['PubMetrics'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SubMetrics'] = []
        if self.sub_metrics is not None:
            for k in self.sub_metrics:
                result['SubMetrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.pub_metrics = []
        if m.get('PubMetrics') is not None:
            for k in m.get('PubMetrics'):
                temp_model = DescribeEndPointMetricDataResponseBodyPubMetrics()
                self.pub_metrics.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sub_metrics = []
        if m.get('SubMetrics') is not None:
            for k in m.get('SubMetrics'):
                temp_model = DescribeEndPointMetricDataResponseBodySubMetrics()
                self.sub_metrics.append(temp_model.from_map(k))
        return self


class DescribeEndPointMetricDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeEndPointMetricDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEndPointMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFaultDiagnosisFactorDistributionStatRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_ts: int = None,
        start_ts: int = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_ts = end_ts
        # This parameter is required.
        self.start_ts = start_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeFaultDiagnosisFactorDistributionStatResponseBodyStatList(TeaModel):
    def __init__(
        self,
        factor_id: str = None,
        user_count: int = None,
        user_ratio: float = None,
    ):
        self.factor_id = factor_id
        self.user_count = user_count
        self.user_ratio = user_ratio

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.factor_id is not None:
            result['FactorId'] = self.factor_id
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        if self.user_ratio is not None:
            result['UserRatio'] = self.user_ratio
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FactorId') is not None:
            self.factor_id = m.get('FactorId')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        if m.get('UserRatio') is not None:
            self.user_ratio = m.get('UserRatio')
        return self


class DescribeFaultDiagnosisFactorDistributionStatResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        stat_list: List[DescribeFaultDiagnosisFactorDistributionStatResponseBodyStatList] = None,
    ):
        self.request_id = request_id
        self.stat_list = stat_list

    def validate(self):
        if self.stat_list:
            for k in self.stat_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['StatList'] = []
        if self.stat_list is not None:
            for k in self.stat_list:
                result['StatList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.stat_list = []
        if m.get('StatList') is not None:
            for k in m.get('StatList'):
                temp_model = DescribeFaultDiagnosisFactorDistributionStatResponseBodyStatList()
                self.stat_list.append(temp_model.from_map(k))
        return self


class DescribeFaultDiagnosisFactorDistributionStatResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFaultDiagnosisFactorDistributionStatResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFaultDiagnosisFactorDistributionStatResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFaultDiagnosisOverallDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_ts: int = None,
        start_ts: int = None,
        stat_dim: str = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_ts = end_ts
        # This parameter is required.
        self.start_ts = start_ts
        # This parameter is required.
        self.stat_dim = stat_dim

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.stat_dim is not None:
            result['StatDim'] = self.stat_dim
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('StatDim') is not None:
            self.stat_dim = m.get('StatDim')
        return self


class DescribeFaultDiagnosisOverallDataResponseBodyMetricDataNodes(TeaModel):
    def __init__(
        self,
        ext: Dict[str, Any] = None,
        x: str = None,
        y: str = None,
    ):
        self.ext = ext
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeFaultDiagnosisOverallDataResponseBodyMetricData(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeFaultDiagnosisOverallDataResponseBodyMetricDataNodes] = None,
    ):
        self.nodes = nodes

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeFaultDiagnosisOverallDataResponseBodyMetricDataNodes()
                self.nodes.append(temp_model.from_map(k))
        return self


class DescribeFaultDiagnosisOverallDataResponseBodyOverallData(TeaModel):
    def __init__(
        self,
        fault_user_count: int = None,
        fault_user_ratio: float = None,
        total_user_count: int = None,
    ):
        self.fault_user_count = fault_user_count
        self.fault_user_ratio = fault_user_ratio
        self.total_user_count = total_user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fault_user_count is not None:
            result['FaultUserCount'] = self.fault_user_count
        if self.fault_user_ratio is not None:
            result['FaultUserRatio'] = self.fault_user_ratio
        if self.total_user_count is not None:
            result['TotalUserCount'] = self.total_user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FaultUserCount') is not None:
            self.fault_user_count = m.get('FaultUserCount')
        if m.get('FaultUserRatio') is not None:
            self.fault_user_ratio = m.get('FaultUserRatio')
        if m.get('TotalUserCount') is not None:
            self.total_user_count = m.get('TotalUserCount')
        return self


class DescribeFaultDiagnosisOverallDataResponseBody(TeaModel):
    def __init__(
        self,
        metric_data: DescribeFaultDiagnosisOverallDataResponseBodyMetricData = None,
        overall_data: DescribeFaultDiagnosisOverallDataResponseBodyOverallData = None,
        request_id: str = None,
    ):
        self.metric_data = metric_data
        self.overall_data = overall_data
        self.request_id = request_id

    def validate(self):
        if self.metric_data:
            self.metric_data.validate()
        if self.overall_data:
            self.overall_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_data is not None:
            result['MetricData'] = self.metric_data.to_map()
        if self.overall_data is not None:
            result['OverallData'] = self.overall_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MetricData') is not None:
            temp_model = DescribeFaultDiagnosisOverallDataResponseBodyMetricData()
            self.metric_data = temp_model.from_map(m['MetricData'])
        if m.get('OverallData') is not None:
            temp_model = DescribeFaultDiagnosisOverallDataResponseBodyOverallData()
            self.overall_data = temp_model.from_map(m['OverallData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFaultDiagnosisOverallDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFaultDiagnosisOverallDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFaultDiagnosisOverallDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFaultDiagnosisUserDetailRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        fault_type: str = None,
        query_call_user_info: bool = None,
        user_id: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        # This parameter is required.
        self.fault_type = fault_type
        self.query_call_user_info = query_call_user_info
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.fault_type is not None:
            result['FaultType'] = self.fault_type
        if self.query_call_user_info is not None:
            result['QueryCallUserInfo'] = self.query_call_user_info
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('FaultType') is not None:
            self.fault_type = m.get('FaultType')
        if m.get('QueryCallUserInfo') is not None:
            self.query_call_user_info = m.get('QueryCallUserInfo')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyCallInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        call_status: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
    ):
        # App ID。
        self.app_id = app_id
        self.call_status = call_status
        self.channel_id = channel_id
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.call_status is not None:
            result['CallStatus'] = self.call_status
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallStatus') is not None:
            self.call_status = m.get('CallStatus')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatasEventDataItemsEventList(TeaModel):
    def __init__(
        self,
        event_name: str = None,
        event_type: str = None,
        ts: int = None,
    ):
        self.event_name = event_name
        self.event_type = event_type
        self.ts = ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.ts is not None:
            result['Ts'] = self.ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Ts') is not None:
            self.ts = m.get('Ts')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatasEventDataItems(TeaModel):
    def __init__(
        self,
        event_list: List[DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatasEventDataItemsEventList] = None,
        ts: int = None,
    ):
        self.event_list = event_list
        self.ts = ts

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventList'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['EventList'].append(k.to_map() if k else None)
        if self.ts is not None:
            result['Ts'] = self.ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_list = []
        if m.get('EventList') is not None:
            for k in m.get('EventList'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatasEventDataItemsEventList()
                self.event_list.append(temp_model.from_map(k))
        if m.get('Ts') is not None:
            self.ts = m.get('Ts')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatas(TeaModel):
    def __init__(
        self,
        event_data_items: List[DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatasEventDataItems] = None,
        role: str = None,
        user_id: str = None,
    ):
        self.event_data_items = event_data_items
        self.role = role
        self.user_id = user_id

    def validate(self):
        if self.event_data_items:
            for k in self.event_data_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventDataItems'] = []
        if self.event_data_items is not None:
            for k in self.event_data_items:
                result['EventDataItems'].append(k.to_map() if k else None)
        if self.role is not None:
            result['Role'] = self.role
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_data_items = []
        if m.get('EventDataItems') is not None:
            for k in m.get('EventDataItems'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatasEventDataItems()
                self.event_data_items.append(temp_model.from_map(k))
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedMetricDatasNodes(TeaModel):
    def __init__(
        self,
        ext: Dict[str, Any] = None,
        x: str = None,
        y: str = None,
    ):
        self.ext = ext
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ext is not None:
            result['Ext'] = self.ext
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ext') is not None:
            self.ext = m.get('Ext')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedMetricDatas(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedMetricDatasNodes] = None,
        role: str = None,
        type: str = None,
        user_id: str = None,
    ):
        self.nodes = nodes
        self.role = role
        self.type = type
        self.user_id = user_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.role is not None:
            result['Role'] = self.role
        if self.type is not None:
            result['Type'] = self.type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedMetricDatasNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFactorList(TeaModel):
    def __init__(
        self,
        factor_id: str = None,
        fault_source: str = None,
        related_event_datas: List[DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatas] = None,
        related_metric_datas: List[DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedMetricDatas] = None,
    ):
        self.factor_id = factor_id
        self.fault_source = fault_source
        self.related_event_datas = related_event_datas
        self.related_metric_datas = related_metric_datas

    def validate(self):
        if self.related_event_datas:
            for k in self.related_event_datas:
                if k:
                    k.validate()
        if self.related_metric_datas:
            for k in self.related_metric_datas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.factor_id is not None:
            result['FactorId'] = self.factor_id
        if self.fault_source is not None:
            result['FaultSource'] = self.fault_source
        result['RelatedEventDatas'] = []
        if self.related_event_datas is not None:
            for k in self.related_event_datas:
                result['RelatedEventDatas'].append(k.to_map() if k else None)
        result['RelatedMetricDatas'] = []
        if self.related_metric_datas is not None:
            for k in self.related_metric_datas:
                result['RelatedMetricDatas'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FactorId') is not None:
            self.factor_id = m.get('FactorId')
        if m.get('FaultSource') is not None:
            self.fault_source = m.get('FaultSource')
        self.related_event_datas = []
        if m.get('RelatedEventDatas') is not None:
            for k in m.get('RelatedEventDatas'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedEventDatas()
                self.related_event_datas.append(temp_model.from_map(k))
        self.related_metric_datas = []
        if m.get('RelatedMetricDatas') is not None:
            for k in m.get('RelatedMetricDatas'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFactorListRelatedMetricDatas()
                self.related_metric_datas.append(temp_model.from_map(k))
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFaultMetricDataNodes(TeaModel):
    def __init__(
        self,
        x: str = None,
        y: str = None,
    ):
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyFaultMetricData(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeFaultDiagnosisUserDetailResponseBodyFaultMetricDataNodes] = None,
    ):
        self.nodes = nodes

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFaultMetricDataNodes()
                self.nodes.append(temp_model.from_map(k))
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyUserDetailOnlinePeriods(TeaModel):
    def __init__(
        self,
        join_ts: int = None,
        leave_ts: int = None,
    ):
        self.join_ts = join_ts
        self.leave_ts = leave_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_ts is not None:
            result['JoinTs'] = self.join_ts
        if self.leave_ts is not None:
            result['LeaveTs'] = self.leave_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTs') is not None:
            self.join_ts = m.get('JoinTs')
        if m.get('LeaveTs') is not None:
            self.leave_ts = m.get('LeaveTs')
        return self


class DescribeFaultDiagnosisUserDetailResponseBodyUserDetail(TeaModel):
    def __init__(
        self,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
        location: str = None,
        network: str = None,
        online_duration: int = None,
        online_periods: List[DescribeFaultDiagnosisUserDetailResponseBodyUserDetailOnlinePeriods] = None,
        os: str = None,
        sdk_version: str = None,
        user_id: str = None,
    ):
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration
        self.location = location
        self.network = network
        self.online_duration = online_duration
        self.online_periods = online_periods
        self.os = os
        self.sdk_version = sdk_version
        self.user_id = user_id

    def validate(self):
        if self.online_periods:
            for k in self.online_periods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.location is not None:
            result['Location'] = self.location
        if self.network is not None:
            result['Network'] = self.network
        if self.online_duration is not None:
            result['OnlineDuration'] = self.online_duration
        result['OnlinePeriods'] = []
        if self.online_periods is not None:
            for k in self.online_periods:
                result['OnlinePeriods'].append(k.to_map() if k else None)
        if self.os is not None:
            result['Os'] = self.os
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('OnlineDuration') is not None:
            self.online_duration = m.get('OnlineDuration')
        self.online_periods = []
        if m.get('OnlinePeriods') is not None:
            for k in m.get('OnlinePeriods'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyUserDetailOnlinePeriods()
                self.online_periods.append(temp_model.from_map(k))
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeFaultDiagnosisUserDetailResponseBody(TeaModel):
    def __init__(
        self,
        call_info: DescribeFaultDiagnosisUserDetailResponseBodyCallInfo = None,
        factor_list: List[DescribeFaultDiagnosisUserDetailResponseBodyFactorList] = None,
        fault_metric_data: DescribeFaultDiagnosisUserDetailResponseBodyFaultMetricData = None,
        network_operators: List[str] = None,
        request_id: str = None,
        user_detail: DescribeFaultDiagnosisUserDetailResponseBodyUserDetail = None,
    ):
        self.call_info = call_info
        self.factor_list = factor_list
        self.fault_metric_data = fault_metric_data
        self.network_operators = network_operators
        self.request_id = request_id
        self.user_detail = user_detail

    def validate(self):
        if self.call_info:
            self.call_info.validate()
        if self.factor_list:
            for k in self.factor_list:
                if k:
                    k.validate()
        if self.fault_metric_data:
            self.fault_metric_data.validate()
        if self.user_detail:
            self.user_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_info is not None:
            result['CallInfo'] = self.call_info.to_map()
        result['FactorList'] = []
        if self.factor_list is not None:
            for k in self.factor_list:
                result['FactorList'].append(k.to_map() if k else None)
        if self.fault_metric_data is not None:
            result['FaultMetricData'] = self.fault_metric_data.to_map()
        if self.network_operators is not None:
            result['NetworkOperators'] = self.network_operators
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_detail is not None:
            result['UserDetail'] = self.user_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallInfo') is not None:
            temp_model = DescribeFaultDiagnosisUserDetailResponseBodyCallInfo()
            self.call_info = temp_model.from_map(m['CallInfo'])
        self.factor_list = []
        if m.get('FactorList') is not None:
            for k in m.get('FactorList'):
                temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFactorList()
                self.factor_list.append(temp_model.from_map(k))
        if m.get('FaultMetricData') is not None:
            temp_model = DescribeFaultDiagnosisUserDetailResponseBodyFaultMetricData()
            self.fault_metric_data = temp_model.from_map(m['FaultMetricData'])
        if m.get('NetworkOperators') is not None:
            self.network_operators = m.get('NetworkOperators')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserDetail') is not None:
            temp_model = DescribeFaultDiagnosisUserDetailResponseBodyUserDetail()
            self.user_detail = temp_model.from_map(m['UserDetail'])
        return self


class DescribeFaultDiagnosisUserDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFaultDiagnosisUserDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFaultDiagnosisUserDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFaultDiagnosisUserListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        end_ts: int = None,
        fault_types: str = None,
        page_no: int = None,
        page_size: int = None,
        start_ts: int = None,
        user_id: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        self.channel_id = channel_id
        # This parameter is required.
        self.end_ts = end_ts
        self.fault_types = fault_types
        # This parameter is required.
        self.page_no = page_no
        # This parameter is required.
        self.page_size = page_size
        # This parameter is required.
        self.start_ts = start_ts
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.fault_types is not None:
            result['FaultTypes'] = self.fault_types
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('FaultTypes') is not None:
            self.fault_types = m.get('FaultTypes')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeFaultDiagnosisUserListResponseBodyUserListFaultList(TeaModel):
    def __init__(
        self,
        fault_type: str = None,
    ):
        self.fault_type = fault_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fault_type is not None:
            result['FaultType'] = self.fault_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FaultType') is not None:
            self.fault_type = m.get('FaultType')
        return self


class DescribeFaultDiagnosisUserListResponseBodyUserList(TeaModel):
    def __init__(
        self,
        channel_created_ts: int = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        fault_list: List[DescribeFaultDiagnosisUserListResponseBodyUserListFaultList] = None,
        user_id: str = None,
    ):
        self.channel_created_ts = channel_created_ts
        self.channel_id = channel_id
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.fault_list = fault_list
        self.user_id = user_id

    def validate(self):
        if self.fault_list:
            for k in self.fault_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_created_ts is not None:
            result['ChannelCreatedTs'] = self.channel_created_ts
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        result['FaultList'] = []
        if self.fault_list is not None:
            for k in self.fault_list:
                result['FaultList'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelCreatedTs') is not None:
            self.channel_created_ts = m.get('ChannelCreatedTs')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        self.fault_list = []
        if m.get('FaultList') is not None:
            for k in m.get('FaultList'):
                temp_model = DescribeFaultDiagnosisUserListResponseBodyUserListFaultList()
                self.fault_list.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeFaultDiagnosisUserListResponseBody(TeaModel):
    def __init__(
        self,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_cnt: int = None,
        user_list: List[DescribeFaultDiagnosisUserListResponseBodyUserList] = None,
    ):
        self.page_no = page_no
        self.page_size = page_size
        self.request_id = request_id
        self.total_cnt = total_cnt
        self.user_list = user_list

    def validate(self):
        if self.user_list:
            for k in self.user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        result['UserList'] = []
        if self.user_list is not None:
            for k in self.user_list:
                result['UserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        self.user_list = []
        if m.get('UserList') is not None:
            for k in m.get('UserList'):
                temp_model = DescribeFaultDiagnosisUserListResponseBodyUserList()
                self.user_list.append(temp_model.from_map(k))
        return self


class DescribeFaultDiagnosisUserListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeFaultDiagnosisUserListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFaultDiagnosisUserListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMPULayoutInfoListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        layout_id: int = None,
        name: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.layout_id = layout_id
        self.name = name
        self.owner_id = owner_id
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeMPULayoutInfoListResponseBodyLayoutsLayoutPanesPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        major_pane: int = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        self.major_pane = major_pane
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.major_pane is not None:
            result['MajorPane'] = self.major_pane
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MajorPane') is not None:
            self.major_pane = m.get('MajorPane')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class DescribeMPULayoutInfoListResponseBodyLayoutsLayoutPanes(TeaModel):
    def __init__(
        self,
        panes: List[DescribeMPULayoutInfoListResponseBodyLayoutsLayoutPanesPanes] = None,
    ):
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = DescribeMPULayoutInfoListResponseBodyLayoutsLayoutPanesPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class DescribeMPULayoutInfoListResponseBodyLayoutsLayout(TeaModel):
    def __init__(
        self,
        audio_mix_count: int = None,
        layout_id: int = None,
        name: str = None,
        panes: DescribeMPULayoutInfoListResponseBodyLayoutsLayoutPanes = None,
    ):
        self.audio_mix_count = audio_mix_count
        self.layout_id = layout_id
        self.name = name
        self.panes = panes

    def validate(self):
        if self.panes:
            self.panes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_mix_count is not None:
            result['AudioMixCount'] = self.audio_mix_count
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        if self.panes is not None:
            result['Panes'] = self.panes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioMixCount') is not None:
            self.audio_mix_count = m.get('AudioMixCount')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Panes') is not None:
            temp_model = DescribeMPULayoutInfoListResponseBodyLayoutsLayoutPanes()
            self.panes = temp_model.from_map(m['Panes'])
        return self


class DescribeMPULayoutInfoListResponseBodyLayouts(TeaModel):
    def __init__(
        self,
        layout: List[DescribeMPULayoutInfoListResponseBodyLayoutsLayout] = None,
    ):
        self.layout = layout

    def validate(self):
        if self.layout:
            for k in self.layout:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Layout'] = []
        if self.layout is not None:
            for k in self.layout:
                result['Layout'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.layout = []
        if m.get('Layout') is not None:
            for k in m.get('Layout'):
                temp_model = DescribeMPULayoutInfoListResponseBodyLayoutsLayout()
                self.layout.append(temp_model.from_map(k))
        return self


class DescribeMPULayoutInfoListResponseBody(TeaModel):
    def __init__(
        self,
        layouts: DescribeMPULayoutInfoListResponseBodyLayouts = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.layouts = layouts
        self.request_id = request_id
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.layouts:
            self.layouts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layouts is not None:
            result['Layouts'] = self.layouts.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Layouts') is not None:
            temp_model = DescribeMPULayoutInfoListResponseBodyLayouts()
            self.layouts = temp_model.from_map(m['Layouts'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeMPULayoutInfoListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeMPULayoutInfoListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMPULayoutInfoListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePubUserListBySubUserRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        sub_user_id: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        # This parameter is required.
        self.sub_user_id = sub_user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.sub_user_id is not None:
            result['SubUserId'] = self.sub_user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('SubUserId') is not None:
            self.sub_user_id = m.get('SubUserId')
        return self


class DescribePubUserListBySubUserResponseBodyPubUserDetailListOnlinePeriods(TeaModel):
    def __init__(
        self,
        join_ts: int = None,
        leave_ts: int = None,
    ):
        self.join_ts = join_ts
        self.leave_ts = leave_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_ts is not None:
            result['JoinTs'] = self.join_ts
        if self.leave_ts is not None:
            result['LeaveTs'] = self.leave_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTs') is not None:
            self.join_ts = m.get('JoinTs')
        if m.get('LeaveTs') is not None:
            self.leave_ts = m.get('LeaveTs')
        return self


class DescribePubUserListBySubUserResponseBodyPubUserDetailList(TeaModel):
    def __init__(
        self,
        call_id_list: List[str] = None,
        client_type: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
        location: str = None,
        network: str = None,
        network_list: List[str] = None,
        online_duration: int = None,
        online_periods: List[DescribePubUserListBySubUserResponseBodyPubUserDetailListOnlinePeriods] = None,
        os: str = None,
        os_list: List[str] = None,
        roles: List[str] = None,
        sdk_version: str = None,
        sdk_version_list: List[str] = None,
        user_id: str = None,
        user_id_alias: str = None,
    ):
        self.call_id_list = call_id_list
        self.client_type = client_type
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration
        self.location = location
        self.network = network
        self.network_list = network_list
        self.online_duration = online_duration
        self.online_periods = online_periods
        self.os = os
        self.os_list = os_list
        self.roles = roles
        self.sdk_version = sdk_version
        self.sdk_version_list = sdk_version_list
        self.user_id = user_id
        self.user_id_alias = user_id_alias

    def validate(self):
        if self.online_periods:
            for k in self.online_periods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_id_list is not None:
            result['CallIdList'] = self.call_id_list
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.location is not None:
            result['Location'] = self.location
        if self.network is not None:
            result['Network'] = self.network
        if self.network_list is not None:
            result['NetworkList'] = self.network_list
        if self.online_duration is not None:
            result['OnlineDuration'] = self.online_duration
        result['OnlinePeriods'] = []
        if self.online_periods is not None:
            for k in self.online_periods:
                result['OnlinePeriods'].append(k.to_map() if k else None)
        if self.os is not None:
            result['Os'] = self.os
        if self.os_list is not None:
            result['OsList'] = self.os_list
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.sdk_version_list is not None:
            result['SdkVersionList'] = self.sdk_version_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_id_alias is not None:
            result['UserIdAlias'] = self.user_id_alias
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallIdList') is not None:
            self.call_id_list = m.get('CallIdList')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('NetworkList') is not None:
            self.network_list = m.get('NetworkList')
        if m.get('OnlineDuration') is not None:
            self.online_duration = m.get('OnlineDuration')
        self.online_periods = []
        if m.get('OnlinePeriods') is not None:
            for k in m.get('OnlinePeriods'):
                temp_model = DescribePubUserListBySubUserResponseBodyPubUserDetailListOnlinePeriods()
                self.online_periods.append(temp_model.from_map(k))
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsList') is not None:
            self.os_list = m.get('OsList')
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('SdkVersionList') is not None:
            self.sdk_version_list = m.get('SdkVersionList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserIdAlias') is not None:
            self.user_id_alias = m.get('UserIdAlias')
        return self


class DescribePubUserListBySubUserResponseBodySubUserDetailOnlinePeriods(TeaModel):
    def __init__(
        self,
        join_ts: int = None,
        leave_ts: int = None,
    ):
        self.join_ts = join_ts
        self.leave_ts = leave_ts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join_ts is not None:
            result['JoinTs'] = self.join_ts
        if self.leave_ts is not None:
            result['LeaveTs'] = self.leave_ts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JoinTs') is not None:
            self.join_ts = m.get('JoinTs')
        if m.get('LeaveTs') is not None:
            self.leave_ts = m.get('LeaveTs')
        return self


class DescribePubUserListBySubUserResponseBodySubUserDetail(TeaModel):
    def __init__(
        self,
        client_type: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        duration: int = None,
        location: str = None,
        network: str = None,
        network_list: List[str] = None,
        online_duration: int = None,
        online_periods: List[DescribePubUserListBySubUserResponseBodySubUserDetailOnlinePeriods] = None,
        os: str = None,
        os_list: List[str] = None,
        roles: List[str] = None,
        sdk_version: str = None,
        sdk_version_list: List[str] = None,
        user_id: str = None,
        user_id_alias: str = None,
    ):
        self.client_type = client_type
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        self.duration = duration
        self.location = location
        self.network = network
        self.network_list = network_list
        self.online_duration = online_duration
        self.online_periods = online_periods
        self.os = os
        self.os_list = os_list
        self.roles = roles
        self.sdk_version = sdk_version
        self.sdk_version_list = sdk_version_list
        self.user_id = user_id
        self.user_id_alias = user_id_alias

    def validate(self):
        if self.online_periods:
            for k in self.online_periods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.location is not None:
            result['Location'] = self.location
        if self.network is not None:
            result['Network'] = self.network
        if self.network_list is not None:
            result['NetworkList'] = self.network_list
        if self.online_duration is not None:
            result['OnlineDuration'] = self.online_duration
        result['OnlinePeriods'] = []
        if self.online_periods is not None:
            for k in self.online_periods:
                result['OnlinePeriods'].append(k.to_map() if k else None)
        if self.os is not None:
            result['Os'] = self.os
        if self.os_list is not None:
            result['OsList'] = self.os_list
        if self.roles is not None:
            result['Roles'] = self.roles
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.sdk_version_list is not None:
            result['SdkVersionList'] = self.sdk_version_list
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_id_alias is not None:
            result['UserIdAlias'] = self.user_id_alias
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('NetworkList') is not None:
            self.network_list = m.get('NetworkList')
        if m.get('OnlineDuration') is not None:
            self.online_duration = m.get('OnlineDuration')
        self.online_periods = []
        if m.get('OnlinePeriods') is not None:
            for k in m.get('OnlinePeriods'):
                temp_model = DescribePubUserListBySubUserResponseBodySubUserDetailOnlinePeriods()
                self.online_periods.append(temp_model.from_map(k))
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('OsList') is not None:
            self.os_list = m.get('OsList')
        if m.get('Roles') is not None:
            self.roles = m.get('Roles')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('SdkVersionList') is not None:
            self.sdk_version_list = m.get('SdkVersionList')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserIdAlias') is not None:
            self.user_id_alias = m.get('UserIdAlias')
        return self


class DescribePubUserListBySubUserResponseBody(TeaModel):
    def __init__(
        self,
        call_status: str = None,
        pub_user_detail_list: List[DescribePubUserListBySubUserResponseBodyPubUserDetailList] = None,
        request_id: str = None,
        sub_user_detail: DescribePubUserListBySubUserResponseBodySubUserDetail = None,
    ):
        self.call_status = call_status
        self.pub_user_detail_list = pub_user_detail_list
        self.request_id = request_id
        self.sub_user_detail = sub_user_detail

    def validate(self):
        if self.pub_user_detail_list:
            for k in self.pub_user_detail_list:
                if k:
                    k.validate()
        if self.sub_user_detail:
            self.sub_user_detail.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_status is not None:
            result['CallStatus'] = self.call_status
        result['PubUserDetailList'] = []
        if self.pub_user_detail_list is not None:
            for k in self.pub_user_detail_list:
                result['PubUserDetailList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_user_detail is not None:
            result['SubUserDetail'] = self.sub_user_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallStatus') is not None:
            self.call_status = m.get('CallStatus')
        self.pub_user_detail_list = []
        if m.get('PubUserDetailList') is not None:
            for k in m.get('PubUserDetailList'):
                temp_model = DescribePubUserListBySubUserResponseBodyPubUserDetailList()
                self.pub_user_detail_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubUserDetail') is not None:
            temp_model = DescribePubUserListBySubUserResponseBodySubUserDetail()
            self.sub_user_detail = temp_model.from_map(m['SubUserDetail'])
        return self


class DescribePubUserListBySubUserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribePubUserListBySubUserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePubUserListBySubUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQoeMetricDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        created_ts: int = None,
        destroyed_ts: int = None,
        user_id: str = None,
    ):
        # APP ID。
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.created_ts = created_ts
        self.destroyed_ts = destroyed_ts
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.created_ts is not None:
            result['CreatedTs'] = self.created_ts
        if self.destroyed_ts is not None:
            result['DestroyedTs'] = self.destroyed_ts
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreatedTs') is not None:
            self.created_ts = m.get('CreatedTs')
        if m.get('DestroyedTs') is not None:
            self.destroyed_ts = m.get('DestroyedTs')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeQoeMetricDataResponseBodyAudioDataNodes(TeaModel):
    def __init__(
        self,
        x: str = None,
        y: str = None,
    ):
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeQoeMetricDataResponseBodyAudioData(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeQoeMetricDataResponseBodyAudioDataNodes] = None,
        type: str = None,
        user_id: str = None,
    ):
        self.nodes = nodes
        self.type = type
        self.user_id = user_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeQoeMetricDataResponseBodyAudioDataNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeQoeMetricDataResponseBodyVideoDataNodes(TeaModel):
    def __init__(
        self,
        x: str = None,
        y: str = None,
    ):
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeQoeMetricDataResponseBodyVideoData(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeQoeMetricDataResponseBodyVideoDataNodes] = None,
        type: str = None,
        user_id: str = None,
    ):
        self.nodes = nodes
        self.type = type
        self.user_id = user_id

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeQoeMetricDataResponseBodyVideoDataNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeQoeMetricDataResponseBody(TeaModel):
    def __init__(
        self,
        audio_data: List[DescribeQoeMetricDataResponseBodyAudioData] = None,
        request_id: str = None,
        video_data: List[DescribeQoeMetricDataResponseBodyVideoData] = None,
    ):
        self.audio_data = audio_data
        self.request_id = request_id
        self.video_data = video_data

    def validate(self):
        if self.audio_data:
            for k in self.audio_data:
                if k:
                    k.validate()
        if self.video_data:
            for k in self.video_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioData'] = []
        if self.audio_data is not None:
            for k in self.audio_data:
                result['AudioData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VideoData'] = []
        if self.video_data is not None:
            for k in self.video_data:
                result['VideoData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.audio_data = []
        if m.get('AudioData') is not None:
            for k in m.get('AudioData'):
                temp_model = DescribeQoeMetricDataResponseBodyAudioData()
                self.audio_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.video_data = []
        if m.get('VideoData') is not None:
            for k in m.get('VideoData'):
                temp_model = DescribeQoeMetricDataResponseBodyVideoData()
                self.video_data.append(temp_model.from_map(k))
        return self


class DescribeQoeMetricDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQoeMetricDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQoeMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQualityAreaDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        parent_area: str = None,
        start_date: int = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        self.parent_area = parent_area
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.parent_area is not None:
            result['ParentArea'] = self.parent_area
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('ParentArea') is not None:
            self.parent_area = m.get('ParentArea')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeQualityAreaDistributionStatDataResponseBodyQualityStatDataList(TeaModel):
    def __init__(
        self,
        audio_delay: int = None,
        audio_high_quality_transmission_rate: str = None,
        audio_stuck_rate: str = None,
        call_duration_ratio: str = None,
        join_channel_suc_five_sec_rate: str = None,
        join_channel_suc_rate: str = None,
        name: str = None,
        video_delay: int = None,
        video_first_pic_duration: int = None,
        video_high_quality_transmission_rate: str = None,
        video_stuck_rate: str = None,
    ):
        self.audio_delay = audio_delay
        self.audio_high_quality_transmission_rate = audio_high_quality_transmission_rate
        self.audio_stuck_rate = audio_stuck_rate
        self.call_duration_ratio = call_duration_ratio
        self.join_channel_suc_five_sec_rate = join_channel_suc_five_sec_rate
        self.join_channel_suc_rate = join_channel_suc_rate
        self.name = name
        self.video_delay = video_delay
        self.video_first_pic_duration = video_first_pic_duration
        self.video_high_quality_transmission_rate = video_high_quality_transmission_rate
        self.video_stuck_rate = video_stuck_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_delay is not None:
            result['AudioDelay'] = self.audio_delay
        if self.audio_high_quality_transmission_rate is not None:
            result['AudioHighQualityTransmissionRate'] = self.audio_high_quality_transmission_rate
        if self.audio_stuck_rate is not None:
            result['AudioStuckRate'] = self.audio_stuck_rate
        if self.call_duration_ratio is not None:
            result['CallDurationRatio'] = self.call_duration_ratio
        if self.join_channel_suc_five_sec_rate is not None:
            result['JoinChannelSucFiveSecRate'] = self.join_channel_suc_five_sec_rate
        if self.join_channel_suc_rate is not None:
            result['JoinChannelSucRate'] = self.join_channel_suc_rate
        if self.name is not None:
            result['Name'] = self.name
        if self.video_delay is not None:
            result['VideoDelay'] = self.video_delay
        if self.video_first_pic_duration is not None:
            result['VideoFirstPicDuration'] = self.video_first_pic_duration
        if self.video_high_quality_transmission_rate is not None:
            result['VideoHighQualityTransmissionRate'] = self.video_high_quality_transmission_rate
        if self.video_stuck_rate is not None:
            result['VideoStuckRate'] = self.video_stuck_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioDelay') is not None:
            self.audio_delay = m.get('AudioDelay')
        if m.get('AudioHighQualityTransmissionRate') is not None:
            self.audio_high_quality_transmission_rate = m.get('AudioHighQualityTransmissionRate')
        if m.get('AudioStuckRate') is not None:
            self.audio_stuck_rate = m.get('AudioStuckRate')
        if m.get('CallDurationRatio') is not None:
            self.call_duration_ratio = m.get('CallDurationRatio')
        if m.get('JoinChannelSucFiveSecRate') is not None:
            self.join_channel_suc_five_sec_rate = m.get('JoinChannelSucFiveSecRate')
        if m.get('JoinChannelSucRate') is not None:
            self.join_channel_suc_rate = m.get('JoinChannelSucRate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoDelay') is not None:
            self.video_delay = m.get('VideoDelay')
        if m.get('VideoFirstPicDuration') is not None:
            self.video_first_pic_duration = m.get('VideoFirstPicDuration')
        if m.get('VideoHighQualityTransmissionRate') is not None:
            self.video_high_quality_transmission_rate = m.get('VideoHighQualityTransmissionRate')
        if m.get('VideoStuckRate') is not None:
            self.video_stuck_rate = m.get('VideoStuckRate')
        return self


class DescribeQualityAreaDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        quality_stat_data_list: List[DescribeQualityAreaDistributionStatDataResponseBodyQualityStatDataList] = None,
        request_id: str = None,
    ):
        self.quality_stat_data_list = quality_stat_data_list
        self.request_id = request_id

    def validate(self):
        if self.quality_stat_data_list:
            for k in self.quality_stat_data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['QualityStatDataList'] = []
        if self.quality_stat_data_list is not None:
            for k in self.quality_stat_data_list:
                result['QualityStatDataList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.quality_stat_data_list = []
        if m.get('QualityStatDataList') is not None:
            for k in m.get('QualityStatDataList'):
                temp_model = DescribeQualityAreaDistributionStatDataResponseBodyQualityStatDataList()
                self.quality_stat_data_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeQualityAreaDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQualityAreaDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQualityAreaDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQualityDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        start_date: int = None,
        stat_dim: str = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        # This parameter is required.
        self.start_date = start_date
        # This parameter is required.
        self.stat_dim = stat_dim

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.stat_dim is not None:
            result['StatDim'] = self.stat_dim
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('StatDim') is not None:
            self.stat_dim = m.get('StatDim')
        return self


class DescribeQualityDistributionStatDataResponseBodyQualityStatDataList(TeaModel):
    def __init__(
        self,
        audio_delay: int = None,
        audio_high_quality_transmission_rate: str = None,
        audio_stuck_rate: str = None,
        call_duration_ratio: str = None,
        join_channel_suc_five_sec_rate: str = None,
        join_channel_suc_rate: str = None,
        name: str = None,
        video_delay: int = None,
        video_first_pic_duration: int = None,
        video_high_quality_transmission_rate: str = None,
        video_stuck_rate: str = None,
    ):
        self.audio_delay = audio_delay
        self.audio_high_quality_transmission_rate = audio_high_quality_transmission_rate
        self.audio_stuck_rate = audio_stuck_rate
        self.call_duration_ratio = call_duration_ratio
        self.join_channel_suc_five_sec_rate = join_channel_suc_five_sec_rate
        self.join_channel_suc_rate = join_channel_suc_rate
        self.name = name
        self.video_delay = video_delay
        self.video_first_pic_duration = video_first_pic_duration
        self.video_high_quality_transmission_rate = video_high_quality_transmission_rate
        self.video_stuck_rate = video_stuck_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_delay is not None:
            result['AudioDelay'] = self.audio_delay
        if self.audio_high_quality_transmission_rate is not None:
            result['AudioHighQualityTransmissionRate'] = self.audio_high_quality_transmission_rate
        if self.audio_stuck_rate is not None:
            result['AudioStuckRate'] = self.audio_stuck_rate
        if self.call_duration_ratio is not None:
            result['CallDurationRatio'] = self.call_duration_ratio
        if self.join_channel_suc_five_sec_rate is not None:
            result['JoinChannelSucFiveSecRate'] = self.join_channel_suc_five_sec_rate
        if self.join_channel_suc_rate is not None:
            result['JoinChannelSucRate'] = self.join_channel_suc_rate
        if self.name is not None:
            result['Name'] = self.name
        if self.video_delay is not None:
            result['VideoDelay'] = self.video_delay
        if self.video_first_pic_duration is not None:
            result['VideoFirstPicDuration'] = self.video_first_pic_duration
        if self.video_high_quality_transmission_rate is not None:
            result['VideoHighQualityTransmissionRate'] = self.video_high_quality_transmission_rate
        if self.video_stuck_rate is not None:
            result['VideoStuckRate'] = self.video_stuck_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioDelay') is not None:
            self.audio_delay = m.get('AudioDelay')
        if m.get('AudioHighQualityTransmissionRate') is not None:
            self.audio_high_quality_transmission_rate = m.get('AudioHighQualityTransmissionRate')
        if m.get('AudioStuckRate') is not None:
            self.audio_stuck_rate = m.get('AudioStuckRate')
        if m.get('CallDurationRatio') is not None:
            self.call_duration_ratio = m.get('CallDurationRatio')
        if m.get('JoinChannelSucFiveSecRate') is not None:
            self.join_channel_suc_five_sec_rate = m.get('JoinChannelSucFiveSecRate')
        if m.get('JoinChannelSucRate') is not None:
            self.join_channel_suc_rate = m.get('JoinChannelSucRate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VideoDelay') is not None:
            self.video_delay = m.get('VideoDelay')
        if m.get('VideoFirstPicDuration') is not None:
            self.video_first_pic_duration = m.get('VideoFirstPicDuration')
        if m.get('VideoHighQualityTransmissionRate') is not None:
            self.video_high_quality_transmission_rate = m.get('VideoHighQualityTransmissionRate')
        if m.get('VideoStuckRate') is not None:
            self.video_stuck_rate = m.get('VideoStuckRate')
        return self


class DescribeQualityDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        quality_stat_data_list: List[DescribeQualityDistributionStatDataResponseBodyQualityStatDataList] = None,
        request_id: str = None,
    ):
        self.quality_stat_data_list = quality_stat_data_list
        self.request_id = request_id

    def validate(self):
        if self.quality_stat_data_list:
            for k in self.quality_stat_data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['QualityStatDataList'] = []
        if self.quality_stat_data_list is not None:
            for k in self.quality_stat_data_list:
                result['QualityStatDataList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.quality_stat_data_list = []
        if m.get('QualityStatDataList') is not None:
            for k in m.get('QualityStatDataList'):
                temp_model = DescribeQualityDistributionStatDataResponseBodyQualityStatDataList()
                self.quality_stat_data_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeQualityDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQualityDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQualityDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQualityOsSdkVersionDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        start_date: int = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeQualityOsSdkVersionDistributionStatDataResponseBodyQualityOsSdkVersionStatDataList(TeaModel):
    def __init__(
        self,
        audio_delay: int = None,
        audio_high_quality_transmission_rate: str = None,
        audio_stuck_rate: str = None,
        call_duration_ratio: str = None,
        join_channel_suc_five_sec_rate: str = None,
        join_channel_suc_rate: str = None,
        name: str = None,
        os: str = None,
        video_delay: int = None,
        video_first_pic_duration: int = None,
        video_high_quality_transmission_rate: str = None,
        video_stuck_rate: str = None,
    ):
        self.audio_delay = audio_delay
        self.audio_high_quality_transmission_rate = audio_high_quality_transmission_rate
        self.audio_stuck_rate = audio_stuck_rate
        self.call_duration_ratio = call_duration_ratio
        self.join_channel_suc_five_sec_rate = join_channel_suc_five_sec_rate
        self.join_channel_suc_rate = join_channel_suc_rate
        self.name = name
        self.os = os
        self.video_delay = video_delay
        self.video_first_pic_duration = video_first_pic_duration
        self.video_high_quality_transmission_rate = video_high_quality_transmission_rate
        self.video_stuck_rate = video_stuck_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_delay is not None:
            result['AudioDelay'] = self.audio_delay
        if self.audio_high_quality_transmission_rate is not None:
            result['AudioHighQualityTransmissionRate'] = self.audio_high_quality_transmission_rate
        if self.audio_stuck_rate is not None:
            result['AudioStuckRate'] = self.audio_stuck_rate
        if self.call_duration_ratio is not None:
            result['CallDurationRatio'] = self.call_duration_ratio
        if self.join_channel_suc_five_sec_rate is not None:
            result['JoinChannelSucFiveSecRate'] = self.join_channel_suc_five_sec_rate
        if self.join_channel_suc_rate is not None:
            result['JoinChannelSucRate'] = self.join_channel_suc_rate
        if self.name is not None:
            result['Name'] = self.name
        if self.os is not None:
            result['Os'] = self.os
        if self.video_delay is not None:
            result['VideoDelay'] = self.video_delay
        if self.video_first_pic_duration is not None:
            result['VideoFirstPicDuration'] = self.video_first_pic_duration
        if self.video_high_quality_transmission_rate is not None:
            result['VideoHighQualityTransmissionRate'] = self.video_high_quality_transmission_rate
        if self.video_stuck_rate is not None:
            result['VideoStuckRate'] = self.video_stuck_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioDelay') is not None:
            self.audio_delay = m.get('AudioDelay')
        if m.get('AudioHighQualityTransmissionRate') is not None:
            self.audio_high_quality_transmission_rate = m.get('AudioHighQualityTransmissionRate')
        if m.get('AudioStuckRate') is not None:
            self.audio_stuck_rate = m.get('AudioStuckRate')
        if m.get('CallDurationRatio') is not None:
            self.call_duration_ratio = m.get('CallDurationRatio')
        if m.get('JoinChannelSucFiveSecRate') is not None:
            self.join_channel_suc_five_sec_rate = m.get('JoinChannelSucFiveSecRate')
        if m.get('JoinChannelSucRate') is not None:
            self.join_channel_suc_rate = m.get('JoinChannelSucRate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('VideoDelay') is not None:
            self.video_delay = m.get('VideoDelay')
        if m.get('VideoFirstPicDuration') is not None:
            self.video_first_pic_duration = m.get('VideoFirstPicDuration')
        if m.get('VideoHighQualityTransmissionRate') is not None:
            self.video_high_quality_transmission_rate = m.get('VideoHighQualityTransmissionRate')
        if m.get('VideoStuckRate') is not None:
            self.video_stuck_rate = m.get('VideoStuckRate')
        return self


class DescribeQualityOsSdkVersionDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        quality_os_sdk_version_stat_data_list: List[DescribeQualityOsSdkVersionDistributionStatDataResponseBodyQualityOsSdkVersionStatDataList] = None,
        request_id: str = None,
    ):
        self.quality_os_sdk_version_stat_data_list = quality_os_sdk_version_stat_data_list
        self.request_id = request_id

    def validate(self):
        if self.quality_os_sdk_version_stat_data_list:
            for k in self.quality_os_sdk_version_stat_data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['QualityOsSdkVersionStatDataList'] = []
        if self.quality_os_sdk_version_stat_data_list is not None:
            for k in self.quality_os_sdk_version_stat_data_list:
                result['QualityOsSdkVersionStatDataList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.quality_os_sdk_version_stat_data_list = []
        if m.get('QualityOsSdkVersionStatDataList') is not None:
            for k in m.get('QualityOsSdkVersionStatDataList'):
                temp_model = DescribeQualityOsSdkVersionDistributionStatDataResponseBodyQualityOsSdkVersionStatDataList()
                self.quality_os_sdk_version_stat_data_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeQualityOsSdkVersionDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQualityOsSdkVersionDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQualityOsSdkVersionDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQualityOverallDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        start_date: int = None,
        types: str = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        # This parameter is required.
        self.start_date = start_date
        # This parameter is required.
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class DescribeQualityOverallDataResponseBodyQualityOverallDataNodes(TeaModel):
    def __init__(
        self,
        x: str = None,
        y: str = None,
    ):
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeQualityOverallDataResponseBodyQualityOverallData(TeaModel):
    def __init__(
        self,
        average: str = None,
        nodes: List[DescribeQualityOverallDataResponseBodyQualityOverallDataNodes] = None,
        type: str = None,
    ):
        self.average = average
        self.nodes = nodes
        self.type = type

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average is not None:
            result['Average'] = self.average
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Average') is not None:
            self.average = m.get('Average')
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeQualityOverallDataResponseBodyQualityOverallDataNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeQualityOverallDataResponseBody(TeaModel):
    def __init__(
        self,
        quality_overall_data: List[DescribeQualityOverallDataResponseBodyQualityOverallData] = None,
        request_id: str = None,
    ):
        self.quality_overall_data = quality_overall_data
        self.request_id = request_id

    def validate(self):
        if self.quality_overall_data:
            for k in self.quality_overall_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['QualityOverallData'] = []
        if self.quality_overall_data is not None:
            for k in self.quality_overall_data:
                result['QualityOverallData'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.quality_overall_data = []
        if m.get('QualityOverallData') is not None:
            for k in m.get('QualityOverallData'):
                temp_model = DescribeQualityOverallDataResponseBodyQualityOverallData()
                self.quality_overall_data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeQualityOverallDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeQualityOverallDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQualityOverallDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecordFilesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        end_time: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        start_time: str = None,
        task_ids: List[str] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.channel_id = channel_id
        self.end_time = end_time
        self.owner_id = owner_id
        self.page_num = page_num
        self.page_size = page_size
        self.start_time = start_time
        self.task_ids = task_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DescribeRecordFilesResponseBodyRecordFiles(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        create_time: str = None,
        duration: float = None,
        start_time: str = None,
        stop_time: str = None,
        task_id: str = None,
        url: str = None,
    ):
        self.app_id = app_id
        self.channel_id = channel_id
        self.create_time = create_time
        self.duration = duration
        self.start_time = start_time
        self.stop_time = stop_time
        self.task_id = task_id
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeRecordFilesResponseBody(TeaModel):
    def __init__(
        self,
        record_files: List[DescribeRecordFilesResponseBodyRecordFiles] = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.record_files = record_files
        self.request_id = request_id
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.record_files:
            for k in self.record_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecordFiles'] = []
        if self.record_files is not None:
            for k in self.record_files:
                result['RecordFiles'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.record_files = []
        if m.get('RecordFiles') is not None:
            for k in m.get('RecordFiles'):
                temp_model = DescribeRecordFilesResponseBodyRecordFiles()
                self.record_files.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeRecordFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecordFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecordFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecordTemplatesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
        template_ids: List[str] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # 1
        self.owner_id = owner_id
        self.page_num = page_num
        self.page_size = page_size
        self.template_ids = template_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        return self


class DescribeRecordTemplatesResponseBodyTemplatesBackgrounds(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class DescribeRecordTemplatesResponseBodyTemplatesClockWidgets(TeaModel):
    def __init__(
        self,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class DescribeRecordTemplatesResponseBodyTemplatesWatermarks(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class DescribeRecordTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        background_color: int = None,
        backgrounds: List[DescribeRecordTemplatesResponseBodyTemplatesBackgrounds] = None,
        clock_widgets: List[DescribeRecordTemplatesResponseBodyTemplatesClockWidgets] = None,
        create_time: str = None,
        delay_stop_time: int = None,
        enable_m3u_8date_time: bool = None,
        file_split_interval: int = None,
        formats: List[str] = None,
        http_callback_url: str = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        mns_queue: str = None,
        name: str = None,
        oss_bucket: str = None,
        oss_file_prefix: str = None,
        task_profile: str = None,
        template_id: str = None,
        watermarks: List[DescribeRecordTemplatesResponseBodyTemplatesWatermarks] = None,
    ):
        self.background_color = background_color
        self.backgrounds = backgrounds
        self.clock_widgets = clock_widgets
        self.create_time = create_time
        self.delay_stop_time = delay_stop_time
        self.enable_m3u_8date_time = enable_m3u_8date_time
        self.file_split_interval = file_split_interval
        self.formats = formats
        self.http_callback_url = http_callback_url
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.mns_queue = mns_queue
        self.name = name
        self.oss_bucket = oss_bucket
        self.oss_file_prefix = oss_file_prefix
        self.task_profile = task_profile
        self.template_id = template_id
        self.watermarks = watermarks

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.watermarks:
            for k in self.watermarks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.background_color is not None:
            result['BackgroundColor'] = self.background_color
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.delay_stop_time is not None:
            result['DelayStopTime'] = self.delay_stop_time
        if self.enable_m3u_8date_time is not None:
            result['EnableM3u8DateTime'] = self.enable_m3u_8date_time
        if self.file_split_interval is not None:
            result['FileSplitInterval'] = self.file_split_interval
        if self.formats is not None:
            result['Formats'] = self.formats
        if self.http_callback_url is not None:
            result['HttpCallbackUrl'] = self.http_callback_url
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.mns_queue is not None:
            result['MnsQueue'] = self.mns_queue
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_file_prefix is not None:
            result['OssFilePrefix'] = self.oss_file_prefix
        if self.task_profile is not None:
            result['TaskProfile'] = self.task_profile
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Watermarks'] = []
        if self.watermarks is not None:
            for k in self.watermarks:
                result['Watermarks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BackgroundColor') is not None:
            self.background_color = m.get('BackgroundColor')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = DescribeRecordTemplatesResponseBodyTemplatesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = DescribeRecordTemplatesResponseBodyTemplatesClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DelayStopTime') is not None:
            self.delay_stop_time = m.get('DelayStopTime')
        if m.get('EnableM3u8DateTime') is not None:
            self.enable_m3u_8date_time = m.get('EnableM3u8DateTime')
        if m.get('FileSplitInterval') is not None:
            self.file_split_interval = m.get('FileSplitInterval')
        if m.get('Formats') is not None:
            self.formats = m.get('Formats')
        if m.get('HttpCallbackUrl') is not None:
            self.http_callback_url = m.get('HttpCallbackUrl')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('MnsQueue') is not None:
            self.mns_queue = m.get('MnsQueue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssFilePrefix') is not None:
            self.oss_file_prefix = m.get('OssFilePrefix')
        if m.get('TaskProfile') is not None:
            self.task_profile = m.get('TaskProfile')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.watermarks = []
        if m.get('Watermarks') is not None:
            for k in m.get('Watermarks'):
                temp_model = DescribeRecordTemplatesResponseBodyTemplatesWatermarks()
                self.watermarks.append(temp_model.from_map(k))
        return self


class DescribeRecordTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        templates: List[DescribeRecordTemplatesResponseBodyTemplates] = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.request_id = request_id
        self.templates = templates
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['Templates'].append(k.to_map() if k else None)
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.templates = []
        if m.get('Templates') is not None:
            for k in m.get('Templates'):
                temp_model = DescribeRecordTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeRecordTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRecordTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecordTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcChannelListRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        owner_id: int = None,
        page_no: int = None,
        page_size: int = None,
        service_area: str = None,
        sort_type: str = None,
        time_point: str = None,
        user_id: str = None,
    ):
        self.app_id = app_id
        self.channel_id = channel_id
        self.owner_id = owner_id
        # This parameter is required.
        self.page_no = page_no
        # This parameter is required.
        self.page_size = page_size
        self.service_area = service_area
        self.sort_type = sort_type
        # This parameter is required.
        self.time_point = time_point
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.service_area is not None:
            result['ServiceArea'] = self.service_area
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.time_point is not None:
            result['TimePoint'] = self.time_point
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ServiceArea') is not None:
            self.service_area = m.get('ServiceArea')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('TimePoint') is not None:
            self.time_point = m.get('TimePoint')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeRtcChannelListResponseBodyChannelListChannelListCallArea(TeaModel):
    def __init__(
        self,
        call_area: List[str] = None,
    ):
        self.call_area = call_area

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_area is not None:
            result['CallArea'] = self.call_area
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallArea') is not None:
            self.call_area = m.get('CallArea')
        return self


class DescribeRtcChannelListResponseBodyChannelListChannelList(TeaModel):
    def __init__(
        self,
        call_area: DescribeRtcChannelListResponseBodyChannelListChannelListCallArea = None,
        channel_id: str = None,
        end_time: str = None,
        start_time: str = None,
        total_user_cnt: int = None,
    ):
        self.call_area = call_area
        self.channel_id = channel_id
        self.end_time = end_time
        self.start_time = start_time
        self.total_user_cnt = total_user_cnt

    def validate(self):
        if self.call_area:
            self.call_area.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.call_area is not None:
            result['CallArea'] = self.call_area.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.total_user_cnt is not None:
            result['TotalUserCnt'] = self.total_user_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CallArea') is not None:
            temp_model = DescribeRtcChannelListResponseBodyChannelListChannelListCallArea()
            self.call_area = temp_model.from_map(m['CallArea'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TotalUserCnt') is not None:
            self.total_user_cnt = m.get('TotalUserCnt')
        return self


class DescribeRtcChannelListResponseBodyChannelList(TeaModel):
    def __init__(
        self,
        channel_list: List[DescribeRtcChannelListResponseBodyChannelListChannelList] = None,
    ):
        self.channel_list = channel_list

    def validate(self):
        if self.channel_list:
            for k in self.channel_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChannelList'] = []
        if self.channel_list is not None:
            for k in self.channel_list:
                result['ChannelList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel_list = []
        if m.get('ChannelList') is not None:
            for k in m.get('ChannelList'):
                temp_model = DescribeRtcChannelListResponseBodyChannelListChannelList()
                self.channel_list.append(temp_model.from_map(k))
        return self


class DescribeRtcChannelListResponseBody(TeaModel):
    def __init__(
        self,
        channel_list: DescribeRtcChannelListResponseBodyChannelList = None,
        page_no: int = None,
        page_size: int = None,
        request_id: str = None,
        total_cnt: int = None,
    ):
        self.channel_list = channel_list
        self.page_no = page_no
        self.page_size = page_size
        self.request_id = request_id
        self.total_cnt = total_cnt

    def validate(self):
        if self.channel_list:
            self.channel_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_list is not None:
            result['ChannelList'] = self.channel_list.to_map()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelList') is not None:
            temp_model = DescribeRtcChannelListResponseBodyChannelList()
            self.channel_list = temp_model.from_map(m['ChannelList'])
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribeRtcChannelListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcChannelListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcChannelListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcChannelMetricRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        owner_id: int = None,
        time_point: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.owner_id = owner_id
        # This parameter is required.
        self.time_point = time_point

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.time_point is not None:
            result['TimePoint'] = self.time_point
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TimePoint') is not None:
            self.time_point = m.get('TimePoint')
        return self


class DescribeRtcChannelMetricResponseBodyChannelMetricInfoChannelMetric(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        end_time: str = None,
        pub_user_count: int = None,
        start_time: str = None,
        sub_user_count: int = None,
        user_count: int = None,
    ):
        self.channel_id = channel_id
        self.end_time = end_time
        self.pub_user_count = pub_user_count
        self.start_time = start_time
        self.sub_user_count = sub_user_count
        self.user_count = user_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.pub_user_count is not None:
            result['PubUserCount'] = self.pub_user_count
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.sub_user_count is not None:
            result['SubUserCount'] = self.sub_user_count
        if self.user_count is not None:
            result['UserCount'] = self.user_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PubUserCount') is not None:
            self.pub_user_count = m.get('PubUserCount')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SubUserCount') is not None:
            self.sub_user_count = m.get('SubUserCount')
        if m.get('UserCount') is not None:
            self.user_count = m.get('UserCount')
        return self


class DescribeRtcChannelMetricResponseBodyChannelMetricInfoDurationPubDuration(TeaModel):
    def __init__(
        self,
        audio: int = None,
        content: int = None,
        video_1080: int = None,
        video_360: int = None,
        video_720: int = None,
    ):
        self.audio = audio
        self.content = content
        self.video_1080 = video_1080
        self.video_360 = video_360
        self.video_720 = video_720

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio
        if self.content is not None:
            result['Content'] = self.content
        if self.video_1080 is not None:
            result['Video1080'] = self.video_1080
        if self.video_360 is not None:
            result['Video360'] = self.video_360
        if self.video_720 is not None:
            result['Video720'] = self.video_720
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            self.audio = m.get('Audio')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Video1080') is not None:
            self.video_1080 = m.get('Video1080')
        if m.get('Video360') is not None:
            self.video_360 = m.get('Video360')
        if m.get('Video720') is not None:
            self.video_720 = m.get('Video720')
        return self


class DescribeRtcChannelMetricResponseBodyChannelMetricInfoDurationSubDuration(TeaModel):
    def __init__(
        self,
        audio: int = None,
        content: int = None,
        video_1080: int = None,
        video_360: int = None,
        video_720: int = None,
    ):
        self.audio = audio
        self.content = content
        self.video_1080 = video_1080
        self.video_360 = video_360
        self.video_720 = video_720

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio
        if self.content is not None:
            result['Content'] = self.content
        if self.video_1080 is not None:
            result['Video1080'] = self.video_1080
        if self.video_360 is not None:
            result['Video360'] = self.video_360
        if self.video_720 is not None:
            result['Video720'] = self.video_720
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            self.audio = m.get('Audio')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Video1080') is not None:
            self.video_1080 = m.get('Video1080')
        if m.get('Video360') is not None:
            self.video_360 = m.get('Video360')
        if m.get('Video720') is not None:
            self.video_720 = m.get('Video720')
        return self


class DescribeRtcChannelMetricResponseBodyChannelMetricInfoDuration(TeaModel):
    def __init__(
        self,
        pub_duration: DescribeRtcChannelMetricResponseBodyChannelMetricInfoDurationPubDuration = None,
        sub_duration: DescribeRtcChannelMetricResponseBodyChannelMetricInfoDurationSubDuration = None,
    ):
        self.pub_duration = pub_duration
        self.sub_duration = sub_duration

    def validate(self):
        if self.pub_duration:
            self.pub_duration.validate()
        if self.sub_duration:
            self.sub_duration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pub_duration is not None:
            result['PubDuration'] = self.pub_duration.to_map()
        if self.sub_duration is not None:
            result['SubDuration'] = self.sub_duration.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PubDuration') is not None:
            temp_model = DescribeRtcChannelMetricResponseBodyChannelMetricInfoDurationPubDuration()
            self.pub_duration = temp_model.from_map(m['PubDuration'])
        if m.get('SubDuration') is not None:
            temp_model = DescribeRtcChannelMetricResponseBodyChannelMetricInfoDurationSubDuration()
            self.sub_duration = temp_model.from_map(m['SubDuration'])
        return self


class DescribeRtcChannelMetricResponseBodyChannelMetricInfo(TeaModel):
    def __init__(
        self,
        channel_metric: DescribeRtcChannelMetricResponseBodyChannelMetricInfoChannelMetric = None,
        duration: DescribeRtcChannelMetricResponseBodyChannelMetricInfoDuration = None,
    ):
        self.channel_metric = channel_metric
        self.duration = duration

    def validate(self):
        if self.channel_metric:
            self.channel_metric.validate()
        if self.duration:
            self.duration.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_metric is not None:
            result['ChannelMetric'] = self.channel_metric.to_map()
        if self.duration is not None:
            result['Duration'] = self.duration.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelMetric') is not None:
            temp_model = DescribeRtcChannelMetricResponseBodyChannelMetricInfoChannelMetric()
            self.channel_metric = temp_model.from_map(m['ChannelMetric'])
        if m.get('Duration') is not None:
            temp_model = DescribeRtcChannelMetricResponseBodyChannelMetricInfoDuration()
            self.duration = temp_model.from_map(m['Duration'])
        return self


class DescribeRtcChannelMetricResponseBody(TeaModel):
    def __init__(
        self,
        channel_metric_info: DescribeRtcChannelMetricResponseBodyChannelMetricInfo = None,
        request_id: str = None,
    ):
        self.channel_metric_info = channel_metric_info
        self.request_id = request_id

    def validate(self):
        if self.channel_metric_info:
            self.channel_metric_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_metric_info is not None:
            result['ChannelMetricInfo'] = self.channel_metric_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelMetricInfo') is not None:
            temp_model = DescribeRtcChannelMetricResponseBodyChannelMetricInfo()
            self.channel_metric_info = temp_model.from_map(m['ChannelMetricInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRtcChannelMetricResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcChannelMetricResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcChannelMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcDurationDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        service_area: str = None,
        start_time: str = None,
    ):
        self.app_id = app_id
        self.end_time = end_time
        self.interval = interval
        self.owner_id = owner_id
        self.service_area = service_area
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.service_area is not None:
            result['ServiceArea'] = self.service_area
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ServiceArea') is not None:
            self.service_area = m.get('ServiceArea')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRtcDurationDataResponseBodyDurationDataPerIntervalDurationModule(TeaModel):
    def __init__(
        self,
        audio_duration: int = None,
        content_duration: int = None,
        time_stamp: str = None,
        total_duration: int = None,
        v_1080duration: int = None,
        v_360duration: int = None,
        v_720duration: int = None,
    ):
        self.audio_duration = audio_duration
        self.content_duration = content_duration
        self.time_stamp = time_stamp
        self.total_duration = total_duration
        self.v_1080duration = v_1080duration
        self.v_360duration = v_360duration
        self.v_720duration = v_720duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_duration is not None:
            result['AudioDuration'] = self.audio_duration
        if self.content_duration is not None:
            result['ContentDuration'] = self.content_duration
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        if self.total_duration is not None:
            result['TotalDuration'] = self.total_duration
        if self.v_1080duration is not None:
            result['V1080Duration'] = self.v_1080duration
        if self.v_360duration is not None:
            result['V360Duration'] = self.v_360duration
        if self.v_720duration is not None:
            result['V720Duration'] = self.v_720duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioDuration') is not None:
            self.audio_duration = m.get('AudioDuration')
        if m.get('ContentDuration') is not None:
            self.content_duration = m.get('ContentDuration')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        if m.get('TotalDuration') is not None:
            self.total_duration = m.get('TotalDuration')
        if m.get('V1080Duration') is not None:
            self.v_1080duration = m.get('V1080Duration')
        if m.get('V360Duration') is not None:
            self.v_360duration = m.get('V360Duration')
        if m.get('V720Duration') is not None:
            self.v_720duration = m.get('V720Duration')
        return self


class DescribeRtcDurationDataResponseBodyDurationDataPerInterval(TeaModel):
    def __init__(
        self,
        duration_module: List[DescribeRtcDurationDataResponseBodyDurationDataPerIntervalDurationModule] = None,
    ):
        self.duration_module = duration_module

    def validate(self):
        if self.duration_module:
            for k in self.duration_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DurationModule'] = []
        if self.duration_module is not None:
            for k in self.duration_module:
                result['DurationModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.duration_module = []
        if m.get('DurationModule') is not None:
            for k in m.get('DurationModule'):
                temp_model = DescribeRtcDurationDataResponseBodyDurationDataPerIntervalDurationModule()
                self.duration_module.append(temp_model.from_map(k))
        return self


class DescribeRtcDurationDataResponseBody(TeaModel):
    def __init__(
        self,
        duration_data_per_interval: DescribeRtcDurationDataResponseBodyDurationDataPerInterval = None,
        request_id: str = None,
    ):
        self.duration_data_per_interval = duration_data_per_interval
        self.request_id = request_id

    def validate(self):
        if self.duration_data_per_interval:
            self.duration_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration_data_per_interval is not None:
            result['DurationDataPerInterval'] = self.duration_data_per_interval.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DurationDataPerInterval') is not None:
            temp_model = DescribeRtcDurationDataResponseBodyDurationDataPerInterval()
            self.duration_data_per_interval = temp_model.from_map(m['DurationDataPerInterval'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRtcDurationDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcDurationDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcDurationDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcPeakChannelCntDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        service_area: str = None,
        start_time: str = None,
    ):
        self.app_id = app_id
        self.end_time = end_time
        self.interval = interval
        self.owner_id = owner_id
        self.service_area = service_area
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.service_area is not None:
            result['ServiceArea'] = self.service_area
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ServiceArea') is not None:
            self.service_area = m.get('ServiceArea')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRtcPeakChannelCntDataResponseBodyPeakChannelCntDataPerIntervalPeakChannelCntModule(TeaModel):
    def __init__(
        self,
        active_channel_peak: int = None,
        active_channel_peak_time: str = None,
        time_stamp: str = None,
    ):
        self.active_channel_peak = active_channel_peak
        self.active_channel_peak_time = active_channel_peak_time
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_channel_peak is not None:
            result['ActiveChannelPeak'] = self.active_channel_peak
        if self.active_channel_peak_time is not None:
            result['ActiveChannelPeakTime'] = self.active_channel_peak_time
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveChannelPeak') is not None:
            self.active_channel_peak = m.get('ActiveChannelPeak')
        if m.get('ActiveChannelPeakTime') is not None:
            self.active_channel_peak_time = m.get('ActiveChannelPeakTime')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeRtcPeakChannelCntDataResponseBodyPeakChannelCntDataPerInterval(TeaModel):
    def __init__(
        self,
        peak_channel_cnt_module: List[DescribeRtcPeakChannelCntDataResponseBodyPeakChannelCntDataPerIntervalPeakChannelCntModule] = None,
    ):
        self.peak_channel_cnt_module = peak_channel_cnt_module

    def validate(self):
        if self.peak_channel_cnt_module:
            for k in self.peak_channel_cnt_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PeakChannelCntModule'] = []
        if self.peak_channel_cnt_module is not None:
            for k in self.peak_channel_cnt_module:
                result['PeakChannelCntModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.peak_channel_cnt_module = []
        if m.get('PeakChannelCntModule') is not None:
            for k in m.get('PeakChannelCntModule'):
                temp_model = DescribeRtcPeakChannelCntDataResponseBodyPeakChannelCntDataPerIntervalPeakChannelCntModule()
                self.peak_channel_cnt_module.append(temp_model.from_map(k))
        return self


class DescribeRtcPeakChannelCntDataResponseBody(TeaModel):
    def __init__(
        self,
        peak_channel_cnt_data_per_interval: DescribeRtcPeakChannelCntDataResponseBodyPeakChannelCntDataPerInterval = None,
        request_id: str = None,
    ):
        self.peak_channel_cnt_data_per_interval = peak_channel_cnt_data_per_interval
        self.request_id = request_id

    def validate(self):
        if self.peak_channel_cnt_data_per_interval:
            self.peak_channel_cnt_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.peak_channel_cnt_data_per_interval is not None:
            result['PeakChannelCntDataPerInterval'] = self.peak_channel_cnt_data_per_interval.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PeakChannelCntDataPerInterval') is not None:
            temp_model = DescribeRtcPeakChannelCntDataResponseBodyPeakChannelCntDataPerInterval()
            self.peak_channel_cnt_data_per_interval = temp_model.from_map(m['PeakChannelCntDataPerInterval'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRtcPeakChannelCntDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcPeakChannelCntDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcPeakChannelCntDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRtcUserCntDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_time: str = None,
        interval: str = None,
        owner_id: int = None,
        service_area: str = None,
        start_time: str = None,
    ):
        self.app_id = app_id
        self.end_time = end_time
        self.interval = interval
        self.owner_id = owner_id
        self.service_area = service_area
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.service_area is not None:
            result['ServiceArea'] = self.service_area
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ServiceArea') is not None:
            self.service_area = m.get('ServiceArea')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeRtcUserCntDataResponseBodyUserCntDataPerIntervalUserCntModule(TeaModel):
    def __init__(
        self,
        active_user_cnt: int = None,
        time_stamp: str = None,
    ):
        self.active_user_cnt = active_user_cnt
        self.time_stamp = time_stamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_user_cnt is not None:
            result['ActiveUserCnt'] = self.active_user_cnt
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveUserCnt') is not None:
            self.active_user_cnt = m.get('ActiveUserCnt')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeRtcUserCntDataResponseBodyUserCntDataPerInterval(TeaModel):
    def __init__(
        self,
        user_cnt_module: List[DescribeRtcUserCntDataResponseBodyUserCntDataPerIntervalUserCntModule] = None,
    ):
        self.user_cnt_module = user_cnt_module

    def validate(self):
        if self.user_cnt_module:
            for k in self.user_cnt_module:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['UserCntModule'] = []
        if self.user_cnt_module is not None:
            for k in self.user_cnt_module:
                result['UserCntModule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.user_cnt_module = []
        if m.get('UserCntModule') is not None:
            for k in m.get('UserCntModule'):
                temp_model = DescribeRtcUserCntDataResponseBodyUserCntDataPerIntervalUserCntModule()
                self.user_cnt_module.append(temp_model.from_map(k))
        return self


class DescribeRtcUserCntDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        user_cnt_data_per_interval: DescribeRtcUserCntDataResponseBodyUserCntDataPerInterval = None,
    ):
        self.request_id = request_id
        self.user_cnt_data_per_interval = user_cnt_data_per_interval

    def validate(self):
        if self.user_cnt_data_per_interval:
            self.user_cnt_data_per_interval.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_cnt_data_per_interval is not None:
            result['UserCntDataPerInterval'] = self.user_cnt_data_per_interval.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserCntDataPerInterval') is not None:
            temp_model = DescribeRtcUserCntDataResponseBodyUserCntDataPerInterval()
            self.user_cnt_data_per_interval = temp_model.from_map(m['UserCntDataPerInterval'])
        return self


class DescribeRtcUserCntDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeRtcUserCntDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRtcUserCntDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStreamingOutStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeStreamingOutStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        status: int = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeStreamingOutStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeStreamingOutStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStreamingOutStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSystemLayoutListRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
        page_num: int = None,
        page_size: int = None,
    ):
        self.owner_id = owner_id
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeSystemLayoutListResponseBodyLayoutsLayoutPanesPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        major_pane: int = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        # MajorPane。
        self.major_pane = major_pane
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.major_pane is not None:
            result['MajorPane'] = self.major_pane
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MajorPane') is not None:
            self.major_pane = m.get('MajorPane')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class DescribeSystemLayoutListResponseBodyLayoutsLayoutPanes(TeaModel):
    def __init__(
        self,
        panes: List[DescribeSystemLayoutListResponseBodyLayoutsLayoutPanesPanes] = None,
    ):
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = DescribeSystemLayoutListResponseBodyLayoutsLayoutPanesPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class DescribeSystemLayoutListResponseBodyLayoutsLayout(TeaModel):
    def __init__(
        self,
        audio_mix_count: int = None,
        layout_id: int = None,
        name: str = None,
        panes: DescribeSystemLayoutListResponseBodyLayoutsLayoutPanes = None,
    ):
        # AudioMixCount。
        self.audio_mix_count = audio_mix_count
        self.layout_id = layout_id
        self.name = name
        self.panes = panes

    def validate(self):
        if self.panes:
            self.panes.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_mix_count is not None:
            result['AudioMixCount'] = self.audio_mix_count
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        if self.panes is not None:
            result['Panes'] = self.panes.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioMixCount') is not None:
            self.audio_mix_count = m.get('AudioMixCount')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Panes') is not None:
            temp_model = DescribeSystemLayoutListResponseBodyLayoutsLayoutPanes()
            self.panes = temp_model.from_map(m['Panes'])
        return self


class DescribeSystemLayoutListResponseBodyLayouts(TeaModel):
    def __init__(
        self,
        layout: List[DescribeSystemLayoutListResponseBodyLayoutsLayout] = None,
    ):
        self.layout = layout

    def validate(self):
        if self.layout:
            for k in self.layout:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Layout'] = []
        if self.layout is not None:
            for k in self.layout:
                result['Layout'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.layout = []
        if m.get('Layout') is not None:
            for k in m.get('Layout'):
                temp_model = DescribeSystemLayoutListResponseBodyLayoutsLayout()
                self.layout.append(temp_model.from_map(k))
        return self


class DescribeSystemLayoutListResponseBody(TeaModel):
    def __init__(
        self,
        layouts: DescribeSystemLayoutListResponseBodyLayouts = None,
        request_id: str = None,
        total_num: int = None,
        total_page: int = None,
    ):
        self.layouts = layouts
        self.request_id = request_id
        self.total_num = total_num
        self.total_page = total_page

    def validate(self):
        if self.layouts:
            self.layouts.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layouts is not None:
            result['Layouts'] = self.layouts.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_num is not None:
            result['TotalNum'] = self.total_num
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Layouts') is not None:
            temp_model = DescribeSystemLayoutListResponseBodyLayouts()
            self.layouts = temp_model.from_map(m['Layouts'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalNum') is not None:
            self.total_num = m.get('TotalNum')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class DescribeSystemLayoutListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeSystemLayoutListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSystemLayoutListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsageAreaDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: str = None,
        parent_area: str = None,
        start_date: str = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        self.parent_area = parent_area
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.parent_area is not None:
            result['ParentArea'] = self.parent_area
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('ParentArea') is not None:
            self.parent_area = m.get('ParentArea')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeUsageAreaDistributionStatDataResponseBodyUsageAreaStatList(TeaModel):
    def __init__(
        self,
        audio_call_duration: int = None,
        name: str = None,
        total_call_duration: int = None,
        video_call_duration: int = None,
    ):
        self.audio_call_duration = audio_call_duration
        self.name = name
        self.total_call_duration = total_call_duration
        self.video_call_duration = video_call_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_call_duration is not None:
            result['AudioCallDuration'] = self.audio_call_duration
        if self.name is not None:
            result['Name'] = self.name
        if self.total_call_duration is not None:
            result['TotalCallDuration'] = self.total_call_duration
        if self.video_call_duration is not None:
            result['VideoCallDuration'] = self.video_call_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCallDuration') is not None:
            self.audio_call_duration = m.get('AudioCallDuration')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TotalCallDuration') is not None:
            self.total_call_duration = m.get('TotalCallDuration')
        if m.get('VideoCallDuration') is not None:
            self.video_call_duration = m.get('VideoCallDuration')
        return self


class DescribeUsageAreaDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        usage_area_stat_list: List[DescribeUsageAreaDistributionStatDataResponseBodyUsageAreaStatList] = None,
    ):
        self.request_id = request_id
        self.usage_area_stat_list = usage_area_stat_list

    def validate(self):
        if self.usage_area_stat_list:
            for k in self.usage_area_stat_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UsageAreaStatList'] = []
        if self.usage_area_stat_list is not None:
            for k in self.usage_area_stat_list:
                result['UsageAreaStatList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.usage_area_stat_list = []
        if m.get('UsageAreaStatList') is not None:
            for k in m.get('UsageAreaStatList'):
                temp_model = DescribeUsageAreaDistributionStatDataResponseBodyUsageAreaStatList()
                self.usage_area_stat_list.append(temp_model.from_map(k))
        return self


class DescribeUsageAreaDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUsageAreaDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsageAreaDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsageDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        start_date: int = None,
        stat_dim: str = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        # This parameter is required.
        self.start_date = start_date
        # This parameter is required.
        self.stat_dim = stat_dim

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.stat_dim is not None:
            result['StatDim'] = self.stat_dim
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('StatDim') is not None:
            self.stat_dim = m.get('StatDim')
        return self


class DescribeUsageDistributionStatDataResponseBodyUsageStatList(TeaModel):
    def __init__(
        self,
        audio_call_duration: int = None,
        call_duration_ratio: str = None,
        name: str = None,
        total_call_duration: int = None,
        video_call_duration: int = None,
    ):
        self.audio_call_duration = audio_call_duration
        self.call_duration_ratio = call_duration_ratio
        self.name = name
        self.total_call_duration = total_call_duration
        self.video_call_duration = video_call_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_call_duration is not None:
            result['AudioCallDuration'] = self.audio_call_duration
        if self.call_duration_ratio is not None:
            result['CallDurationRatio'] = self.call_duration_ratio
        if self.name is not None:
            result['Name'] = self.name
        if self.total_call_duration is not None:
            result['TotalCallDuration'] = self.total_call_duration
        if self.video_call_duration is not None:
            result['VideoCallDuration'] = self.video_call_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCallDuration') is not None:
            self.audio_call_duration = m.get('AudioCallDuration')
        if m.get('CallDurationRatio') is not None:
            self.call_duration_ratio = m.get('CallDurationRatio')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TotalCallDuration') is not None:
            self.total_call_duration = m.get('TotalCallDuration')
        if m.get('VideoCallDuration') is not None:
            self.video_call_duration = m.get('VideoCallDuration')
        return self


class DescribeUsageDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        usage_stat_list: List[DescribeUsageDistributionStatDataResponseBodyUsageStatList] = None,
    ):
        self.request_id = request_id
        self.usage_stat_list = usage_stat_list

    def validate(self):
        if self.usage_stat_list:
            for k in self.usage_stat_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UsageStatList'] = []
        if self.usage_stat_list is not None:
            for k in self.usage_stat_list:
                result['UsageStatList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.usage_stat_list = []
        if m.get('UsageStatList') is not None:
            for k in m.get('UsageStatList'):
                temp_model = DescribeUsageDistributionStatDataResponseBodyUsageStatList()
                self.usage_stat_list.append(temp_model.from_map(k))
        return self


class DescribeUsageDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUsageDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsageDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsageOsSdkVersionDistributionStatDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        start_date: int = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        # This parameter is required.
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class DescribeUsageOsSdkVersionDistributionStatDataResponseBodyUsageOsSdkVersionStatList(TeaModel):
    def __init__(
        self,
        audio_call_duration: int = None,
        call_duration_ratio: str = None,
        name: str = None,
        os: str = None,
        total_call_duration: int = None,
        video_call_duration: int = None,
    ):
        self.audio_call_duration = audio_call_duration
        self.call_duration_ratio = call_duration_ratio
        self.name = name
        self.os = os
        self.total_call_duration = total_call_duration
        self.video_call_duration = video_call_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_call_duration is not None:
            result['AudioCallDuration'] = self.audio_call_duration
        if self.call_duration_ratio is not None:
            result['CallDurationRatio'] = self.call_duration_ratio
        if self.name is not None:
            result['Name'] = self.name
        if self.os is not None:
            result['Os'] = self.os
        if self.total_call_duration is not None:
            result['TotalCallDuration'] = self.total_call_duration
        if self.video_call_duration is not None:
            result['VideoCallDuration'] = self.video_call_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioCallDuration') is not None:
            self.audio_call_duration = m.get('AudioCallDuration')
        if m.get('CallDurationRatio') is not None:
            self.call_duration_ratio = m.get('CallDurationRatio')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('TotalCallDuration') is not None:
            self.total_call_duration = m.get('TotalCallDuration')
        if m.get('VideoCallDuration') is not None:
            self.video_call_duration = m.get('VideoCallDuration')
        return self


class DescribeUsageOsSdkVersionDistributionStatDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        usage_os_sdk_version_stat_list: List[DescribeUsageOsSdkVersionDistributionStatDataResponseBodyUsageOsSdkVersionStatList] = None,
    ):
        self.request_id = request_id
        self.usage_os_sdk_version_stat_list = usage_os_sdk_version_stat_list

    def validate(self):
        if self.usage_os_sdk_version_stat_list:
            for k in self.usage_os_sdk_version_stat_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UsageOsSdkVersionStatList'] = []
        if self.usage_os_sdk_version_stat_list is not None:
            for k in self.usage_os_sdk_version_stat_list:
                result['UsageOsSdkVersionStatList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.usage_os_sdk_version_stat_list = []
        if m.get('UsageOsSdkVersionStatList') is not None:
            for k in m.get('UsageOsSdkVersionStatList'):
                temp_model = DescribeUsageOsSdkVersionDistributionStatDataResponseBodyUsageOsSdkVersionStatList()
                self.usage_os_sdk_version_stat_list.append(temp_model.from_map(k))
        return self


class DescribeUsageOsSdkVersionDistributionStatDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUsageOsSdkVersionDistributionStatDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsageOsSdkVersionDistributionStatDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsageOverallDataRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        end_date: int = None,
        start_date: int = None,
        types: str = None,
    ):
        # APP ID
        # 
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.end_date = end_date
        # This parameter is required.
        self.start_date = start_date
        # This parameter is required.
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class DescribeUsageOverallDataResponseBodyUsageOverallDataNodes(TeaModel):
    def __init__(
        self,
        x: str = None,
        y: str = None,
    ):
        self.x = x
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribeUsageOverallDataResponseBodyUsageOverallData(TeaModel):
    def __init__(
        self,
        nodes: List[DescribeUsageOverallDataResponseBodyUsageOverallDataNodes] = None,
        type: str = None,
    ):
        self.nodes = nodes
        self.type = type

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeUsageOverallDataResponseBodyUsageOverallDataNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeUsageOverallDataResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        usage_overall_data: List[DescribeUsageOverallDataResponseBodyUsageOverallData] = None,
    ):
        self.request_id = request_id
        self.usage_overall_data = usage_overall_data

    def validate(self):
        if self.usage_overall_data:
            for k in self.usage_overall_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UsageOverallData'] = []
        if self.usage_overall_data is not None:
            for k in self.usage_overall_data:
                result['UsageOverallData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.usage_overall_data = []
        if m.get('UsageOverallData') is not None:
            for k in m.get('UsageOverallData'):
                temp_model = DescribeUsageOverallDataResponseBodyUsageOverallData()
                self.usage_overall_data.append(temp_model.from_map(k))
        return self


class DescribeUsageOverallDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUsageOverallDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsageOverallDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserInfoInChannelRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        owner_id: int = None,
        user_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.owner_id = owner_id
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class DescribeUserInfoInChannelResponseBodyProperty(TeaModel):
    def __init__(
        self,
        join: int = None,
        role: int = None,
        session: str = None,
    ):
        self.join = join
        self.role = role
        self.session = session

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.join is not None:
            result['Join'] = self.join
        if self.role is not None:
            result['Role'] = self.role
        if self.session is not None:
            result['Session'] = self.session
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Join') is not None:
            self.join = m.get('Join')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Session') is not None:
            self.session = m.get('Session')
        return self


class DescribeUserInfoInChannelResponseBody(TeaModel):
    def __init__(
        self,
        is_channel_exist: bool = None,
        is_in_channel: bool = None,
        property: List[DescribeUserInfoInChannelResponseBodyProperty] = None,
        request_id: str = None,
        timestamp: int = None,
    ):
        self.is_channel_exist = is_channel_exist
        self.is_in_channel = is_in_channel
        self.property = property
        self.request_id = request_id
        self.timestamp = timestamp

    def validate(self):
        if self.property:
            for k in self.property:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_channel_exist is not None:
            result['IsChannelExist'] = self.is_channel_exist
        if self.is_in_channel is not None:
            result['IsInChannel'] = self.is_in_channel
        result['Property'] = []
        if self.property is not None:
            for k in self.property:
                result['Property'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IsChannelExist') is not None:
            self.is_channel_exist = m.get('IsChannelExist')
        if m.get('IsInChannel') is not None:
            self.is_in_channel = m.get('IsInChannel')
        self.property = []
        if m.get('Property') is not None:
            for k in m.get('Property'):
                temp_model = DescribeUserInfoInChannelResponseBodyProperty()
                self.property.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class DescribeUserInfoInChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DescribeUserInfoInChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserInfoInChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableAutoLiveStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        rule_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DisableAutoLiveStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableAutoLiveStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableAutoLiveStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableAutoLiveStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableAutoLiveStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        rule_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class EnableAutoLiveStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnableAutoLiveStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableAutoLiveStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableAutoLiveStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAgentRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
    ):
        self.app_id = app_id
        self.channel_id = channel_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetAgentResponseBody(TeaModel):
    def __init__(
        self,
        message: str = None,
        request_id: str = None,
        start_time: str = None,
        status: str = None,
        stop_time: str = None,
    ):
        self.message = message
        # Id of the request
        self.request_id = request_id
        self.start_time = start_time
        self.status = status
        self.stop_time = stop_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        return self


class GetAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMPUTaskStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetMPUTaskStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        status: int = None,
    ):
        self.request_id = request_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetMPUTaskStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMPUTaskStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMPUTaskStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_name: str = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.app_name = app_name
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class ModifyAppResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppAgentFunctionStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ModifyAppAgentFunctionStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppAgentFunctionStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppAgentFunctionStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppAgentFunctionStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppAgentTemplateRequestAgentSilenceConfig(TeaModel):
    def __init__(
        self,
        alert_timeout: int = None,
        content: str = None,
        strategy: int = None,
        webhook_trigger_timeout: int = None,
    ):
        self.alert_timeout = alert_timeout
        self.content = content
        self.strategy = strategy
        self.webhook_trigger_timeout = webhook_trigger_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_timeout is not None:
            result['AlertTimeout'] = self.alert_timeout
        if self.content is not None:
            result['Content'] = self.content
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.webhook_trigger_timeout is not None:
            result['WebhookTriggerTimeout'] = self.webhook_trigger_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertTimeout') is not None:
            self.alert_timeout = m.get('AlertTimeout')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('WebhookTriggerTimeout') is not None:
            self.webhook_trigger_timeout = m.get('WebhookTriggerTimeout')
        return self


class ModifyAppAgentTemplateRequestAsrConfigVadConfig(TeaModel):
    def __init__(
        self,
        interrupt_speech_duration: int = None,
    ):
        self.interrupt_speech_duration = interrupt_speech_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interrupt_speech_duration is not None:
            result['InterruptSpeechDuration'] = self.interrupt_speech_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InterruptSpeechDuration') is not None:
            self.interrupt_speech_duration = m.get('InterruptSpeechDuration')
        return self


class ModifyAppAgentTemplateRequestAsrConfigWordWeights(TeaModel):
    def __init__(
        self,
        lang: str = None,
        weight: int = None,
        word: str = None,
    ):
        self.lang = lang
        # This parameter is required.
        self.weight = weight
        # This parameter is required.
        self.word = word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.weight is not None:
            result['Weight'] = self.weight
        if self.word is not None:
            result['Word'] = self.word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        return self


class ModifyAppAgentTemplateRequestAsrConfig(TeaModel):
    def __init__(
        self,
        max_sentence_silence: int = None,
        name: str = None,
        vad_config: ModifyAppAgentTemplateRequestAsrConfigVadConfig = None,
        vocabulary_id: str = None,
        word_weights: List[ModifyAppAgentTemplateRequestAsrConfigWordWeights] = None,
    ):
        self.max_sentence_silence = max_sentence_silence
        # This parameter is required.
        self.name = name
        self.vad_config = vad_config
        self.vocabulary_id = vocabulary_id
        self.word_weights = word_weights

    def validate(self):
        if self.vad_config:
            self.vad_config.validate()
        if self.word_weights:
            for k in self.word_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_sentence_silence is not None:
            result['MaxSentenceSilence'] = self.max_sentence_silence
        if self.name is not None:
            result['Name'] = self.name
        if self.vad_config is not None:
            result['VadConfig'] = self.vad_config.to_map()
        if self.vocabulary_id is not None:
            result['VocabularyId'] = self.vocabulary_id
        result['WordWeights'] = []
        if self.word_weights is not None:
            for k in self.word_weights:
                result['WordWeights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaxSentenceSilence') is not None:
            self.max_sentence_silence = m.get('MaxSentenceSilence')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('VadConfig') is not None:
            temp_model = ModifyAppAgentTemplateRequestAsrConfigVadConfig()
            self.vad_config = temp_model.from_map(m['VadConfig'])
        if m.get('VocabularyId') is not None:
            self.vocabulary_id = m.get('VocabularyId')
        self.word_weights = []
        if m.get('WordWeights') is not None:
            for k in m.get('WordWeights'):
                temp_model = ModifyAppAgentTemplateRequestAsrConfigWordWeights()
                self.word_weights.append(temp_model.from_map(k))
        return self


class ModifyAppAgentTemplateRequestLlmConfig(TeaModel):
    def __init__(
        self,
        agent_app_id: str = None,
        api_key: str = None,
        history_depth: int = None,
        max_token: int = None,
        name: str = None,
        prompt: str = None,
        temperature: float = None,
        top_p: float = None,
        url: str = None,
        vendor: str = None,
    ):
        self.agent_app_id = agent_app_id
        # This parameter is required.
        self.api_key = api_key
        self.history_depth = history_depth
        self.max_token = max_token
        # This parameter is required.
        self.name = name
        self.prompt = prompt
        self.temperature = temperature
        self.top_p = top_p
        self.url = url
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_app_id is not None:
            result['AgentAppId'] = self.agent_app_id
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.history_depth is not None:
            result['HistoryDepth'] = self.history_depth
        if self.max_token is not None:
            result['MaxToken'] = self.max_token
        if self.name is not None:
            result['Name'] = self.name
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.temperature is not None:
            result['Temperature'] = self.temperature
        if self.top_p is not None:
            result['TopP'] = self.top_p
        if self.url is not None:
            result['Url'] = self.url
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentAppId') is not None:
            self.agent_app_id = m.get('AgentAppId')
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('HistoryDepth') is not None:
            self.history_depth = m.get('HistoryDepth')
        if m.get('MaxToken') is not None:
            self.max_token = m.get('MaxToken')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Temperature') is not None:
            self.temperature = m.get('Temperature')
        if m.get('TopP') is not None:
            self.top_p = m.get('TopP')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class ModifyAppAgentTemplateRequestTtsConfig(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        filter_brackets: List[int] = None,
        name: str = None,
        pitch: float = None,
        rate: float = None,
        vendor: str = None,
        voice: str = None,
        volume: int = None,
    ):
        # This parameter is required.
        self.api_key = api_key
        self.filter_brackets = filter_brackets
        # This parameter is required.
        self.name = name
        self.pitch = pitch
        self.rate = rate
        # This parameter is required.
        self.vendor = vendor
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.filter_brackets is not None:
            result['FilterBrackets'] = self.filter_brackets
        if self.name is not None:
            result['Name'] = self.name
        if self.pitch is not None:
            result['Pitch'] = self.pitch
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('FilterBrackets') is not None:
            self.filter_brackets = m.get('FilterBrackets')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Pitch') is not None:
            self.pitch = m.get('Pitch')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class ModifyAppAgentTemplateRequest(TeaModel):
    def __init__(
        self,
        agent_silence_config: ModifyAppAgentTemplateRequestAgentSilenceConfig = None,
        app_id: str = None,
        asr_config: ModifyAppAgentTemplateRequestAsrConfig = None,
        chat_mode: int = None,
        greeting: str = None,
        id: str = None,
        interrupt_mode: int = None,
        llm_config: ModifyAppAgentTemplateRequestLlmConfig = None,
        name: str = None,
        tts_config: ModifyAppAgentTemplateRequestTtsConfig = None,
        type: int = None,
    ):
        self.agent_silence_config = agent_silence_config
        # This parameter is required.
        self.app_id = app_id
        self.asr_config = asr_config
        self.chat_mode = chat_mode
        self.greeting = greeting
        # This parameter is required.
        self.id = id
        self.interrupt_mode = interrupt_mode
        self.llm_config = llm_config
        # This parameter is required.
        self.name = name
        self.tts_config = tts_config
        self.type = type

    def validate(self):
        if self.agent_silence_config:
            self.agent_silence_config.validate()
        if self.asr_config:
            self.asr_config.validate()
        if self.llm_config:
            self.llm_config.validate()
        if self.tts_config:
            self.tts_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_silence_config is not None:
            result['AgentSilenceConfig'] = self.agent_silence_config.to_map()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.asr_config is not None:
            result['AsrConfig'] = self.asr_config.to_map()
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.id is not None:
            result['Id'] = self.id
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        if self.llm_config is not None:
            result['LlmConfig'] = self.llm_config.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.tts_config is not None:
            result['TtsConfig'] = self.tts_config.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentSilenceConfig') is not None:
            temp_model = ModifyAppAgentTemplateRequestAgentSilenceConfig()
            self.agent_silence_config = temp_model.from_map(m['AgentSilenceConfig'])
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AsrConfig') is not None:
            temp_model = ModifyAppAgentTemplateRequestAsrConfig()
            self.asr_config = temp_model.from_map(m['AsrConfig'])
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        if m.get('LlmConfig') is not None:
            temp_model = ModifyAppAgentTemplateRequestLlmConfig()
            self.llm_config = temp_model.from_map(m['LlmConfig'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TtsConfig') is not None:
            temp_model = ModifyAppAgentTemplateRequestTtsConfig()
            self.tts_config = temp_model.from_map(m['TtsConfig'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyAppAgentTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        agent_silence_config_shrink: str = None,
        app_id: str = None,
        asr_config_shrink: str = None,
        chat_mode: int = None,
        greeting: str = None,
        id: str = None,
        interrupt_mode: int = None,
        llm_config_shrink: str = None,
        name: str = None,
        tts_config_shrink: str = None,
        type: int = None,
    ):
        self.agent_silence_config_shrink = agent_silence_config_shrink
        # This parameter is required.
        self.app_id = app_id
        self.asr_config_shrink = asr_config_shrink
        self.chat_mode = chat_mode
        self.greeting = greeting
        # This parameter is required.
        self.id = id
        self.interrupt_mode = interrupt_mode
        self.llm_config_shrink = llm_config_shrink
        # This parameter is required.
        self.name = name
        self.tts_config_shrink = tts_config_shrink
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_silence_config_shrink is not None:
            result['AgentSilenceConfig'] = self.agent_silence_config_shrink
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.asr_config_shrink is not None:
            result['AsrConfig'] = self.asr_config_shrink
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.id is not None:
            result['Id'] = self.id
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        if self.llm_config_shrink is not None:
            result['LlmConfig'] = self.llm_config_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.tts_config_shrink is not None:
            result['TtsConfig'] = self.tts_config_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AgentSilenceConfig') is not None:
            self.agent_silence_config_shrink = m.get('AgentSilenceConfig')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AsrConfig') is not None:
            self.asr_config_shrink = m.get('AsrConfig')
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        if m.get('LlmConfig') is not None:
            self.llm_config_shrink = m.get('LlmConfig')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TtsConfig') is not None:
            self.tts_config_shrink = m.get('TtsConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyAppAgentTemplateResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppAgentTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppAgentTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppAgentTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppCallbackStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class ModifyAppCallbackStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppCallbackStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppCallbackStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppCallbackStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppLayoutRequestLayoutPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class ModifyAppLayoutRequestLayout(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        name: str = None,
        panes: List[ModifyAppLayoutRequestLayoutPanes] = None,
    ):
        # This parameter is required.
        self.layout_id = layout_id
        # This parameter is required.
        self.name = name
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = ModifyAppLayoutRequestLayoutPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class ModifyAppLayoutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        layout: ModifyAppLayoutRequestLayout = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.layout = layout

    def validate(self):
        if self.layout:
            self.layout.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.layout is not None:
            result['Layout'] = self.layout.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Layout') is not None:
            temp_model = ModifyAppLayoutRequestLayout()
            self.layout = temp_model.from_map(m['Layout'])
        return self


class ModifyAppLayoutShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        layout_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.layout_shrink = layout_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.layout_shrink is not None:
            result['Layout'] = self.layout_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Layout') is not None:
            self.layout_shrink = m.get('Layout')
        return self


class ModifyAppLayoutResponseBody(TeaModel):
    def __init__(
        self,
        layout_id: str = None,
        request_id: str = None,
    ):
        self.layout_id = layout_id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppLayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppLayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppLayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppLiveStreamStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class ModifyAppLiveStreamStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppLiveStreamStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppLiveStreamStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppLiveStreamStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppRecordStatusRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        return self


class ModifyAppRecordStatusResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppRecordStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppRecordStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppRecordStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppRecordTemplateRequestRecordTemplate(TeaModel):
    def __init__(
        self,
        delay_stop_time: int = None,
        file_prefix: str = None,
        file_split_interval: int = None,
        formats: List[str] = None,
        layout_ids: List[str] = None,
        media_encode: int = None,
        name: str = None,
        template_id: str = None,
    ):
        self.delay_stop_time = delay_stop_time
        # This parameter is required.
        self.file_prefix = file_prefix
        # This parameter is required.
        self.file_split_interval = file_split_interval
        # This parameter is required.
        self.formats = formats
        # This parameter is required.
        self.layout_ids = layout_ids
        # This parameter is required.
        self.media_encode = media_encode
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delay_stop_time is not None:
            result['DelayStopTime'] = self.delay_stop_time
        if self.file_prefix is not None:
            result['FilePrefix'] = self.file_prefix
        if self.file_split_interval is not None:
            result['FileSplitInterval'] = self.file_split_interval
        if self.formats is not None:
            result['Formats'] = self.formats
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DelayStopTime') is not None:
            self.delay_stop_time = m.get('DelayStopTime')
        if m.get('FilePrefix') is not None:
            self.file_prefix = m.get('FilePrefix')
        if m.get('FileSplitInterval') is not None:
            self.file_split_interval = m.get('FileSplitInterval')
        if m.get('Formats') is not None:
            self.formats = m.get('Formats')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ModifyAppRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        record_template: ModifyAppRecordTemplateRequestRecordTemplate = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.record_template = record_template

    def validate(self):
        if self.record_template:
            self.record_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.record_template is not None:
            result['RecordTemplate'] = self.record_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('RecordTemplate') is not None:
            temp_model = ModifyAppRecordTemplateRequestRecordTemplate()
            self.record_template = temp_model.from_map(m['RecordTemplate'])
        return self


class ModifyAppRecordTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        client_token: str = None,
        record_template_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.client_token = client_token
        # This parameter is required.
        self.record_template_shrink = record_template_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.record_template_shrink is not None:
            result['RecordTemplate'] = self.record_template_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('RecordTemplate') is not None:
            self.record_template_shrink = m.get('RecordTemplate')
        return self


class ModifyAppRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAppRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAppStreamingOutTemplateRequestStreamingOutTemplate(TeaModel):
    def __init__(
        self,
        layout_ids: List[str] = None,
        media_encode: int = None,
        name: str = None,
        template_id: str = None,
    ):
        # This parameter is required.
        self.layout_ids = layout_ids
        # This parameter is required.
        self.media_encode = media_encode
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.name is not None:
            result['Name'] = self.name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ModifyAppStreamingOutTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        streaming_out_template: ModifyAppStreamingOutTemplateRequestStreamingOutTemplate = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.streaming_out_template = streaming_out_template

    def validate(self):
        if self.streaming_out_template:
            self.streaming_out_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.streaming_out_template is not None:
            result['StreamingOutTemplate'] = self.streaming_out_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('StreamingOutTemplate') is not None:
            temp_model = ModifyAppStreamingOutTemplateRequestStreamingOutTemplate()
            self.streaming_out_template = temp_model.from_map(m['StreamingOutTemplate'])
        return self


class ModifyAppStreamingOutTemplateShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        streaming_out_template_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.streaming_out_template_shrink = streaming_out_template_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.streaming_out_template_shrink is not None:
            result['StreamingOutTemplate'] = self.streaming_out_template_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('StreamingOutTemplate') is not None:
            self.streaming_out_template_shrink = m.get('StreamingOutTemplate')
        return self


class ModifyAppStreamingOutTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ModifyAppStreamingOutTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyAppStreamingOutTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAppStreamingOutTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCallbackMetaRequestCallback(TeaModel):
    def __init__(
        self,
        category: str = None,
        conf: str = None,
        sub_event: List[int] = None,
    ):
        # This parameter is required.
        self.category = category
        # This parameter is required.
        self.conf = conf
        self.sub_event = sub_event

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.conf is not None:
            result['Conf'] = self.conf
        if self.sub_event is not None:
            result['SubEvent'] = self.sub_event
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Conf') is not None:
            self.conf = m.get('Conf')
        if m.get('SubEvent') is not None:
            self.sub_event = m.get('SubEvent')
        return self


class ModifyCallbackMetaRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback: ModifyCallbackMetaRequestCallback = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback = callback
        self.owner_id = owner_id

    def validate(self):
        if self.callback:
            self.callback.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback is not None:
            result['Callback'] = self.callback.to_map()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callback') is not None:
            temp_model = ModifyCallbackMetaRequestCallback()
            self.callback = temp_model.from_map(m['Callback'])
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class ModifyCallbackMetaShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_shrink: str = None,
        owner_id: int = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback_shrink = callback_shrink
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_shrink is not None:
            result['Callback'] = self.callback_shrink
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callback') is not None:
            self.callback_shrink = m.get('Callback')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class ModifyCallbackMetaResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        http_status_code: int = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # code
        self.code = code
        # httpStatusCode
        self.http_status_code = http_status_code
        # message
        self.message = message
        # requestId
        self.request_id = request_id
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyCallbackMetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCallbackMetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCallbackMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCloudNotePhrasesRequestPhraseWordWeights(TeaModel):
    def __init__(
        self,
        weight: int = None,
        word: str = None,
    ):
        # This parameter is required.
        self.weight = weight
        # This parameter is required.
        self.word = word

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.weight is not None:
            result['Weight'] = self.weight
        if self.word is not None:
            result['Word'] = self.word
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        if m.get('Word') is not None:
            self.word = m.get('Word')
        return self


class ModifyCloudNotePhrasesRequestPhrase(TeaModel):
    def __init__(
        self,
        description: str = None,
        id: str = None,
        name: str = None,
        word_weights: List[ModifyCloudNotePhrasesRequestPhraseWordWeights] = None,
    ):
        self.description = description
        # This parameter is required.
        self.id = id
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.word_weights = word_weights

    def validate(self):
        if self.word_weights:
            for k in self.word_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        result['WordWeights'] = []
        if self.word_weights is not None:
            for k in self.word_weights:
                result['WordWeights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.word_weights = []
        if m.get('WordWeights') is not None:
            for k in m.get('WordWeights'):
                temp_model = ModifyCloudNotePhrasesRequestPhraseWordWeights()
                self.word_weights.append(temp_model.from_map(k))
        return self


class ModifyCloudNotePhrasesRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        phrase: ModifyCloudNotePhrasesRequestPhrase = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.phrase = phrase

    def validate(self):
        if self.phrase:
            self.phrase.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.phrase is not None:
            result['Phrase'] = self.phrase.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Phrase') is not None:
            temp_model = ModifyCloudNotePhrasesRequestPhrase()
            self.phrase = temp_model.from_map(m['Phrase'])
        return self


class ModifyCloudNotePhrasesShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        phrase_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.phrase_shrink = phrase_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.phrase_shrink is not None:
            result['Phrase'] = self.phrase_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Phrase') is not None:
            self.phrase_shrink = m.get('Phrase')
        return self


class ModifyCloudNotePhrasesResponseBody(TeaModel):
    def __init__(
        self,
        id: str = None,
        request_id: str = None,
    ):
        self.id = id
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCloudNotePhrasesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyCloudNotePhrasesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCloudNotePhrasesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyMPULayoutRequestPanes(TeaModel):
    def __init__(
        self,
        height: float = None,
        major_pane: int = None,
        pane_id: int = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.height = height
        self.major_pane = major_pane
        self.pane_id = pane_id
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.height is not None:
            result['Height'] = self.height
        if self.major_pane is not None:
            result['MajorPane'] = self.major_pane
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MajorPane') is not None:
            self.major_pane = m.get('MajorPane')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class ModifyMPULayoutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        audio_mix_count: int = None,
        layout_id: int = None,
        name: str = None,
        owner_id: int = None,
        panes: List[ModifyMPULayoutRequestPanes] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.audio_mix_count = audio_mix_count
        # This parameter is required.
        self.layout_id = layout_id
        self.name = name
        self.owner_id = owner_id
        self.panes = panes

    def validate(self):
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.audio_mix_count is not None:
            result['AudioMixCount'] = self.audio_mix_count
        if self.layout_id is not None:
            result['LayoutId'] = self.layout_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AudioMixCount') is not None:
            self.audio_mix_count = m.get('AudioMixCount')
        if m.get('LayoutId') is not None:
            self.layout_id = m.get('LayoutId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = ModifyMPULayoutRequestPanes()
                self.panes.append(temp_model.from_map(k))
        return self


class ModifyMPULayoutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyMPULayoutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyMPULayoutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyMPULayoutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class NotifyAgentRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        custom_attribute: str = None,
        interruptable: bool = None,
        message: str = None,
        priority: int = None,
        task_id: str = None,
    ):
        self.app_id = app_id
        self.channel_id = channel_id
        self.custom_attribute = custom_attribute
        self.interruptable = interruptable
        self.message = message
        self.priority = priority
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.custom_attribute is not None:
            result['CustomAttribute'] = self.custom_attribute
        if self.interruptable is not None:
            result['Interruptable'] = self.interruptable
        if self.message is not None:
            result['Message'] = self.message
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CustomAttribute') is not None:
            self.custom_attribute = m.get('CustomAttribute')
        if m.get('Interruptable') is not None:
            self.interruptable = m.get('Interruptable')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class NotifyAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class NotifyAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: NotifyAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = NotifyAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTerminalsRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        owner_id: int = None,
        terminal_ids: List[str] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.owner_id = owner_id
        # This parameter is required.
        self.terminal_ids = terminal_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.terminal_ids is not None:
            result['TerminalIds'] = self.terminal_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TerminalIds') is not None:
            self.terminal_ids = m.get('TerminalIds')
        return self


class RemoveTerminalsResponseBodyTerminalsTerminal(TeaModel):
    def __init__(
        self,
        code: int = None,
        id: str = None,
        message: str = None,
    ):
        self.code = code
        self.id = id
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class RemoveTerminalsResponseBodyTerminals(TeaModel):
    def __init__(
        self,
        terminal: List[RemoveTerminalsResponseBodyTerminalsTerminal] = None,
    ):
        self.terminal = terminal

    def validate(self):
        if self.terminal:
            for k in self.terminal:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Terminal'] = []
        if self.terminal is not None:
            for k in self.terminal:
                result['Terminal'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.terminal = []
        if m.get('Terminal') is not None:
            for k in m.get('Terminal'):
                temp_model = RemoveTerminalsResponseBodyTerminalsTerminal()
                self.terminal.append(temp_model.from_map(k))
        return self


class RemoveTerminalsResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        terminals: RemoveTerminalsResponseBodyTerminals = None,
    ):
        self.request_id = request_id
        self.terminals = terminals

    def validate(self):
        if self.terminals:
            self.terminals.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.terminals is not None:
            result['Terminals'] = self.terminals.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Terminals') is not None:
            temp_model = RemoveTerminalsResponseBodyTerminals()
            self.terminals = temp_model.from_map(m['Terminals'])
        return self


class RemoveTerminalsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveTerminalsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTerminalsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveUsersRequestUsers(TeaModel):
    def __init__(
        self,
        user_id: str = None,
    ):
        # This parameter is required.
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RemoveUsersRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        users: List[RemoveUsersRequestUsers] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = RemoveUsersRequestUsers()
                self.users.append(temp_model.from_map(k))
        return self


class RemoveUsersResponseBodyUsers(TeaModel):
    def __init__(
        self,
        code: int = None,
        message: str = None,
        user_id: str = None,
    ):
        self.code = code
        self.message = message
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class RemoveUsersResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        users: List[RemoveUsersResponseBodyUsers] = None,
    ):
        self.request_id = request_id
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = RemoveUsersResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class RemoveUsersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveUsersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartAgentRequestRtcConfig(TeaModel):
    def __init__(
        self,
        target_user_ids: List[str] = None,
        user_id: str = None,
        user_inactivity_timeout: int = None,
    ):
        self.target_user_ids = target_user_ids
        # This parameter is required.
        self.user_id = user_id
        self.user_inactivity_timeout = user_inactivity_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_user_ids is not None:
            result['TargetUserIds'] = self.target_user_ids
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_inactivity_timeout is not None:
            result['UserInactivityTimeout'] = self.user_inactivity_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetUserIds') is not None:
            self.target_user_ids = m.get('TargetUserIds')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserInactivityTimeout') is not None:
            self.user_inactivity_timeout = m.get('UserInactivityTimeout')
        return self


class StartAgentRequestVoiceChatConfigASRConfigVadConfig(TeaModel):
    def __init__(
        self,
        interrupt_speech_duration: int = None,
    ):
        self.interrupt_speech_duration = interrupt_speech_duration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.interrupt_speech_duration is not None:
            result['InterruptSpeechDuration'] = self.interrupt_speech_duration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InterruptSpeechDuration') is not None:
            self.interrupt_speech_duration = m.get('InterruptSpeechDuration')
        return self


class StartAgentRequestVoiceChatConfigASRConfig(TeaModel):
    def __init__(
        self,
        language_hints: List[str] = None,
        max_sentence_silence: int = None,
        semantic_punctuation_enabled: bool = None,
        source_language: str = None,
        vad_config: StartAgentRequestVoiceChatConfigASRConfigVadConfig = None,
        vocabulary_id: str = None,
    ):
        self.language_hints = language_hints
        self.max_sentence_silence = max_sentence_silence
        self.semantic_punctuation_enabled = semantic_punctuation_enabled
        self.source_language = source_language
        self.vad_config = vad_config
        self.vocabulary_id = vocabulary_id

    def validate(self):
        if self.vad_config:
            self.vad_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.language_hints is not None:
            result['LanguageHints'] = self.language_hints
        if self.max_sentence_silence is not None:
            result['MaxSentenceSilence'] = self.max_sentence_silence
        if self.semantic_punctuation_enabled is not None:
            result['SemanticPunctuationEnabled'] = self.semantic_punctuation_enabled
        if self.source_language is not None:
            result['SourceLanguage'] = self.source_language
        if self.vad_config is not None:
            result['VadConfig'] = self.vad_config.to_map()
        if self.vocabulary_id is not None:
            result['VocabularyId'] = self.vocabulary_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LanguageHints') is not None:
            self.language_hints = m.get('LanguageHints')
        if m.get('MaxSentenceSilence') is not None:
            self.max_sentence_silence = m.get('MaxSentenceSilence')
        if m.get('SemanticPunctuationEnabled') is not None:
            self.semantic_punctuation_enabled = m.get('SemanticPunctuationEnabled')
        if m.get('SourceLanguage') is not None:
            self.source_language = m.get('SourceLanguage')
        if m.get('VadConfig') is not None:
            temp_model = StartAgentRequestVoiceChatConfigASRConfigVadConfig()
            self.vad_config = temp_model.from_map(m['VadConfig'])
        if m.get('VocabularyId') is not None:
            self.vocabulary_id = m.get('VocabularyId')
        return self


class StartAgentRequestVoiceChatConfigAgentSilenceConfig(TeaModel):
    def __init__(
        self,
        alert_timeout: int = None,
        content: str = None,
        enable: bool = None,
        strategy: int = None,
        webhook_trigger_timeout: int = None,
    ):
        self.alert_timeout = alert_timeout
        self.content = content
        self.enable = enable
        self.strategy = strategy
        self.webhook_trigger_timeout = webhook_trigger_timeout

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_timeout is not None:
            result['AlertTimeout'] = self.alert_timeout
        if self.content is not None:
            result['Content'] = self.content
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.webhook_trigger_timeout is not None:
            result['WebhookTriggerTimeout'] = self.webhook_trigger_timeout
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlertTimeout') is not None:
            self.alert_timeout = m.get('AlertTimeout')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('WebhookTriggerTimeout') is not None:
            self.webhook_trigger_timeout = m.get('WebhookTriggerTimeout')
        return self


class StartAgentRequestVoiceChatConfigLLMConfig(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        app_id: str = None,
        history_depth: int = None,
        max_token: int = None,
        model: str = None,
        params: Dict[str, Any] = None,
        prompt: str = None,
        temperature: float = None,
        top_p: float = None,
        url: str = None,
        vendor: str = None,
    ):
        self.api_key = api_key
        self.app_id = app_id
        self.history_depth = history_depth
        self.max_token = max_token
        self.model = model
        self.params = params
        self.prompt = prompt
        self.temperature = temperature
        self.top_p = top_p
        self.url = url
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.history_depth is not None:
            result['HistoryDepth'] = self.history_depth
        if self.max_token is not None:
            result['MaxToken'] = self.max_token
        if self.model is not None:
            result['Model'] = self.model
        if self.params is not None:
            result['Params'] = self.params
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.temperature is not None:
            result['Temperature'] = self.temperature
        if self.top_p is not None:
            result['TopP'] = self.top_p
        if self.url is not None:
            result['Url'] = self.url
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('HistoryDepth') is not None:
            self.history_depth = m.get('HistoryDepth')
        if m.get('MaxToken') is not None:
            self.max_token = m.get('MaxToken')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('Temperature') is not None:
            self.temperature = m.get('Temperature')
        if m.get('TopP') is not None:
            self.top_p = m.get('TopP')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class StartAgentRequestVoiceChatConfigTTSConfig(TeaModel):
    def __init__(
        self,
        api_key: str = None,
        filter_brackets: List[int] = None,
        model: str = None,
        pitch: float = None,
        rate: float = None,
        vendor: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.api_key = api_key
        self.filter_brackets = filter_brackets
        self.model = model
        self.pitch = pitch
        self.rate = rate
        self.vendor = vendor
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_key is not None:
            result['ApiKey'] = self.api_key
        if self.filter_brackets is not None:
            result['FilterBrackets'] = self.filter_brackets
        if self.model is not None:
            result['Model'] = self.model
        if self.pitch is not None:
            result['Pitch'] = self.pitch
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiKey') is not None:
            self.api_key = m.get('ApiKey')
        if m.get('FilterBrackets') is not None:
            self.filter_brackets = m.get('FilterBrackets')
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Pitch') is not None:
            self.pitch = m.get('Pitch')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class StartAgentRequestVoiceChatConfig(TeaModel):
    def __init__(
        self,
        asrconfig: StartAgentRequestVoiceChatConfigASRConfig = None,
        agent_silence_config: StartAgentRequestVoiceChatConfigAgentSilenceConfig = None,
        chat_mode: int = None,
        greeting: str = None,
        interrupt_mode: int = None,
        llmconfig: StartAgentRequestVoiceChatConfigLLMConfig = None,
        ttsconfig: StartAgentRequestVoiceChatConfigTTSConfig = None,
    ):
        self.asrconfig = asrconfig
        self.agent_silence_config = agent_silence_config
        self.chat_mode = chat_mode
        self.greeting = greeting
        self.interrupt_mode = interrupt_mode
        self.llmconfig = llmconfig
        self.ttsconfig = ttsconfig

    def validate(self):
        if self.asrconfig:
            self.asrconfig.validate()
        if self.agent_silence_config:
            self.agent_silence_config.validate()
        if self.llmconfig:
            self.llmconfig.validate()
        if self.ttsconfig:
            self.ttsconfig.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asrconfig is not None:
            result['ASRConfig'] = self.asrconfig.to_map()
        if self.agent_silence_config is not None:
            result['AgentSilenceConfig'] = self.agent_silence_config.to_map()
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.greeting is not None:
            result['Greeting'] = self.greeting
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        if self.llmconfig is not None:
            result['LLMConfig'] = self.llmconfig.to_map()
        if self.ttsconfig is not None:
            result['TTSConfig'] = self.ttsconfig.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ASRConfig') is not None:
            temp_model = StartAgentRequestVoiceChatConfigASRConfig()
            self.asrconfig = temp_model.from_map(m['ASRConfig'])
        if m.get('AgentSilenceConfig') is not None:
            temp_model = StartAgentRequestVoiceChatConfigAgentSilenceConfig()
            self.agent_silence_config = temp_model.from_map(m['AgentSilenceConfig'])
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('Greeting') is not None:
            self.greeting = m.get('Greeting')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        if m.get('LLMConfig') is not None:
            temp_model = StartAgentRequestVoiceChatConfigLLMConfig()
            self.llmconfig = temp_model.from_map(m['LLMConfig'])
        if m.get('TTSConfig') is not None:
            temp_model = StartAgentRequestVoiceChatConfigTTSConfig()
            self.ttsconfig = temp_model.from_map(m['TTSConfig'])
        return self


class StartAgentRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        rtc_config: StartAgentRequestRtcConfig = None,
        task_id: str = None,
        template_id: str = None,
        voice_chat_config: StartAgentRequestVoiceChatConfig = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.rtc_config = rtc_config
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.voice_chat_config = voice_chat_config

    def validate(self):
        if self.rtc_config:
            self.rtc_config.validate()
        if self.voice_chat_config:
            self.voice_chat_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.rtc_config is not None:
            result['RtcConfig'] = self.rtc_config.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.voice_chat_config is not None:
            result['VoiceChatConfig'] = self.voice_chat_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('RtcConfig') is not None:
            temp_model = StartAgentRequestRtcConfig()
            self.rtc_config = temp_model.from_map(m['RtcConfig'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('VoiceChatConfig') is not None:
            temp_model = StartAgentRequestVoiceChatConfig()
            self.voice_chat_config = temp_model.from_map(m['VoiceChatConfig'])
        return self


class StartAgentShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        rtc_config_shrink: str = None,
        task_id: str = None,
        template_id: str = None,
        voice_chat_config_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.rtc_config_shrink = rtc_config_shrink
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.voice_chat_config_shrink = voice_chat_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.rtc_config_shrink is not None:
            result['RtcConfig'] = self.rtc_config_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.voice_chat_config_shrink is not None:
            result['VoiceChatConfig'] = self.voice_chat_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('RtcConfig') is not None:
            self.rtc_config_shrink = m.get('RtcConfig')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('VoiceChatConfig') is not None:
            self.voice_chat_config_shrink = m.get('VoiceChatConfig')
        return self


class StartAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartCategoryCallbackRequestCallback(TeaModel):
    def __init__(
        self,
        category: str = None,
    ):
        # This parameter is required.
        self.category = category

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        return self


class StartCategoryCallbackRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback: StartCategoryCallbackRequestCallback = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback = callback

    def validate(self):
        if self.callback:
            self.callback.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback is not None:
            result['Callback'] = self.callback.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callback') is not None:
            temp_model = StartCategoryCallbackRequestCallback()
            self.callback = temp_model.from_map(m['Callback'])
        return self


class StartCategoryCallbackShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback_shrink = callback_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_shrink is not None:
            result['Callback'] = self.callback_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callback') is not None:
            self.callback_shrink = m.get('Callback')
        return self


class StartCategoryCallbackResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartCategoryCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartCategoryCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartCategoryCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartCloudNoteRequestAutoChapters(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
    ):
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        return self


class StartCloudNoteRequestCustomPromptCustomPromptContents(TeaModel):
    def __init__(
        self,
        model: str = None,
        name: str = None,
        prompt: str = None,
        trans_type: str = None,
    ):
        self.model = model
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.prompt = prompt
        self.trans_type = trans_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.model is not None:
            result['Model'] = self.model
        if self.name is not None:
            result['Name'] = self.name
        if self.prompt is not None:
            result['Prompt'] = self.prompt
        if self.trans_type is not None:
            result['TransType'] = self.trans_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Model') is not None:
            self.model = m.get('Model')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Prompt') is not None:
            self.prompt = m.get('Prompt')
        if m.get('TransType') is not None:
            self.trans_type = m.get('TransType')
        return self


class StartCloudNoteRequestCustomPrompt(TeaModel):
    def __init__(
        self,
        custom_prompt_contents: List[StartCloudNoteRequestCustomPromptCustomPromptContents] = None,
        enabled: bool = None,
    ):
        # This parameter is required.
        self.custom_prompt_contents = custom_prompt_contents
        self.enabled = enabled

    def validate(self):
        if self.custom_prompt_contents:
            for k in self.custom_prompt_contents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomPromptContents'] = []
        if self.custom_prompt_contents is not None:
            for k in self.custom_prompt_contents:
                result['CustomPromptContents'].append(k.to_map() if k else None)
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_prompt_contents = []
        if m.get('CustomPromptContents') is not None:
            for k in m.get('CustomPromptContents'):
                temp_model = StartCloudNoteRequestCustomPromptCustomPromptContents()
                self.custom_prompt_contents.append(temp_model.from_map(k))
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        return self


class StartCloudNoteRequestMeetingAssistance(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        meeting_assistance_type: List[str] = None,
    ):
        self.enabled = enabled
        # This parameter is required.
        self.meeting_assistance_type = meeting_assistance_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.meeting_assistance_type is not None:
            result['MeetingAssistanceType'] = self.meeting_assistance_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MeetingAssistanceType') is not None:
            self.meeting_assistance_type = m.get('MeetingAssistanceType')
        return self


class StartCloudNoteRequestRealtimeSubtitleTranslation(TeaModel):
    def __init__(
        self,
        translate_level: int = None,
    ):
        self.translate_level = translate_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.translate_level is not None:
            result['TranslateLevel'] = self.translate_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TranslateLevel') is not None:
            self.translate_level = m.get('TranslateLevel')
        return self


class StartCloudNoteRequestRealtimeSubtitle(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        translation: StartCloudNoteRequestRealtimeSubtitleTranslation = None,
    ):
        self.enabled = enabled
        self.translation = translation

    def validate(self):
        if self.translation:
            self.translation.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.translation is not None:
            result['Translation'] = self.translation.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Translation') is not None:
            temp_model = StartCloudNoteRequestRealtimeSubtitleTranslation()
            self.translation = temp_model.from_map(m['Translation'])
        return self


class StartCloudNoteRequestServiceInspectionInspectionContents(TeaModel):
    def __init__(
        self,
        content: str = None,
        title: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class StartCloudNoteRequestServiceInspection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        inspection_contents: List[StartCloudNoteRequestServiceInspectionInspectionContents] = None,
        inspection_introduction: str = None,
        scene_introduction: str = None,
    ):
        self.enabled = enabled
        # This parameter is required.
        self.inspection_contents = inspection_contents
        # This parameter is required.
        self.inspection_introduction = inspection_introduction
        # This parameter is required.
        self.scene_introduction = scene_introduction

    def validate(self):
        if self.inspection_contents:
            for k in self.inspection_contents:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        result['InspectionContents'] = []
        if self.inspection_contents is not None:
            for k in self.inspection_contents:
                result['InspectionContents'].append(k.to_map() if k else None)
        if self.inspection_introduction is not None:
            result['InspectionIntroduction'] = self.inspection_introduction
        if self.scene_introduction is not None:
            result['SceneIntroduction'] = self.scene_introduction
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        self.inspection_contents = []
        if m.get('InspectionContents') is not None:
            for k in m.get('InspectionContents'):
                temp_model = StartCloudNoteRequestServiceInspectionInspectionContents()
                self.inspection_contents.append(temp_model.from_map(k))
        if m.get('InspectionIntroduction') is not None:
            self.inspection_introduction = m.get('InspectionIntroduction')
        if m.get('SceneIntroduction') is not None:
            self.scene_introduction = m.get('SceneIntroduction')
        return self


class StartCloudNoteRequestStorageConfig(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        bucket: str = None,
        region: int = None,
        secret_key: str = None,
        vendor: int = None,
    ):
        # accessKey。
        # 
        # This parameter is required.
        self.access_key = access_key
        # This parameter is required.
        self.bucket = bucket
        # This parameter is required.
        self.region = region
        # secretKey。
        # 
        # This parameter is required.
        self.secret_key = secret_key
        # This parameter is required.
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.region is not None:
            result['Region'] = self.region
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class StartCloudNoteRequestSummarization(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        type: List[str] = None,
    ):
        self.enabled = enabled
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StartCloudNoteRequestTextPolish(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
    ):
        self.enabled = enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        return self


class StartCloudNoteRequestTranscription(TeaModel):
    def __init__(
        self,
        diarization_enabled: bool = None,
        phrase_id: str = None,
        speaker_count: int = None,
        transcription_level: int = None,
    ):
        self.diarization_enabled = diarization_enabled
        self.phrase_id = phrase_id
        self.speaker_count = speaker_count
        self.transcription_level = transcription_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.diarization_enabled is not None:
            result['DiarizationEnabled'] = self.diarization_enabled
        if self.phrase_id is not None:
            result['PhraseId'] = self.phrase_id
        if self.speaker_count is not None:
            result['SpeakerCount'] = self.speaker_count
        if self.transcription_level is not None:
            result['TranscriptionLevel'] = self.transcription_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DiarizationEnabled') is not None:
            self.diarization_enabled = m.get('DiarizationEnabled')
        if m.get('PhraseId') is not None:
            self.phrase_id = m.get('PhraseId')
        if m.get('SpeakerCount') is not None:
            self.speaker_count = m.get('SpeakerCount')
        if m.get('TranscriptionLevel') is not None:
            self.transcription_level = m.get('TranscriptionLevel')
        return self


class StartCloudNoteRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_chapters: StartCloudNoteRequestAutoChapters = None,
        channel_id: str = None,
        custom_prompt: StartCloudNoteRequestCustomPrompt = None,
        language_hints: List[str] = None,
        meeting_assistance: StartCloudNoteRequestMeetingAssistance = None,
        realtime_subtitle: StartCloudNoteRequestRealtimeSubtitle = None,
        service_inspection: StartCloudNoteRequestServiceInspection = None,
        source_language: str = None,
        storage_config: StartCloudNoteRequestStorageConfig = None,
        summarization: StartCloudNoteRequestSummarization = None,
        task_id: str = None,
        text_polish: StartCloudNoteRequestTextPolish = None,
        transcription: StartCloudNoteRequestTranscription = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.auto_chapters = auto_chapters
        # This parameter is required.
        self.channel_id = channel_id
        self.custom_prompt = custom_prompt
        self.language_hints = language_hints
        self.meeting_assistance = meeting_assistance
        self.realtime_subtitle = realtime_subtitle
        self.service_inspection = service_inspection
        self.source_language = source_language
        # This parameter is required.
        self.storage_config = storage_config
        self.summarization = summarization
        # This parameter is required.
        self.task_id = task_id
        self.text_polish = text_polish
        self.transcription = transcription

    def validate(self):
        if self.auto_chapters:
            self.auto_chapters.validate()
        if self.custom_prompt:
            self.custom_prompt.validate()
        if self.meeting_assistance:
            self.meeting_assistance.validate()
        if self.realtime_subtitle:
            self.realtime_subtitle.validate()
        if self.service_inspection:
            self.service_inspection.validate()
        if self.storage_config:
            self.storage_config.validate()
        if self.summarization:
            self.summarization.validate()
        if self.text_polish:
            self.text_polish.validate()
        if self.transcription:
            self.transcription.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_chapters is not None:
            result['AutoChapters'] = self.auto_chapters.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.custom_prompt is not None:
            result['CustomPrompt'] = self.custom_prompt.to_map()
        if self.language_hints is not None:
            result['LanguageHints'] = self.language_hints
        if self.meeting_assistance is not None:
            result['MeetingAssistance'] = self.meeting_assistance.to_map()
        if self.realtime_subtitle is not None:
            result['RealtimeSubtitle'] = self.realtime_subtitle.to_map()
        if self.service_inspection is not None:
            result['ServiceInspection'] = self.service_inspection.to_map()
        if self.source_language is not None:
            result['SourceLanguage'] = self.source_language
        if self.storage_config is not None:
            result['StorageConfig'] = self.storage_config.to_map()
        if self.summarization is not None:
            result['Summarization'] = self.summarization.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.text_polish is not None:
            result['TextPolish'] = self.text_polish.to_map()
        if self.transcription is not None:
            result['Transcription'] = self.transcription.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoChapters') is not None:
            temp_model = StartCloudNoteRequestAutoChapters()
            self.auto_chapters = temp_model.from_map(m['AutoChapters'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CustomPrompt') is not None:
            temp_model = StartCloudNoteRequestCustomPrompt()
            self.custom_prompt = temp_model.from_map(m['CustomPrompt'])
        if m.get('LanguageHints') is not None:
            self.language_hints = m.get('LanguageHints')
        if m.get('MeetingAssistance') is not None:
            temp_model = StartCloudNoteRequestMeetingAssistance()
            self.meeting_assistance = temp_model.from_map(m['MeetingAssistance'])
        if m.get('RealtimeSubtitle') is not None:
            temp_model = StartCloudNoteRequestRealtimeSubtitle()
            self.realtime_subtitle = temp_model.from_map(m['RealtimeSubtitle'])
        if m.get('ServiceInspection') is not None:
            temp_model = StartCloudNoteRequestServiceInspection()
            self.service_inspection = temp_model.from_map(m['ServiceInspection'])
        if m.get('SourceLanguage') is not None:
            self.source_language = m.get('SourceLanguage')
        if m.get('StorageConfig') is not None:
            temp_model = StartCloudNoteRequestStorageConfig()
            self.storage_config = temp_model.from_map(m['StorageConfig'])
        if m.get('Summarization') is not None:
            temp_model = StartCloudNoteRequestSummarization()
            self.summarization = temp_model.from_map(m['Summarization'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TextPolish') is not None:
            temp_model = StartCloudNoteRequestTextPolish()
            self.text_polish = temp_model.from_map(m['TextPolish'])
        if m.get('Transcription') is not None:
            temp_model = StartCloudNoteRequestTranscription()
            self.transcription = temp_model.from_map(m['Transcription'])
        return self


class StartCloudNoteShrinkRequestStorageConfig(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        bucket: str = None,
        region: int = None,
        secret_key: str = None,
        vendor: int = None,
    ):
        # accessKey。
        # 
        # This parameter is required.
        self.access_key = access_key
        # This parameter is required.
        self.bucket = bucket
        # This parameter is required.
        self.region = region
        # secretKey。
        # 
        # This parameter is required.
        self.secret_key = secret_key
        # This parameter is required.
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.region is not None:
            result['Region'] = self.region
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class StartCloudNoteShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auto_chapters_shrink: str = None,
        channel_id: str = None,
        custom_prompt_shrink: str = None,
        language_hints: List[str] = None,
        meeting_assistance_shrink: str = None,
        realtime_subtitle_shrink: str = None,
        service_inspection_shrink: str = None,
        source_language: str = None,
        storage_config: StartCloudNoteShrinkRequestStorageConfig = None,
        summarization_shrink: str = None,
        task_id: str = None,
        text_polish_shrink: str = None,
        transcription_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.auto_chapters_shrink = auto_chapters_shrink
        # This parameter is required.
        self.channel_id = channel_id
        self.custom_prompt_shrink = custom_prompt_shrink
        self.language_hints = language_hints
        self.meeting_assistance_shrink = meeting_assistance_shrink
        self.realtime_subtitle_shrink = realtime_subtitle_shrink
        self.service_inspection_shrink = service_inspection_shrink
        self.source_language = source_language
        # This parameter is required.
        self.storage_config = storage_config
        self.summarization_shrink = summarization_shrink
        # This parameter is required.
        self.task_id = task_id
        self.text_polish_shrink = text_polish_shrink
        self.transcription_shrink = transcription_shrink

    def validate(self):
        if self.storage_config:
            self.storage_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auto_chapters_shrink is not None:
            result['AutoChapters'] = self.auto_chapters_shrink
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.custom_prompt_shrink is not None:
            result['CustomPrompt'] = self.custom_prompt_shrink
        if self.language_hints is not None:
            result['LanguageHints'] = self.language_hints
        if self.meeting_assistance_shrink is not None:
            result['MeetingAssistance'] = self.meeting_assistance_shrink
        if self.realtime_subtitle_shrink is not None:
            result['RealtimeSubtitle'] = self.realtime_subtitle_shrink
        if self.service_inspection_shrink is not None:
            result['ServiceInspection'] = self.service_inspection_shrink
        if self.source_language is not None:
            result['SourceLanguage'] = self.source_language
        if self.storage_config is not None:
            result['StorageConfig'] = self.storage_config.to_map()
        if self.summarization_shrink is not None:
            result['Summarization'] = self.summarization_shrink
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.text_polish_shrink is not None:
            result['TextPolish'] = self.text_polish_shrink
        if self.transcription_shrink is not None:
            result['Transcription'] = self.transcription_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AutoChapters') is not None:
            self.auto_chapters_shrink = m.get('AutoChapters')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CustomPrompt') is not None:
            self.custom_prompt_shrink = m.get('CustomPrompt')
        if m.get('LanguageHints') is not None:
            self.language_hints = m.get('LanguageHints')
        if m.get('MeetingAssistance') is not None:
            self.meeting_assistance_shrink = m.get('MeetingAssistance')
        if m.get('RealtimeSubtitle') is not None:
            self.realtime_subtitle_shrink = m.get('RealtimeSubtitle')
        if m.get('ServiceInspection') is not None:
            self.service_inspection_shrink = m.get('ServiceInspection')
        if m.get('SourceLanguage') is not None:
            self.source_language = m.get('SourceLanguage')
        if m.get('StorageConfig') is not None:
            temp_model = StartCloudNoteShrinkRequestStorageConfig()
            self.storage_config = temp_model.from_map(m['StorageConfig'])
        if m.get('Summarization') is not None:
            self.summarization_shrink = m.get('Summarization')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TextPolish') is not None:
            self.text_polish_shrink = m.get('TextPolish')
        if m.get('Transcription') is not None:
            self.transcription_shrink = m.get('Transcription')
        return self


class StartCloudNoteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StartCloudNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartCloudNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartCloudNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartCloudRecordRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordRequestBgColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartCloudRecordRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: StartCloudRecordRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartCloudRecordRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartCloudRecordRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class StartCloudRecordRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordRequestLayoutSpecifiedUsers(TeaModel):
    def __init__(
        self,
        ids: List[str] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.ids = ids
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StartCloudRecordRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartCloudRecordRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: StartCloudRecordRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartCloudRecordRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartCloudRecordRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class StartCloudRecordRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[StartCloudRecordRequestPanesBackgrounds] = None,
        images: List[StartCloudRecordRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: int = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[StartCloudRecordRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: StartCloudRecordRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        # paneId
        # 
        # This parameter is required.
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        # source
        self.source = source
        # sourceType
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartCloudRecordRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartCloudRecordRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartCloudRecordRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = StartCloudRecordRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class StartCloudRecordRequestRegionColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestSingleStreamingRecordSpecifiedStreams(TeaModel):
    def __init__(
        self,
        ids: List[str] = None,
        stream_type: str = None,
        type: str = None,
    ):
        # This parameter is required.
        self.ids = ids
        # This parameter is required.
        self.stream_type = stream_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StartCloudRecordRequestSingleStreamingRecordTranscodingParametersAudio(TeaModel):
    def __init__(
        self,
        bitrate: int = None,
        codec: str = None,
        sample_rate: int = None,
    ):
        self.bitrate = bitrate
        self.codec = codec
        self.sample_rate = sample_rate

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        return self


class StartCloudRecordRequestSingleStreamingRecordTranscodingParameters(TeaModel):
    def __init__(
        self,
        audio: StartCloudRecordRequestSingleStreamingRecordTranscodingParametersAudio = None,
        container: str = None,
    ):
        self.audio = audio
        self.container = container

    def validate(self):
        if self.audio:
            self.audio.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = StartCloudRecordRequestSingleStreamingRecordTranscodingParametersAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            self.container = m.get('Container')
        return self


class StartCloudRecordRequestSingleStreamingRecord(TeaModel):
    def __init__(
        self,
        specified_streams: List[StartCloudRecordRequestSingleStreamingRecordSpecifiedStreams] = None,
        transcoding_parameters: StartCloudRecordRequestSingleStreamingRecordTranscodingParameters = None,
    ):
        # This parameter is required.
        self.specified_streams = specified_streams
        self.transcoding_parameters = transcoding_parameters

    def validate(self):
        if self.specified_streams:
            for k in self.specified_streams:
                if k:
                    k.validate()
        if self.transcoding_parameters:
            self.transcoding_parameters.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SpecifiedStreams'] = []
        if self.specified_streams is not None:
            for k in self.specified_streams:
                result['SpecifiedStreams'].append(k.to_map() if k else None)
        if self.transcoding_parameters is not None:
            result['TranscodingParameters'] = self.transcoding_parameters.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.specified_streams = []
        if m.get('SpecifiedStreams') is not None:
            for k in m.get('SpecifiedStreams'):
                temp_model = StartCloudRecordRequestSingleStreamingRecordSpecifiedStreams()
                self.specified_streams.append(temp_model.from_map(k))
        if m.get('TranscodingParameters') is not None:
            temp_model = StartCloudRecordRequestSingleStreamingRecordTranscodingParameters()
            self.transcoding_parameters = temp_model.from_map(m['TranscodingParameters'])
        return self


class StartCloudRecordRequestStorageConfig(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        bucket: str = None,
        endpoint: str = None,
        region: int = None,
        secret_key: str = None,
        vendor: int = None,
    ):
        # accessKey
        # 
        # This parameter is required.
        self.access_key = access_key
        # bucket
        # 
        # This parameter is required.
        self.bucket = bucket
        self.endpoint = endpoint
        # region
        # 
        # This parameter is required.
        self.region = region
        # secretKey
        # 
        # This parameter is required.
        self.secret_key = secret_key
        # vendor
        # 
        # This parameter is required.
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.region is not None:
            result['Region'] = self.region
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class StartCloudRecordRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartCloudRecordRequestTextsBoxColor = None,
        font: int = None,
        font_color: StartCloudRecordRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartCloudRecordRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartCloudRecordRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordRequest(TeaModel):
    def __init__(
        self,
        annotation: str = None,
        app_id: str = None,
        backgrounds: List[StartCloudRecordRequestBackgrounds] = None,
        bg_color: StartCloudRecordRequestBgColor = None,
        channel_id: str = None,
        clock_widgets: List[StartCloudRecordRequestClockWidgets] = None,
        crop_mode: int = None,
        images: List[StartCloudRecordRequestImages] = None,
        layout_specified_users: StartCloudRecordRequestLayoutSpecifiedUsers = None,
        panes: List[StartCloudRecordRequestPanes] = None,
        record_mode: int = None,
        region_color: StartCloudRecordRequestRegionColor = None,
        reserve_pane_for_no_camera_user: bool = None,
        show_default_background_on_mute: bool = None,
        single_streaming_record: StartCloudRecordRequestSingleStreamingRecord = None,
        start_without_channel: bool = None,
        start_without_channel_wait_time: int = None,
        storage_config: StartCloudRecordRequestStorageConfig = None,
        sub_high_resolution_stream: bool = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[StartCloudRecordRequestTexts] = None,
    ):
        self.annotation = annotation
        # appId
        # 
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        self.bg_color = bg_color
        # channelName
        # 
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.images = images
        self.layout_specified_users = layout_specified_users
        # panes
        self.panes = panes
        self.record_mode = record_mode
        self.region_color = region_color
        self.reserve_pane_for_no_camera_user = reserve_pane_for_no_camera_user
        self.show_default_background_on_mute = show_default_background_on_mute
        self.single_streaming_record = single_streaming_record
        self.start_without_channel = start_without_channel
        self.start_without_channel_wait_time = start_without_channel_wait_time
        # storageConfig
        # 
        # This parameter is required.
        self.storage_config = storage_config
        self.sub_high_resolution_stream = sub_high_resolution_stream
        # taskId
        self.task_id = task_id
        # templateId
        # 
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.bg_color:
            self.bg_color.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.layout_specified_users:
            self.layout_specified_users.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.region_color:
            self.region_color.validate()
        if self.single_streaming_record:
            self.single_streaming_record.validate()
        if self.storage_config:
            self.storage_config.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation is not None:
            result['Annotation'] = self.annotation
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users.to_map()
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.record_mode is not None:
            result['RecordMode'] = self.record_mode
        if self.region_color is not None:
            result['RegionColor'] = self.region_color.to_map()
        if self.reserve_pane_for_no_camera_user is not None:
            result['ReservePaneForNoCameraUser'] = self.reserve_pane_for_no_camera_user
        if self.show_default_background_on_mute is not None:
            result['ShowDefaultBackgroundOnMute'] = self.show_default_background_on_mute
        if self.single_streaming_record is not None:
            result['SingleStreamingRecord'] = self.single_streaming_record.to_map()
        if self.start_without_channel is not None:
            result['StartWithoutChannel'] = self.start_without_channel
        if self.start_without_channel_wait_time is not None:
            result['StartWithoutChannelWaitTime'] = self.start_without_channel_wait_time
        if self.storage_config is not None:
            result['StorageConfig'] = self.storage_config.to_map()
        if self.sub_high_resolution_stream is not None:
            result['SubHighResolutionStream'] = self.sub_high_resolution_stream
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotation') is not None:
            self.annotation = m.get('Annotation')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartCloudRecordRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('BgColor') is not None:
            temp_model = StartCloudRecordRequestBgColor()
            self.bg_color = temp_model.from_map(m['BgColor'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = StartCloudRecordRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartCloudRecordRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            temp_model = StartCloudRecordRequestLayoutSpecifiedUsers()
            self.layout_specified_users = temp_model.from_map(m['LayoutSpecifiedUsers'])
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = StartCloudRecordRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('RecordMode') is not None:
            self.record_mode = m.get('RecordMode')
        if m.get('RegionColor') is not None:
            temp_model = StartCloudRecordRequestRegionColor()
            self.region_color = temp_model.from_map(m['RegionColor'])
        if m.get('ReservePaneForNoCameraUser') is not None:
            self.reserve_pane_for_no_camera_user = m.get('ReservePaneForNoCameraUser')
        if m.get('ShowDefaultBackgroundOnMute') is not None:
            self.show_default_background_on_mute = m.get('ShowDefaultBackgroundOnMute')
        if m.get('SingleStreamingRecord') is not None:
            temp_model = StartCloudRecordRequestSingleStreamingRecord()
            self.single_streaming_record = temp_model.from_map(m['SingleStreamingRecord'])
        if m.get('StartWithoutChannel') is not None:
            self.start_without_channel = m.get('StartWithoutChannel')
        if m.get('StartWithoutChannelWaitTime') is not None:
            self.start_without_channel_wait_time = m.get('StartWithoutChannelWaitTime')
        if m.get('StorageConfig') is not None:
            temp_model = StartCloudRecordRequestStorageConfig()
            self.storage_config = temp_model.from_map(m['StorageConfig'])
        if m.get('SubHighResolutionStream') is not None:
            self.sub_high_resolution_stream = m.get('SubHighResolutionStream')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartCloudRecordRequestTexts()
                self.texts.append(temp_model.from_map(k))
        return self


class StartCloudRecordShrinkRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordShrinkRequestBgColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartCloudRecordShrinkRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: StartCloudRecordShrinkRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartCloudRecordShrinkRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartCloudRecordShrinkRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class StartCloudRecordShrinkRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordShrinkRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordShrinkRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordShrinkRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartCloudRecordShrinkRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: StartCloudRecordShrinkRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartCloudRecordShrinkRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartCloudRecordShrinkRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordShrinkRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class StartCloudRecordShrinkRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[StartCloudRecordShrinkRequestPanesBackgrounds] = None,
        images: List[StartCloudRecordShrinkRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: int = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[StartCloudRecordShrinkRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: StartCloudRecordShrinkRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        # paneId
        # 
        # This parameter is required.
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        # source
        self.source = source
        # sourceType
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartCloudRecordShrinkRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartCloudRecordShrinkRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartCloudRecordShrinkRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = StartCloudRecordShrinkRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class StartCloudRecordShrinkRequestRegionColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestStorageConfig(TeaModel):
    def __init__(
        self,
        access_key: str = None,
        bucket: str = None,
        endpoint: str = None,
        region: int = None,
        secret_key: str = None,
        vendor: int = None,
    ):
        # accessKey
        # 
        # This parameter is required.
        self.access_key = access_key
        # bucket
        # 
        # This parameter is required.
        self.bucket = bucket
        self.endpoint = endpoint
        # region
        # 
        # This parameter is required.
        self.region = region
        # secretKey
        # 
        # This parameter is required.
        self.secret_key = secret_key
        # vendor
        # 
        # This parameter is required.
        self.vendor = vendor

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.endpoint is not None:
            result['Endpoint'] = self.endpoint
        if self.region is not None:
            result['Region'] = self.region
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.vendor is not None:
            result['Vendor'] = self.vendor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Endpoint') is not None:
            self.endpoint = m.get('Endpoint')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('Vendor') is not None:
            self.vendor = m.get('Vendor')
        return self


class StartCloudRecordShrinkRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartCloudRecordShrinkRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartCloudRecordShrinkRequestTextsBoxColor = None,
        font: int = None,
        font_color: StartCloudRecordShrinkRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartCloudRecordShrinkRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartCloudRecordShrinkRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartCloudRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        annotation: str = None,
        app_id: str = None,
        backgrounds: List[StartCloudRecordShrinkRequestBackgrounds] = None,
        bg_color: StartCloudRecordShrinkRequestBgColor = None,
        channel_id: str = None,
        clock_widgets: List[StartCloudRecordShrinkRequestClockWidgets] = None,
        crop_mode: int = None,
        images: List[StartCloudRecordShrinkRequestImages] = None,
        layout_specified_users_shrink: str = None,
        panes: List[StartCloudRecordShrinkRequestPanes] = None,
        record_mode: int = None,
        region_color: StartCloudRecordShrinkRequestRegionColor = None,
        reserve_pane_for_no_camera_user: bool = None,
        show_default_background_on_mute: bool = None,
        single_streaming_record_shrink: str = None,
        start_without_channel: bool = None,
        start_without_channel_wait_time: int = None,
        storage_config: StartCloudRecordShrinkRequestStorageConfig = None,
        sub_high_resolution_stream: bool = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[StartCloudRecordShrinkRequestTexts] = None,
    ):
        self.annotation = annotation
        # appId
        # 
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        self.bg_color = bg_color
        # channelName
        # 
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.images = images
        self.layout_specified_users_shrink = layout_specified_users_shrink
        # panes
        self.panes = panes
        self.record_mode = record_mode
        self.region_color = region_color
        self.reserve_pane_for_no_camera_user = reserve_pane_for_no_camera_user
        self.show_default_background_on_mute = show_default_background_on_mute
        self.single_streaming_record_shrink = single_streaming_record_shrink
        self.start_without_channel = start_without_channel
        self.start_without_channel_wait_time = start_without_channel_wait_time
        # storageConfig
        # 
        # This parameter is required.
        self.storage_config = storage_config
        self.sub_high_resolution_stream = sub_high_resolution_stream
        # taskId
        self.task_id = task_id
        # templateId
        # 
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.bg_color:
            self.bg_color.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.region_color:
            self.region_color.validate()
        if self.storage_config:
            self.storage_config.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation is not None:
            result['Annotation'] = self.annotation
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users_shrink is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users_shrink
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.record_mode is not None:
            result['RecordMode'] = self.record_mode
        if self.region_color is not None:
            result['RegionColor'] = self.region_color.to_map()
        if self.reserve_pane_for_no_camera_user is not None:
            result['ReservePaneForNoCameraUser'] = self.reserve_pane_for_no_camera_user
        if self.show_default_background_on_mute is not None:
            result['ShowDefaultBackgroundOnMute'] = self.show_default_background_on_mute
        if self.single_streaming_record_shrink is not None:
            result['SingleStreamingRecord'] = self.single_streaming_record_shrink
        if self.start_without_channel is not None:
            result['StartWithoutChannel'] = self.start_without_channel
        if self.start_without_channel_wait_time is not None:
            result['StartWithoutChannelWaitTime'] = self.start_without_channel_wait_time
        if self.storage_config is not None:
            result['StorageConfig'] = self.storage_config.to_map()
        if self.sub_high_resolution_stream is not None:
            result['SubHighResolutionStream'] = self.sub_high_resolution_stream
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotation') is not None:
            self.annotation = m.get('Annotation')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartCloudRecordShrinkRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('BgColor') is not None:
            temp_model = StartCloudRecordShrinkRequestBgColor()
            self.bg_color = temp_model.from_map(m['BgColor'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = StartCloudRecordShrinkRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartCloudRecordShrinkRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            self.layout_specified_users_shrink = m.get('LayoutSpecifiedUsers')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = StartCloudRecordShrinkRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('RecordMode') is not None:
            self.record_mode = m.get('RecordMode')
        if m.get('RegionColor') is not None:
            temp_model = StartCloudRecordShrinkRequestRegionColor()
            self.region_color = temp_model.from_map(m['RegionColor'])
        if m.get('ReservePaneForNoCameraUser') is not None:
            self.reserve_pane_for_no_camera_user = m.get('ReservePaneForNoCameraUser')
        if m.get('ShowDefaultBackgroundOnMute') is not None:
            self.show_default_background_on_mute = m.get('ShowDefaultBackgroundOnMute')
        if m.get('SingleStreamingRecord') is not None:
            self.single_streaming_record_shrink = m.get('SingleStreamingRecord')
        if m.get('StartWithoutChannel') is not None:
            self.start_without_channel = m.get('StartWithoutChannel')
        if m.get('StartWithoutChannelWaitTime') is not None:
            self.start_without_channel_wait_time = m.get('StartWithoutChannelWaitTime')
        if m.get('StorageConfig') is not None:
            temp_model = StartCloudRecordShrinkRequestStorageConfig()
            self.storage_config = temp_model.from_map(m['StorageConfig'])
        if m.get('SubHighResolutionStream') is not None:
            self.sub_high_resolution_stream = m.get('SubHighResolutionStream')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartCloudRecordShrinkRequestTexts()
                self.texts.append(temp_model.from_map(k))
        return self


class StartCloudRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        # requestId
        self.request_id = request_id
        # taskId
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StartCloudRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartCloudRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartCloudRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartMPUTaskRequestBackgrounds(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartMPUTaskRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        border_color: int = None,
        border_width: int = None,
        box: bool = None,
        box_border_width: int = None,
        box_color: int = None,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.border_color = border_color
        self.border_width = border_width
        self.box = box
        self.box_border_width = box_border_width
        self.box_color = box_color
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.box is not None:
            result['Box'] = self.box
        if self.box_border_width is not None:
            result['BoxBorderWidth'] = self.box_border_width
        if self.box_color is not None:
            result['BoxColor'] = self.box_color
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Box') is not None:
            self.box = m.get('Box')
        if m.get('BoxBorderWidth') is not None:
            self.box_border_width = m.get('BoxBorderWidth')
        if m.get('BoxColor') is not None:
            self.box_color = m.get('BoxColor')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartMPUTaskRequestEnhancedParam(TeaModel):
    def __init__(
        self,
        enable_portrait_segmentation: bool = None,
    ):
        self.enable_portrait_segmentation = enable_portrait_segmentation

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_portrait_segmentation is not None:
            result['EnablePortraitSegmentation'] = self.enable_portrait_segmentation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnablePortraitSegmentation') is not None:
            self.enable_portrait_segmentation = m.get('EnablePortraitSegmentation')
        return self


class StartMPUTaskRequestUserPanesImages(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartMPUTaskRequestUserPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        border_color: int = None,
        border_width: int = None,
        box: bool = None,
        box_border_width: int = None,
        box_color: int = None,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        text: str = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.border_color = border_color
        self.border_width = border_width
        self.box = box
        self.box_border_width = box_border_width
        self.box_color = box_color
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.text = text
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.box is not None:
            result['Box'] = self.box
        if self.box_border_width is not None:
            result['BoxBorderWidth'] = self.box_border_width
        if self.box_color is not None:
            result['BoxColor'] = self.box_color
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.text is not None:
            result['Text'] = self.text
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Box') is not None:
            self.box = m.get('Box')
        if m.get('BoxBorderWidth') is not None:
            self.box_border_width = m.get('BoxBorderWidth')
        if m.get('BoxColor') is not None:
            self.box_color = m.get('BoxColor')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartMPUTaskRequestUserPanes(TeaModel):
    def __init__(
        self,
        images: List[StartMPUTaskRequestUserPanesImages] = None,
        pane_id: int = None,
        segment_type: int = None,
        source_type: str = None,
        texts: List[StartMPUTaskRequestUserPanesTexts] = None,
        user_id: str = None,
    ):
        self.images = images
        self.pane_id = pane_id
        self.segment_type = segment_type
        self.source_type = source_type
        self.texts = texts
        self.user_id = user_id

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.segment_type is not None:
            result['SegmentType'] = self.segment_type
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartMPUTaskRequestUserPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('SegmentType') is not None:
            self.segment_type = m.get('SegmentType')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartMPUTaskRequestUserPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartMPUTaskRequestWatermarks(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartMPUTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        background_color: int = None,
        backgrounds: List[StartMPUTaskRequestBackgrounds] = None,
        channel_id: str = None,
        clock_widgets: List[StartMPUTaskRequestClockWidgets] = None,
        crop_mode: int = None,
        enhanced_param: StartMPUTaskRequestEnhancedParam = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        mix_mode: int = None,
        owner_id: int = None,
        payload_type: int = None,
        report_vad: int = None,
        rtp_ext_info: int = None,
        source_type: str = None,
        stream_type: int = None,
        stream_url: str = None,
        sub_spec_audio_users: List[str] = None,
        sub_spec_camera_users: List[str] = None,
        sub_spec_share_screen_users: List[str] = None,
        sub_spec_users: List[str] = None,
        task_id: str = None,
        task_type: int = None,
        time_stamp_ref: int = None,
        unsub_spec_audio_users: List[str] = None,
        unsub_spec_camera_users: List[str] = None,
        unsub_spec_share_screen_users: List[str] = None,
        user_panes: List[StartMPUTaskRequestUserPanes] = None,
        vad_interval: int = None,
        watermarks: List[StartMPUTaskRequestWatermarks] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.background_color = background_color
        self.backgrounds = backgrounds
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.enhanced_param = enhanced_param
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.mix_mode = mix_mode
        self.owner_id = owner_id
        self.payload_type = payload_type
        self.report_vad = report_vad
        self.rtp_ext_info = rtp_ext_info
        self.source_type = source_type
        self.stream_type = stream_type
        self.stream_url = stream_url
        self.sub_spec_audio_users = sub_spec_audio_users
        self.sub_spec_camera_users = sub_spec_camera_users
        self.sub_spec_share_screen_users = sub_spec_share_screen_users
        self.sub_spec_users = sub_spec_users
        # This parameter is required.
        self.task_id = task_id
        self.task_type = task_type
        self.time_stamp_ref = time_stamp_ref
        self.unsub_spec_audio_users = unsub_spec_audio_users
        self.unsub_spec_camera_users = unsub_spec_camera_users
        self.unsub_spec_share_screen_users = unsub_spec_share_screen_users
        self.user_panes = user_panes
        self.vad_interval = vad_interval
        self.watermarks = watermarks

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.enhanced_param:
            self.enhanced_param.validate()
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()
        if self.watermarks:
            for k in self.watermarks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.background_color is not None:
            result['BackgroundColor'] = self.background_color
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        if self.enhanced_param is not None:
            result['EnhancedParam'] = self.enhanced_param.to_map()
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.payload_type is not None:
            result['PayloadType'] = self.payload_type
        if self.report_vad is not None:
            result['ReportVad'] = self.report_vad
        if self.rtp_ext_info is not None:
            result['RtpExtInfo'] = self.rtp_ext_info
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.sub_spec_audio_users is not None:
            result['SubSpecAudioUsers'] = self.sub_spec_audio_users
        if self.sub_spec_camera_users is not None:
            result['SubSpecCameraUsers'] = self.sub_spec_camera_users
        if self.sub_spec_share_screen_users is not None:
            result['SubSpecShareScreenUsers'] = self.sub_spec_share_screen_users
        if self.sub_spec_users is not None:
            result['SubSpecUsers'] = self.sub_spec_users
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.time_stamp_ref is not None:
            result['TimeStampRef'] = self.time_stamp_ref
        if self.unsub_spec_audio_users is not None:
            result['UnsubSpecAudioUsers'] = self.unsub_spec_audio_users
        if self.unsub_spec_camera_users is not None:
            result['UnsubSpecCameraUsers'] = self.unsub_spec_camera_users
        if self.unsub_spec_share_screen_users is not None:
            result['UnsubSpecShareScreenUsers'] = self.unsub_spec_share_screen_users
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        if self.vad_interval is not None:
            result['VadInterval'] = self.vad_interval
        result['Watermarks'] = []
        if self.watermarks is not None:
            for k in self.watermarks:
                result['Watermarks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BackgroundColor') is not None:
            self.background_color = m.get('BackgroundColor')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartMPUTaskRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = StartMPUTaskRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        if m.get('EnhancedParam') is not None:
            temp_model = StartMPUTaskRequestEnhancedParam()
            self.enhanced_param = temp_model.from_map(m['EnhancedParam'])
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PayloadType') is not None:
            self.payload_type = m.get('PayloadType')
        if m.get('ReportVad') is not None:
            self.report_vad = m.get('ReportVad')
        if m.get('RtpExtInfo') is not None:
            self.rtp_ext_info = m.get('RtpExtInfo')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('SubSpecAudioUsers') is not None:
            self.sub_spec_audio_users = m.get('SubSpecAudioUsers')
        if m.get('SubSpecCameraUsers') is not None:
            self.sub_spec_camera_users = m.get('SubSpecCameraUsers')
        if m.get('SubSpecShareScreenUsers') is not None:
            self.sub_spec_share_screen_users = m.get('SubSpecShareScreenUsers')
        if m.get('SubSpecUsers') is not None:
            self.sub_spec_users = m.get('SubSpecUsers')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('TimeStampRef') is not None:
            self.time_stamp_ref = m.get('TimeStampRef')
        if m.get('UnsubSpecAudioUsers') is not None:
            self.unsub_spec_audio_users = m.get('UnsubSpecAudioUsers')
        if m.get('UnsubSpecCameraUsers') is not None:
            self.unsub_spec_camera_users = m.get('UnsubSpecCameraUsers')
        if m.get('UnsubSpecShareScreenUsers') is not None:
            self.unsub_spec_share_screen_users = m.get('UnsubSpecShareScreenUsers')
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = StartMPUTaskRequestUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        if m.get('VadInterval') is not None:
            self.vad_interval = m.get('VadInterval')
        self.watermarks = []
        if m.get('Watermarks') is not None:
            for k in m.get('Watermarks'):
                temp_model = StartMPUTaskRequestWatermarks()
                self.watermarks.append(temp_model.from_map(k))
        return self


class StartMPUTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartMPUTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartMPUTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartMPUTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartRecordTaskRequestUserPanesImages(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartRecordTaskRequestUserPanesTexts(TeaModel):
    def __init__(
        self,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        text: str = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.text = text
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.text is not None:
            result['Text'] = self.text
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class StartRecordTaskRequestUserPanes(TeaModel):
    def __init__(
        self,
        images: List[StartRecordTaskRequestUserPanesImages] = None,
        pane_id: int = None,
        source_type: str = None,
        texts: List[StartRecordTaskRequestUserPanesTexts] = None,
        user_id: str = None,
    ):
        self.images = images
        self.pane_id = pane_id
        self.source_type = source_type
        self.texts = texts
        self.user_id = user_id

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartRecordTaskRequestUserPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartRecordTaskRequestUserPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class StartRecordTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        crop_mode: int = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        mix_mode: int = None,
        owner_id: int = None,
        source_type: str = None,
        stream_type: int = None,
        sub_spec_audio_users: List[str] = None,
        sub_spec_camera_users: List[str] = None,
        sub_spec_share_screen_users: List[str] = None,
        sub_spec_users: List[str] = None,
        task_id: str = None,
        task_profile: str = None,
        template_id: str = None,
        unsub_spec_audio_users: List[str] = None,
        unsub_spec_camera_users: List[str] = None,
        unsub_spec_share_screen_users: List[str] = None,
        user_panes: List[StartRecordTaskRequestUserPanes] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.crop_mode = crop_mode
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.mix_mode = mix_mode
        self.owner_id = owner_id
        self.source_type = source_type
        self.stream_type = stream_type
        self.sub_spec_audio_users = sub_spec_audio_users
        self.sub_spec_camera_users = sub_spec_camera_users
        self.sub_spec_share_screen_users = sub_spec_share_screen_users
        self.sub_spec_users = sub_spec_users
        # This parameter is required.
        self.task_id = task_id
        self.task_profile = task_profile
        # This parameter is required.
        self.template_id = template_id
        self.unsub_spec_audio_users = unsub_spec_audio_users
        self.unsub_spec_camera_users = unsub_spec_camera_users
        self.unsub_spec_share_screen_users = unsub_spec_share_screen_users
        self.user_panes = user_panes

    def validate(self):
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.sub_spec_audio_users is not None:
            result['SubSpecAudioUsers'] = self.sub_spec_audio_users
        if self.sub_spec_camera_users is not None:
            result['SubSpecCameraUsers'] = self.sub_spec_camera_users
        if self.sub_spec_share_screen_users is not None:
            result['SubSpecShareScreenUsers'] = self.sub_spec_share_screen_users
        if self.sub_spec_users is not None:
            result['SubSpecUsers'] = self.sub_spec_users
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_profile is not None:
            result['TaskProfile'] = self.task_profile
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.unsub_spec_audio_users is not None:
            result['UnsubSpecAudioUsers'] = self.unsub_spec_audio_users
        if self.unsub_spec_camera_users is not None:
            result['UnsubSpecCameraUsers'] = self.unsub_spec_camera_users
        if self.unsub_spec_share_screen_users is not None:
            result['UnsubSpecShareScreenUsers'] = self.unsub_spec_share_screen_users
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('SubSpecAudioUsers') is not None:
            self.sub_spec_audio_users = m.get('SubSpecAudioUsers')
        if m.get('SubSpecCameraUsers') is not None:
            self.sub_spec_camera_users = m.get('SubSpecCameraUsers')
        if m.get('SubSpecShareScreenUsers') is not None:
            self.sub_spec_share_screen_users = m.get('SubSpecShareScreenUsers')
        if m.get('SubSpecUsers') is not None:
            self.sub_spec_users = m.get('SubSpecUsers')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskProfile') is not None:
            self.task_profile = m.get('TaskProfile')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UnsubSpecAudioUsers') is not None:
            self.unsub_spec_audio_users = m.get('UnsubSpecAudioUsers')
        if m.get('UnsubSpecCameraUsers') is not None:
            self.unsub_spec_camera_users = m.get('UnsubSpecCameraUsers')
        if m.get('UnsubSpecShareScreenUsers') is not None:
            self.unsub_spec_share_screen_users = m.get('UnsubSpecShareScreenUsers')
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = StartRecordTaskRequestUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class StartRecordTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartRecordTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartRecordTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartRecordTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartStreamingOutRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutRequestBgColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartStreamingOutRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: StartStreamingOutRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartStreamingOutRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartStreamingOutRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class StartStreamingOutRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutRequestLayoutSpecifiedUsers(TeaModel):
    def __init__(
        self,
        ids: List[str] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.ids = ids
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class StartStreamingOutRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartStreamingOutRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: StartStreamingOutRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartStreamingOutRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartStreamingOutRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class StartStreamingOutRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[StartStreamingOutRequestPanesBackgrounds] = None,
        images: List[StartStreamingOutRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: str = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[StartStreamingOutRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: StartStreamingOutRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        # This parameter is required.
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        self.source = source
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartStreamingOutRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartStreamingOutRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartStreamingOutRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = StartStreamingOutRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class StartStreamingOutRequestRegionColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartStreamingOutRequestTextsBoxColor = None,
        font: int = None,
        font_color: StartStreamingOutRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartStreamingOutRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartStreamingOutRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutRequest(TeaModel):
    def __init__(
        self,
        annotation: str = None,
        app_id: str = None,
        backgrounds: List[StartStreamingOutRequestBackgrounds] = None,
        bg_color: StartStreamingOutRequestBgColor = None,
        channel_id: str = None,
        clock_widgets: List[StartStreamingOutRequestClockWidgets] = None,
        crop_mode: int = None,
        images: List[StartStreamingOutRequestImages] = None,
        layout_specified_users: StartStreamingOutRequestLayoutSpecifiedUsers = None,
        panes: List[StartStreamingOutRequestPanes] = None,
        region_color: StartStreamingOutRequestRegionColor = None,
        reserve_pane_for_no_camera_user: bool = None,
        show_default_background_on_mute: bool = None,
        spec_mixed_user_list: List[str] = None,
        start_without_channel: bool = None,
        start_without_channel_wait_time: int = None,
        sub_high_resolution_stream: bool = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[StartStreamingOutRequestTexts] = None,
        url: str = None,
    ):
        self.annotation = annotation
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        self.bg_color = bg_color
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.images = images
        self.layout_specified_users = layout_specified_users
        self.panes = panes
        self.region_color = region_color
        self.reserve_pane_for_no_camera_user = reserve_pane_for_no_camera_user
        self.show_default_background_on_mute = show_default_background_on_mute
        self.spec_mixed_user_list = spec_mixed_user_list
        self.start_without_channel = start_without_channel
        self.start_without_channel_wait_time = start_without_channel_wait_time
        self.sub_high_resolution_stream = sub_high_resolution_stream
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts
        # This parameter is required.
        self.url = url

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.bg_color:
            self.bg_color.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.layout_specified_users:
            self.layout_specified_users.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.region_color:
            self.region_color.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation is not None:
            result['Annotation'] = self.annotation
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users.to_map()
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.region_color is not None:
            result['RegionColor'] = self.region_color.to_map()
        if self.reserve_pane_for_no_camera_user is not None:
            result['ReservePaneForNoCameraUser'] = self.reserve_pane_for_no_camera_user
        if self.show_default_background_on_mute is not None:
            result['ShowDefaultBackgroundOnMute'] = self.show_default_background_on_mute
        if self.spec_mixed_user_list is not None:
            result['SpecMixedUserList'] = self.spec_mixed_user_list
        if self.start_without_channel is not None:
            result['StartWithoutChannel'] = self.start_without_channel
        if self.start_without_channel_wait_time is not None:
            result['StartWithoutChannelWaitTime'] = self.start_without_channel_wait_time
        if self.sub_high_resolution_stream is not None:
            result['SubHighResolutionStream'] = self.sub_high_resolution_stream
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotation') is not None:
            self.annotation = m.get('Annotation')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartStreamingOutRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('BgColor') is not None:
            temp_model = StartStreamingOutRequestBgColor()
            self.bg_color = temp_model.from_map(m['BgColor'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = StartStreamingOutRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartStreamingOutRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            temp_model = StartStreamingOutRequestLayoutSpecifiedUsers()
            self.layout_specified_users = temp_model.from_map(m['LayoutSpecifiedUsers'])
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = StartStreamingOutRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('RegionColor') is not None:
            temp_model = StartStreamingOutRequestRegionColor()
            self.region_color = temp_model.from_map(m['RegionColor'])
        if m.get('ReservePaneForNoCameraUser') is not None:
            self.reserve_pane_for_no_camera_user = m.get('ReservePaneForNoCameraUser')
        if m.get('ShowDefaultBackgroundOnMute') is not None:
            self.show_default_background_on_mute = m.get('ShowDefaultBackgroundOnMute')
        if m.get('SpecMixedUserList') is not None:
            self.spec_mixed_user_list = m.get('SpecMixedUserList')
        if m.get('StartWithoutChannel') is not None:
            self.start_without_channel = m.get('StartWithoutChannel')
        if m.get('StartWithoutChannelWaitTime') is not None:
            self.start_without_channel_wait_time = m.get('StartWithoutChannelWaitTime')
        if m.get('SubHighResolutionStream') is not None:
            self.sub_high_resolution_stream = m.get('SubHighResolutionStream')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartStreamingOutRequestTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class StartStreamingOutShrinkRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutShrinkRequestBgColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartStreamingOutShrinkRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: StartStreamingOutShrinkRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartStreamingOutShrinkRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartStreamingOutShrinkRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class StartStreamingOutShrinkRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutShrinkRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutShrinkRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutShrinkRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartStreamingOutShrinkRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: StartStreamingOutShrinkRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartStreamingOutShrinkRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartStreamingOutShrinkRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutShrinkRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class StartStreamingOutShrinkRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[StartStreamingOutShrinkRequestPanesBackgrounds] = None,
        images: List[StartStreamingOutShrinkRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: str = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[StartStreamingOutShrinkRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: StartStreamingOutShrinkRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        # This parameter is required.
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        self.source = source
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartStreamingOutShrinkRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartStreamingOutShrinkRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartStreamingOutShrinkRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = StartStreamingOutShrinkRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class StartStreamingOutShrinkRequestRegionColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class StartStreamingOutShrinkRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: StartStreamingOutShrinkRequestTextsBoxColor = None,
        font: int = None,
        font_color: StartStreamingOutShrinkRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = StartStreamingOutShrinkRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = StartStreamingOutShrinkRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class StartStreamingOutShrinkRequest(TeaModel):
    def __init__(
        self,
        annotation: str = None,
        app_id: str = None,
        backgrounds: List[StartStreamingOutShrinkRequestBackgrounds] = None,
        bg_color: StartStreamingOutShrinkRequestBgColor = None,
        channel_id: str = None,
        clock_widgets: List[StartStreamingOutShrinkRequestClockWidgets] = None,
        crop_mode: int = None,
        images: List[StartStreamingOutShrinkRequestImages] = None,
        layout_specified_users_shrink: str = None,
        panes: List[StartStreamingOutShrinkRequestPanes] = None,
        region_color: StartStreamingOutShrinkRequestRegionColor = None,
        reserve_pane_for_no_camera_user: bool = None,
        show_default_background_on_mute: bool = None,
        spec_mixed_user_list: List[str] = None,
        start_without_channel: bool = None,
        start_without_channel_wait_time: int = None,
        sub_high_resolution_stream: bool = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[StartStreamingOutShrinkRequestTexts] = None,
        url: str = None,
    ):
        self.annotation = annotation
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        self.bg_color = bg_color
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.images = images
        self.layout_specified_users_shrink = layout_specified_users_shrink
        self.panes = panes
        self.region_color = region_color
        self.reserve_pane_for_no_camera_user = reserve_pane_for_no_camera_user
        self.show_default_background_on_mute = show_default_background_on_mute
        self.spec_mixed_user_list = spec_mixed_user_list
        self.start_without_channel = start_without_channel
        self.start_without_channel_wait_time = start_without_channel_wait_time
        self.sub_high_resolution_stream = sub_high_resolution_stream
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts
        # This parameter is required.
        self.url = url

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.bg_color:
            self.bg_color.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.region_color:
            self.region_color.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation is not None:
            result['Annotation'] = self.annotation
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users_shrink is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users_shrink
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.region_color is not None:
            result['RegionColor'] = self.region_color.to_map()
        if self.reserve_pane_for_no_camera_user is not None:
            result['ReservePaneForNoCameraUser'] = self.reserve_pane_for_no_camera_user
        if self.show_default_background_on_mute is not None:
            result['ShowDefaultBackgroundOnMute'] = self.show_default_background_on_mute
        if self.spec_mixed_user_list is not None:
            result['SpecMixedUserList'] = self.spec_mixed_user_list
        if self.start_without_channel is not None:
            result['StartWithoutChannel'] = self.start_without_channel
        if self.start_without_channel_wait_time is not None:
            result['StartWithoutChannelWaitTime'] = self.start_without_channel_wait_time
        if self.sub_high_resolution_stream is not None:
            result['SubHighResolutionStream'] = self.sub_high_resolution_stream
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Annotation') is not None:
            self.annotation = m.get('Annotation')
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = StartStreamingOutShrinkRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('BgColor') is not None:
            temp_model = StartStreamingOutShrinkRequestBgColor()
            self.bg_color = temp_model.from_map(m['BgColor'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = StartStreamingOutShrinkRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = StartStreamingOutShrinkRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            self.layout_specified_users_shrink = m.get('LayoutSpecifiedUsers')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = StartStreamingOutShrinkRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('RegionColor') is not None:
            temp_model = StartStreamingOutShrinkRequestRegionColor()
            self.region_color = temp_model.from_map(m['RegionColor'])
        if m.get('ReservePaneForNoCameraUser') is not None:
            self.reserve_pane_for_no_camera_user = m.get('ReservePaneForNoCameraUser')
        if m.get('ShowDefaultBackgroundOnMute') is not None:
            self.show_default_background_on_mute = m.get('ShowDefaultBackgroundOnMute')
        if m.get('SpecMixedUserList') is not None:
            self.spec_mixed_user_list = m.get('SpecMixedUserList')
        if m.get('StartWithoutChannel') is not None:
            self.start_without_channel = m.get('StartWithoutChannel')
        if m.get('StartWithoutChannelWaitTime') is not None:
            self.start_without_channel_wait_time = m.get('StartWithoutChannelWaitTime')
        if m.get('SubHighResolutionStream') is not None:
            self.sub_high_resolution_stream = m.get('SubHighResolutionStream')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = StartStreamingOutShrinkRequestTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class StartStreamingOutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StartStreamingOutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartStreamingOutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartStreamingOutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopAgentRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopCategoryCallbackRequestCallback(TeaModel):
    def __init__(
        self,
        category: str = None,
    ):
        # This parameter is required.
        self.category = category

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        return self


class StopCategoryCallbackRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback: StopCategoryCallbackRequestCallback = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback = callback

    def validate(self):
        if self.callback:
            self.callback.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback is not None:
            result['Callback'] = self.callback.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callback') is not None:
            temp_model = StopCategoryCallbackRequestCallback()
            self.callback = temp_model.from_map(m['Callback'])
        return self


class StopCategoryCallbackShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        callback_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.callback_shrink = callback_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.callback_shrink is not None:
            result['Callback'] = self.callback_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Callback') is not None:
            self.callback_shrink = m.get('Callback')
        return self


class StopCategoryCallbackResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopCategoryCallbackResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopCategoryCallbackResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopCategoryCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopChannelRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        return self


class StopChannelResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopCloudNoteRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        client_token: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.client_token = client_token
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopCloudNoteResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopCloudNoteResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopCloudNoteResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopCloudNoteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopCloudRecordRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopCloudRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopCloudRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopCloudRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopCloudRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopMPUTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopMPUTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopMPUTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopMPUTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopMPUTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopRecordTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        owner_id: int = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.owner_id = owner_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopRecordTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopRecordTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopRecordTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopRecordTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopStreamingOutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopStreamingOutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class StopStreamingOutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopStreamingOutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopStreamingOutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAgentRequestVoiceChatConfig(TeaModel):
    def __init__(
        self,
        chat_mode: int = None,
        interrupt_mode: int = None,
    ):
        self.chat_mode = chat_mode
        self.interrupt_mode = interrupt_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chat_mode is not None:
            result['ChatMode'] = self.chat_mode
        if self.interrupt_mode is not None:
            result['InterruptMode'] = self.interrupt_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChatMode') is not None:
            self.chat_mode = m.get('ChatMode')
        if m.get('InterruptMode') is not None:
            self.interrupt_mode = m.get('InterruptMode')
        return self


class UpdateAgentRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
        voice_chat_config: UpdateAgentRequestVoiceChatConfig = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id
        self.voice_chat_config = voice_chat_config

    def validate(self):
        if self.voice_chat_config:
            self.voice_chat_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.voice_chat_config is not None:
            result['VoiceChatConfig'] = self.voice_chat_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('VoiceChatConfig') is not None:
            temp_model = UpdateAgentRequestVoiceChatConfig()
            self.voice_chat_config = temp_model.from_map(m['VoiceChatConfig'])
        return self


class UpdateAgentShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        task_id: str = None,
        voice_chat_config_shrink: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        # This parameter is required.
        self.task_id = task_id
        self.voice_chat_config_shrink = voice_chat_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.voice_chat_config_shrink is not None:
            result['VoiceChatConfig'] = self.voice_chat_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('VoiceChatConfig') is not None:
            self.voice_chat_config_shrink = m.get('VoiceChatConfig')
        return self


class UpdateAgentResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        # Id of the request
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAgentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAgentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAutoLiveStreamRuleRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        call_back: str = None,
        channel_id_prefixes: List[str] = None,
        channel_ids: List[str] = None,
        media_encode: int = None,
        owner_id: int = None,
        play_domain: str = None,
        rule_id: int = None,
        rule_name: str = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.call_back = call_back
        self.channel_id_prefixes = channel_id_prefixes
        self.channel_ids = channel_ids
        self.media_encode = media_encode
        self.owner_id = owner_id
        # This parameter is required.
        self.play_domain = play_domain
        # This parameter is required.
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.call_back is not None:
            result['CallBack'] = self.call_back
        if self.channel_id_prefixes is not None:
            result['ChannelIdPrefixes'] = self.channel_id_prefixes
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.play_domain is not None:
            result['PlayDomain'] = self.play_domain
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('CallBack') is not None:
            self.call_back = m.get('CallBack')
        if m.get('ChannelIdPrefixes') is not None:
            self.channel_id_prefixes = m.get('ChannelIdPrefixes')
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PlayDomain') is not None:
            self.play_domain = m.get('PlayDomain')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class UpdateAutoLiveStreamRuleResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateAutoLiveStreamRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateAutoLiveStreamRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateAutoLiveStreamRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCloudRecordRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateCloudRecordRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: UpdateCloudRecordRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateCloudRecordRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateCloudRecordRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class UpdateCloudRecordRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordRequestLayoutSpecifiedUsers(TeaModel):
    def __init__(
        self,
        ids: List[str] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.ids = ids
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateCloudRecordRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateCloudRecordRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: UpdateCloudRecordRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateCloudRecordRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateCloudRecordRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class UpdateCloudRecordRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[UpdateCloudRecordRequestPanesBackgrounds] = None,
        images: List[UpdateCloudRecordRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: int = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[UpdateCloudRecordRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: UpdateCloudRecordRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        # This parameter is required.
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        self.source = source
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateCloudRecordRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateCloudRecordRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateCloudRecordRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = UpdateCloudRecordRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class UpdateCloudRecordRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateCloudRecordRequestTextsBoxColor = None,
        font: int = None,
        font_color: UpdateCloudRecordRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateCloudRecordRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateCloudRecordRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        backgrounds: List[UpdateCloudRecordRequestBackgrounds] = None,
        channel_id: str = None,
        clock_widgets: List[UpdateCloudRecordRequestClockWidgets] = None,
        images: List[UpdateCloudRecordRequestImages] = None,
        layout_specified_users: UpdateCloudRecordRequestLayoutSpecifiedUsers = None,
        panes: List[UpdateCloudRecordRequestPanes] = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[UpdateCloudRecordRequestTexts] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.images = images
        self.layout_specified_users = layout_specified_users
        self.panes = panes
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.layout_specified_users:
            self.layout_specified_users.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users.to_map()
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateCloudRecordRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = UpdateCloudRecordRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateCloudRecordRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            temp_model = UpdateCloudRecordRequestLayoutSpecifiedUsers()
            self.layout_specified_users = temp_model.from_map(m['LayoutSpecifiedUsers'])
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = UpdateCloudRecordRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateCloudRecordRequestTexts()
                self.texts.append(temp_model.from_map(k))
        return self


class UpdateCloudRecordShrinkRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordShrinkRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordShrinkRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordShrinkRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateCloudRecordShrinkRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: UpdateCloudRecordShrinkRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateCloudRecordShrinkRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateCloudRecordShrinkRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class UpdateCloudRecordShrinkRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordShrinkRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordShrinkRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordShrinkRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordShrinkRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordShrinkRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateCloudRecordShrinkRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: UpdateCloudRecordShrinkRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateCloudRecordShrinkRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateCloudRecordShrinkRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordShrinkRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class UpdateCloudRecordShrinkRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[UpdateCloudRecordShrinkRequestPanesBackgrounds] = None,
        images: List[UpdateCloudRecordShrinkRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: int = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[UpdateCloudRecordShrinkRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: UpdateCloudRecordShrinkRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        # This parameter is required.
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        self.source = source
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateCloudRecordShrinkRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateCloudRecordShrinkRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateCloudRecordShrinkRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = UpdateCloudRecordShrinkRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class UpdateCloudRecordShrinkRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordShrinkRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateCloudRecordShrinkRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateCloudRecordShrinkRequestTextsBoxColor = None,
        font: int = None,
        font_color: UpdateCloudRecordShrinkRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateCloudRecordShrinkRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateCloudRecordShrinkRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateCloudRecordShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        backgrounds: List[UpdateCloudRecordShrinkRequestBackgrounds] = None,
        channel_id: str = None,
        clock_widgets: List[UpdateCloudRecordShrinkRequestClockWidgets] = None,
        images: List[UpdateCloudRecordShrinkRequestImages] = None,
        layout_specified_users_shrink: str = None,
        panes: List[UpdateCloudRecordShrinkRequestPanes] = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[UpdateCloudRecordShrinkRequestTexts] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.images = images
        self.layout_specified_users_shrink = layout_specified_users_shrink
        self.panes = panes
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users_shrink is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users_shrink
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateCloudRecordShrinkRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = UpdateCloudRecordShrinkRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateCloudRecordShrinkRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            self.layout_specified_users_shrink = m.get('LayoutSpecifiedUsers')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = UpdateCloudRecordShrinkRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateCloudRecordShrinkRequestTexts()
                self.texts.append(temp_model.from_map(k))
        return self


class UpdateCloudRecordResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateCloudRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCloudRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCloudRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMPUTaskRequestBackgrounds(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateMPUTaskRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        border_color: int = None,
        border_width: int = None,
        box: bool = None,
        box_border_width: int = None,
        box_color: int = None,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.border_color = border_color
        self.border_width = border_width
        self.box = box
        self.box_border_width = box_border_width
        self.box_color = box_color
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.box is not None:
            result['Box'] = self.box
        if self.box_border_width is not None:
            result['BoxBorderWidth'] = self.box_border_width
        if self.box_color is not None:
            result['BoxColor'] = self.box_color
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Box') is not None:
            self.box = m.get('Box')
        if m.get('BoxBorderWidth') is not None:
            self.box_border_width = m.get('BoxBorderWidth')
        if m.get('BoxColor') is not None:
            self.box_color = m.get('BoxColor')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateMPUTaskRequestUserPanesImages(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateMPUTaskRequestUserPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        border_color: int = None,
        border_width: int = None,
        box: bool = None,
        box_border_width: int = None,
        box_color: int = None,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        text: str = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.border_color = border_color
        self.border_width = border_width
        self.box = box
        self.box_border_width = box_border_width
        self.box_color = box_color
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.text = text
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.box is not None:
            result['Box'] = self.box
        if self.box_border_width is not None:
            result['BoxBorderWidth'] = self.box_border_width
        if self.box_color is not None:
            result['BoxColor'] = self.box_color
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.text is not None:
            result['Text'] = self.text
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Box') is not None:
            self.box = m.get('Box')
        if m.get('BoxBorderWidth') is not None:
            self.box_border_width = m.get('BoxBorderWidth')
        if m.get('BoxColor') is not None:
            self.box_color = m.get('BoxColor')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateMPUTaskRequestUserPanes(TeaModel):
    def __init__(
        self,
        images: List[UpdateMPUTaskRequestUserPanesImages] = None,
        pane_id: int = None,
        segment_type: int = None,
        source_type: str = None,
        texts: List[UpdateMPUTaskRequestUserPanesTexts] = None,
        user_id: str = None,
    ):
        self.images = images
        self.pane_id = pane_id
        self.segment_type = segment_type
        self.source_type = source_type
        self.texts = texts
        self.user_id = user_id

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.segment_type is not None:
            result['SegmentType'] = self.segment_type
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateMPUTaskRequestUserPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('SegmentType') is not None:
            self.segment_type = m.get('SegmentType')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateMPUTaskRequestUserPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateMPUTaskRequestWatermarks(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateMPUTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        background_color: int = None,
        backgrounds: List[UpdateMPUTaskRequestBackgrounds] = None,
        clock_widgets: List[UpdateMPUTaskRequestClockWidgets] = None,
        crop_mode: int = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        mix_mode: int = None,
        owner_id: int = None,
        source_type: str = None,
        stream_type: int = None,
        sub_spec_audio_users: List[str] = None,
        sub_spec_camera_users: List[str] = None,
        sub_spec_share_screen_users: List[str] = None,
        sub_spec_users: List[str] = None,
        task_id: str = None,
        unsub_spec_audio_users: List[str] = None,
        unsub_spec_camera_users: List[str] = None,
        unsub_spec_share_screen_users: List[str] = None,
        user_panes: List[UpdateMPUTaskRequestUserPanes] = None,
        watermarks: List[UpdateMPUTaskRequestWatermarks] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.background_color = background_color
        self.backgrounds = backgrounds
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.mix_mode = mix_mode
        self.owner_id = owner_id
        self.source_type = source_type
        self.stream_type = stream_type
        self.sub_spec_audio_users = sub_spec_audio_users
        self.sub_spec_camera_users = sub_spec_camera_users
        self.sub_spec_share_screen_users = sub_spec_share_screen_users
        self.sub_spec_users = sub_spec_users
        # This parameter is required.
        self.task_id = task_id
        self.unsub_spec_audio_users = unsub_spec_audio_users
        self.unsub_spec_camera_users = unsub_spec_camera_users
        self.unsub_spec_share_screen_users = unsub_spec_share_screen_users
        self.user_panes = user_panes
        self.watermarks = watermarks

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()
        if self.watermarks:
            for k in self.watermarks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.background_color is not None:
            result['BackgroundColor'] = self.background_color
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.mix_mode is not None:
            result['MixMode'] = self.mix_mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.sub_spec_audio_users is not None:
            result['SubSpecAudioUsers'] = self.sub_spec_audio_users
        if self.sub_spec_camera_users is not None:
            result['SubSpecCameraUsers'] = self.sub_spec_camera_users
        if self.sub_spec_share_screen_users is not None:
            result['SubSpecShareScreenUsers'] = self.sub_spec_share_screen_users
        if self.sub_spec_users is not None:
            result['SubSpecUsers'] = self.sub_spec_users
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.unsub_spec_audio_users is not None:
            result['UnsubSpecAudioUsers'] = self.unsub_spec_audio_users
        if self.unsub_spec_camera_users is not None:
            result['UnsubSpecCameraUsers'] = self.unsub_spec_camera_users
        if self.unsub_spec_share_screen_users is not None:
            result['UnsubSpecShareScreenUsers'] = self.unsub_spec_share_screen_users
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        result['Watermarks'] = []
        if self.watermarks is not None:
            for k in self.watermarks:
                result['Watermarks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BackgroundColor') is not None:
            self.background_color = m.get('BackgroundColor')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateMPUTaskRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = UpdateMPUTaskRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('MixMode') is not None:
            self.mix_mode = m.get('MixMode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('SubSpecAudioUsers') is not None:
            self.sub_spec_audio_users = m.get('SubSpecAudioUsers')
        if m.get('SubSpecCameraUsers') is not None:
            self.sub_spec_camera_users = m.get('SubSpecCameraUsers')
        if m.get('SubSpecShareScreenUsers') is not None:
            self.sub_spec_share_screen_users = m.get('SubSpecShareScreenUsers')
        if m.get('SubSpecUsers') is not None:
            self.sub_spec_users = m.get('SubSpecUsers')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UnsubSpecAudioUsers') is not None:
            self.unsub_spec_audio_users = m.get('UnsubSpecAudioUsers')
        if m.get('UnsubSpecCameraUsers') is not None:
            self.unsub_spec_camera_users = m.get('UnsubSpecCameraUsers')
        if m.get('UnsubSpecShareScreenUsers') is not None:
            self.unsub_spec_share_screen_users = m.get('UnsubSpecShareScreenUsers')
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = UpdateMPUTaskRequestUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        self.watermarks = []
        if m.get('Watermarks') is not None:
            for k in m.get('Watermarks'):
                temp_model = UpdateMPUTaskRequestWatermarks()
                self.watermarks.append(temp_model.from_map(k))
        return self


class UpdateMPUTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMPUTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMPUTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMPUTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRecordTaskRequestUserPanesImages(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateRecordTaskRequestUserPanesTexts(TeaModel):
    def __init__(
        self,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        text: str = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.text = text
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.text is not None:
            result['Text'] = self.text
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateRecordTaskRequestUserPanes(TeaModel):
    def __init__(
        self,
        images: List[UpdateRecordTaskRequestUserPanesImages] = None,
        pane_id: int = None,
        source_type: str = None,
        texts: List[UpdateRecordTaskRequestUserPanesTexts] = None,
        user_id: str = None,
    ):
        self.images = images
        self.pane_id = pane_id
        self.source_type = source_type
        self.texts = texts
        self.user_id = user_id

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateRecordTaskRequestUserPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateRecordTaskRequestUserPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class UpdateRecordTaskRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        channel_id: str = None,
        crop_mode: int = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        owner_id: int = None,
        sub_spec_audio_users: List[str] = None,
        sub_spec_camera_users: List[str] = None,
        sub_spec_share_screen_users: List[str] = None,
        sub_spec_users: List[str] = None,
        task_id: str = None,
        task_profile: str = None,
        template_id: str = None,
        unsub_spec_audio_users: List[str] = None,
        unsub_spec_camera_users: List[str] = None,
        unsub_spec_share_screen_users: List[str] = None,
        user_panes: List[UpdateRecordTaskRequestUserPanes] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        # This parameter is required.
        self.channel_id = channel_id
        self.crop_mode = crop_mode
        self.layout_ids = layout_ids
        self.media_encode = media_encode
        self.owner_id = owner_id
        self.sub_spec_audio_users = sub_spec_audio_users
        self.sub_spec_camera_users = sub_spec_camera_users
        self.sub_spec_share_screen_users = sub_spec_share_screen_users
        self.sub_spec_users = sub_spec_users
        # This parameter is required.
        self.task_id = task_id
        self.task_profile = task_profile
        # This parameter is required.
        self.template_id = template_id
        self.unsub_spec_audio_users = unsub_spec_audio_users
        self.unsub_spec_camera_users = unsub_spec_camera_users
        self.unsub_spec_share_screen_users = unsub_spec_share_screen_users
        self.user_panes = user_panes

    def validate(self):
        if self.user_panes:
            for k in self.user_panes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.sub_spec_audio_users is not None:
            result['SubSpecAudioUsers'] = self.sub_spec_audio_users
        if self.sub_spec_camera_users is not None:
            result['SubSpecCameraUsers'] = self.sub_spec_camera_users
        if self.sub_spec_share_screen_users is not None:
            result['SubSpecShareScreenUsers'] = self.sub_spec_share_screen_users
        if self.sub_spec_users is not None:
            result['SubSpecUsers'] = self.sub_spec_users
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_profile is not None:
            result['TaskProfile'] = self.task_profile
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.unsub_spec_audio_users is not None:
            result['UnsubSpecAudioUsers'] = self.unsub_spec_audio_users
        if self.unsub_spec_camera_users is not None:
            result['UnsubSpecCameraUsers'] = self.unsub_spec_camera_users
        if self.unsub_spec_share_screen_users is not None:
            result['UnsubSpecShareScreenUsers'] = self.unsub_spec_share_screen_users
        result['UserPanes'] = []
        if self.user_panes is not None:
            for k in self.user_panes:
                result['UserPanes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('SubSpecAudioUsers') is not None:
            self.sub_spec_audio_users = m.get('SubSpecAudioUsers')
        if m.get('SubSpecCameraUsers') is not None:
            self.sub_spec_camera_users = m.get('SubSpecCameraUsers')
        if m.get('SubSpecShareScreenUsers') is not None:
            self.sub_spec_share_screen_users = m.get('SubSpecShareScreenUsers')
        if m.get('SubSpecUsers') is not None:
            self.sub_spec_users = m.get('SubSpecUsers')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskProfile') is not None:
            self.task_profile = m.get('TaskProfile')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UnsubSpecAudioUsers') is not None:
            self.unsub_spec_audio_users = m.get('UnsubSpecAudioUsers')
        if m.get('UnsubSpecCameraUsers') is not None:
            self.unsub_spec_camera_users = m.get('UnsubSpecCameraUsers')
        if m.get('UnsubSpecShareScreenUsers') is not None:
            self.unsub_spec_share_screen_users = m.get('UnsubSpecShareScreenUsers')
        self.user_panes = []
        if m.get('UserPanes') is not None:
            for k in m.get('UserPanes'):
                temp_model = UpdateRecordTaskRequestUserPanes()
                self.user_panes.append(temp_model.from_map(k))
        return self


class UpdateRecordTaskResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
    ):
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateRecordTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRecordTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRecordTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRecordTemplateRequestBackgrounds(TeaModel):
    def __init__(
        self,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateRecordTemplateRequestClockWidgets(TeaModel):
    def __init__(
        self,
        font_color: int = None,
        font_size: int = None,
        font_type: int = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.font_color = font_color
        self.font_size = font_size
        self.font_type = font_type
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.font_type is not None:
            result['FontType'] = self.font_type
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('FontType') is not None:
            self.font_type = m.get('FontType')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateRecordTemplateRequestWatermarks(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: int = None,
        height: float = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
        zorder: int = None,
    ):
        self.alpha = alpha
        self.display = display
        self.height = height
        self.url = url
        self.width = width
        self.x = x
        self.y = y
        self.zorder = zorder

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zorder is not None:
            result['ZOrder'] = self.zorder
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('ZOrder') is not None:
            self.zorder = m.get('ZOrder')
        return self


class UpdateRecordTemplateRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        background_color: int = None,
        backgrounds: List[UpdateRecordTemplateRequestBackgrounds] = None,
        clock_widgets: List[UpdateRecordTemplateRequestClockWidgets] = None,
        delay_stop_time: int = None,
        enable_m3u_8date_time: bool = None,
        file_split_interval: int = None,
        formats: List[str] = None,
        http_callback_url: str = None,
        layout_ids: List[int] = None,
        media_encode: int = None,
        mns_queue: str = None,
        name: str = None,
        oss_bucket: str = None,
        oss_endpoint: str = None,
        oss_file_prefix: str = None,
        owner_id: int = None,
        task_profile: str = None,
        template_id: str = None,
        watermarks: List[UpdateRecordTemplateRequestWatermarks] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.background_color = background_color
        self.backgrounds = backgrounds
        self.clock_widgets = clock_widgets
        self.delay_stop_time = delay_stop_time
        self.enable_m3u_8date_time = enable_m3u_8date_time
        # This parameter is required.
        self.file_split_interval = file_split_interval
        # This parameter is required.
        self.formats = formats
        self.http_callback_url = http_callback_url
        # This parameter is required.
        self.layout_ids = layout_ids
        # This parameter is required.
        self.media_encode = media_encode
        self.mns_queue = mns_queue
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.oss_bucket = oss_bucket
        self.oss_endpoint = oss_endpoint
        # This parameter is required.
        self.oss_file_prefix = oss_file_prefix
        self.owner_id = owner_id
        # This parameter is required.
        self.task_profile = task_profile
        # This parameter is required.
        self.template_id = template_id
        self.watermarks = watermarks

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.watermarks:
            for k in self.watermarks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.background_color is not None:
            result['BackgroundColor'] = self.background_color
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.delay_stop_time is not None:
            result['DelayStopTime'] = self.delay_stop_time
        if self.enable_m3u_8date_time is not None:
            result['EnableM3u8DateTime'] = self.enable_m3u_8date_time
        if self.file_split_interval is not None:
            result['FileSplitInterval'] = self.file_split_interval
        if self.formats is not None:
            result['Formats'] = self.formats
        if self.http_callback_url is not None:
            result['HttpCallbackUrl'] = self.http_callback_url
        if self.layout_ids is not None:
            result['LayoutIds'] = self.layout_ids
        if self.media_encode is not None:
            result['MediaEncode'] = self.media_encode
        if self.mns_queue is not None:
            result['MnsQueue'] = self.mns_queue
        if self.name is not None:
            result['Name'] = self.name
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_endpoint is not None:
            result['OssEndpoint'] = self.oss_endpoint
        if self.oss_file_prefix is not None:
            result['OssFilePrefix'] = self.oss_file_prefix
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.task_profile is not None:
            result['TaskProfile'] = self.task_profile
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Watermarks'] = []
        if self.watermarks is not None:
            for k in self.watermarks:
                result['Watermarks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('BackgroundColor') is not None:
            self.background_color = m.get('BackgroundColor')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateRecordTemplateRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = UpdateRecordTemplateRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('DelayStopTime') is not None:
            self.delay_stop_time = m.get('DelayStopTime')
        if m.get('EnableM3u8DateTime') is not None:
            self.enable_m3u_8date_time = m.get('EnableM3u8DateTime')
        if m.get('FileSplitInterval') is not None:
            self.file_split_interval = m.get('FileSplitInterval')
        if m.get('Formats') is not None:
            self.formats = m.get('Formats')
        if m.get('HttpCallbackUrl') is not None:
            self.http_callback_url = m.get('HttpCallbackUrl')
        if m.get('LayoutIds') is not None:
            self.layout_ids = m.get('LayoutIds')
        if m.get('MediaEncode') is not None:
            self.media_encode = m.get('MediaEncode')
        if m.get('MnsQueue') is not None:
            self.mns_queue = m.get('MnsQueue')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssEndpoint') is not None:
            self.oss_endpoint = m.get('OssEndpoint')
        if m.get('OssFilePrefix') is not None:
            self.oss_file_prefix = m.get('OssFilePrefix')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('TaskProfile') is not None:
            self.task_profile = m.get('TaskProfile')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.watermarks = []
        if m.get('Watermarks') is not None:
            for k in m.get('Watermarks'):
                temp_model = UpdateRecordTemplateRequestWatermarks()
                self.watermarks.append(temp_model.from_map(k))
        return self


class UpdateRecordTemplateResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        template_id: str = None,
    ):
        self.request_id = request_id
        self.template_id = template_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateRecordTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRecordTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateStreamingOutRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutRequestBgColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateStreamingOutRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: UpdateStreamingOutRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateStreamingOutRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateStreamingOutRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class UpdateStreamingOutRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutRequestLayoutSpecifiedUsers(TeaModel):
    def __init__(
        self,
        ids: List[str] = None,
        type: str = None,
    ):
        # This parameter is required.
        self.ids = ids
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateStreamingOutRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateStreamingOutRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: UpdateStreamingOutRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateStreamingOutRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateStreamingOutRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class UpdateStreamingOutRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[UpdateStreamingOutRequestPanesBackgrounds] = None,
        images: List[UpdateStreamingOutRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: int = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[UpdateStreamingOutRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: UpdateStreamingOutRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        self.source = source
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateStreamingOutRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateStreamingOutRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateStreamingOutRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = UpdateStreamingOutRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class UpdateStreamingOutRequestRegionColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateStreamingOutRequestTextsBoxColor = None,
        font: int = None,
        font_color: UpdateStreamingOutRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateStreamingOutRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateStreamingOutRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        backgrounds: List[UpdateStreamingOutRequestBackgrounds] = None,
        bg_color: UpdateStreamingOutRequestBgColor = None,
        channel_id: str = None,
        clock_widgets: List[UpdateStreamingOutRequestClockWidgets] = None,
        crop_mode: int = None,
        images: List[UpdateStreamingOutRequestImages] = None,
        layout_specified_users: UpdateStreamingOutRequestLayoutSpecifiedUsers = None,
        panes: List[UpdateStreamingOutRequestPanes] = None,
        region_color: UpdateStreamingOutRequestRegionColor = None,
        spec_mixed_user_list: List[str] = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[UpdateStreamingOutRequestTexts] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        self.bg_color = bg_color
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.images = images
        self.layout_specified_users = layout_specified_users
        self.panes = panes
        self.region_color = region_color
        self.spec_mixed_user_list = spec_mixed_user_list
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.bg_color:
            self.bg_color.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.layout_specified_users:
            self.layout_specified_users.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.region_color:
            self.region_color.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users.to_map()
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.region_color is not None:
            result['RegionColor'] = self.region_color.to_map()
        if self.spec_mixed_user_list is not None:
            result['SpecMixedUserList'] = self.spec_mixed_user_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateStreamingOutRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('BgColor') is not None:
            temp_model = UpdateStreamingOutRequestBgColor()
            self.bg_color = temp_model.from_map(m['BgColor'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = UpdateStreamingOutRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateStreamingOutRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            temp_model = UpdateStreamingOutRequestLayoutSpecifiedUsers()
            self.layout_specified_users = temp_model.from_map(m['LayoutSpecifiedUsers'])
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = UpdateStreamingOutRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('RegionColor') is not None:
            temp_model = UpdateStreamingOutRequestRegionColor()
            self.region_color = temp_model.from_map(m['RegionColor'])
        if m.get('SpecMixedUserList') is not None:
            self.spec_mixed_user_list = m.get('SpecMixedUserList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateStreamingOutRequestTexts()
                self.texts.append(temp_model.from_map(k))
        return self


class UpdateStreamingOutShrinkRequestBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        background_crop_mode: int = None,
        height: float = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.background_crop_mode = background_crop_mode
        # This parameter is required.
        self.height = height
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.background_crop_mode is not None:
            result['BackgroundCropMode'] = self.background_crop_mode
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BackgroundCropMode') is not None:
            self.background_crop_mode = m.get('BackgroundCropMode')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutShrinkRequestBgColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestClockWidgetsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestClockWidgetsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestClockWidgets(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateStreamingOutShrinkRequestClockWidgetsBoxColor = None,
        font: int = None,
        font_color: UpdateStreamingOutShrinkRequestClockWidgetsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        x: float = None,
        y: float = None,
        zone: int = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y
        self.zone = zone

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestClockWidgetsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestClockWidgetsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class UpdateStreamingOutShrinkRequestImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        height: float = None,
        image_crop_mode: int = None,
        layer: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        # This parameter is required.
        self.height = height
        self.image_crop_mode = image_crop_mode
        self.layer = layer
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.height is not None:
            result['Height'] = self.height
        if self.image_crop_mode is not None:
            result['ImageCropMode'] = self.image_crop_mode
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ImageCropMode') is not None:
            self.image_crop_mode = m.get('ImageCropMode')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutShrinkRequestPanesBackgrounds(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_background_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_background_crop_mode = pane_background_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_background_crop_mode is not None:
            result['PaneBackgroundCropMode'] = self.pane_background_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneBackgroundCropMode') is not None:
            self.pane_background_crop_mode = m.get('PaneBackgroundCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutShrinkRequestPanesImages(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        display: str = None,
        height: float = None,
        layer: int = None,
        pane_image_crop_mode: int = None,
        url: str = None,
        width: float = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.display = display
        # This parameter is required.
        self.height = height
        self.layer = layer
        self.pane_image_crop_mode = pane_image_crop_mode
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.width = width
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.display is not None:
            result['Display'] = self.display
        if self.height is not None:
            result['Height'] = self.height
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.pane_image_crop_mode is not None:
            result['PaneImageCropMode'] = self.pane_image_crop_mode
        if self.url is not None:
            result['Url'] = self.url
        if self.width is not None:
            result['Width'] = self.width
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('PaneImageCropMode') is not None:
            self.pane_image_crop_mode = m.get('PaneImageCropMode')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutShrinkRequestPanesTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestPanesTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestPanesTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateStreamingOutShrinkRequestPanesTextsBoxColor = None,
        display: str = None,
        font: int = None,
        font_color: UpdateStreamingOutShrinkRequestPanesTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.display = display
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.display is not None:
            result['Display'] = self.display
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestPanesTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Display') is not None:
            self.display = m.get('Display')
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestPanesTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutShrinkRequestPanesWhiteboard(TeaModel):
    def __init__(
        self,
        whiteboard_id: str = None,
    ):
        self.whiteboard_id = whiteboard_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.whiteboard_id is not None:
            result['WhiteboardId'] = self.whiteboard_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WhiteboardId') is not None:
            self.whiteboard_id = m.get('WhiteboardId')
        return self


class UpdateStreamingOutShrinkRequestPanes(TeaModel):
    def __init__(
        self,
        backgrounds: List[UpdateStreamingOutShrinkRequestPanesBackgrounds] = None,
        images: List[UpdateStreamingOutShrinkRequestPanesImages] = None,
        pane_crop_mode: int = None,
        pane_id: int = None,
        reserve_pane_for_offline_user: bool = None,
        source: str = None,
        source_type: str = None,
        texts: List[UpdateStreamingOutShrinkRequestPanesTexts] = None,
        video_order: str = None,
        whiteboard: UpdateStreamingOutShrinkRequestPanesWhiteboard = None,
    ):
        self.backgrounds = backgrounds
        self.images = images
        self.pane_crop_mode = pane_crop_mode
        self.pane_id = pane_id
        self.reserve_pane_for_offline_user = reserve_pane_for_offline_user
        self.source = source
        self.source_type = source_type
        self.texts = texts
        self.video_order = video_order
        self.whiteboard = whiteboard

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()
        if self.whiteboard:
            self.whiteboard.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.pane_crop_mode is not None:
            result['PaneCropMode'] = self.pane_crop_mode
        if self.pane_id is not None:
            result['PaneId'] = self.pane_id
        if self.reserve_pane_for_offline_user is not None:
            result['ReservePaneForOfflineUser'] = self.reserve_pane_for_offline_user
        if self.source is not None:
            result['Source'] = self.source
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        if self.video_order is not None:
            result['VideoOrder'] = self.video_order
        if self.whiteboard is not None:
            result['Whiteboard'] = self.whiteboard.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateStreamingOutShrinkRequestPanesBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateStreamingOutShrinkRequestPanesImages()
                self.images.append(temp_model.from_map(k))
        if m.get('PaneCropMode') is not None:
            self.pane_crop_mode = m.get('PaneCropMode')
        if m.get('PaneId') is not None:
            self.pane_id = m.get('PaneId')
        if m.get('ReservePaneForOfflineUser') is not None:
            self.reserve_pane_for_offline_user = m.get('ReservePaneForOfflineUser')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateStreamingOutShrinkRequestPanesTexts()
                self.texts.append(temp_model.from_map(k))
        if m.get('VideoOrder') is not None:
            self.video_order = m.get('VideoOrder')
        if m.get('Whiteboard') is not None:
            temp_model = UpdateStreamingOutShrinkRequestPanesWhiteboard()
            self.whiteboard = temp_model.from_map(m['Whiteboard'])
        return self


class UpdateStreamingOutShrinkRequestRegionColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestTextsBoxColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestTextsFontColor(TeaModel):
    def __init__(
        self,
        b: int = None,
        g: int = None,
        r: int = None,
    ):
        self.b = b
        self.g = g
        self.r = r

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.b is not None:
            result['B'] = self.b
        if self.g is not None:
            result['G'] = self.g
        if self.r is not None:
            result['R'] = self.r
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('B') is not None:
            self.b = m.get('B')
        if m.get('G') is not None:
            self.g = m.get('G')
        if m.get('R') is not None:
            self.r = m.get('R')
        return self


class UpdateStreamingOutShrinkRequestTexts(TeaModel):
    def __init__(
        self,
        alpha: float = None,
        box_alpha: float = None,
        box_borderw: int = None,
        box_color: UpdateStreamingOutShrinkRequestTextsBoxColor = None,
        font: int = None,
        font_color: UpdateStreamingOutShrinkRequestTextsFontColor = None,
        font_size: int = None,
        has_box: bool = None,
        layer: int = None,
        texture: str = None,
        x: float = None,
        y: float = None,
    ):
        self.alpha = alpha
        self.box_alpha = box_alpha
        self.box_borderw = box_borderw
        self.box_color = box_color
        self.font = font
        self.font_color = font_color
        self.font_size = font_size
        self.has_box = has_box
        self.layer = layer
        # This parameter is required.
        self.texture = texture
        # This parameter is required.
        self.x = x
        # This parameter is required.
        self.y = y

    def validate(self):
        if self.box_color:
            self.box_color.validate()
        if self.font_color:
            self.font_color.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alpha is not None:
            result['Alpha'] = self.alpha
        if self.box_alpha is not None:
            result['BoxAlpha'] = self.box_alpha
        if self.box_borderw is not None:
            result['BoxBorderw'] = self.box_borderw
        if self.box_color is not None:
            result['BoxColor'] = self.box_color.to_map()
        if self.font is not None:
            result['Font'] = self.font
        if self.font_color is not None:
            result['FontColor'] = self.font_color.to_map()
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.has_box is not None:
            result['HasBox'] = self.has_box
        if self.layer is not None:
            result['Layer'] = self.layer
        if self.texture is not None:
            result['Texture'] = self.texture
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alpha') is not None:
            self.alpha = m.get('Alpha')
        if m.get('BoxAlpha') is not None:
            self.box_alpha = m.get('BoxAlpha')
        if m.get('BoxBorderw') is not None:
            self.box_borderw = m.get('BoxBorderw')
        if m.get('BoxColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestTextsBoxColor()
            self.box_color = temp_model.from_map(m['BoxColor'])
        if m.get('Font') is not None:
            self.font = m.get('Font')
        if m.get('FontColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestTextsFontColor()
            self.font_color = temp_model.from_map(m['FontColor'])
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('HasBox') is not None:
            self.has_box = m.get('HasBox')
        if m.get('Layer') is not None:
            self.layer = m.get('Layer')
        if m.get('Texture') is not None:
            self.texture = m.get('Texture')
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class UpdateStreamingOutShrinkRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        backgrounds: List[UpdateStreamingOutShrinkRequestBackgrounds] = None,
        bg_color: UpdateStreamingOutShrinkRequestBgColor = None,
        channel_id: str = None,
        clock_widgets: List[UpdateStreamingOutShrinkRequestClockWidgets] = None,
        crop_mode: int = None,
        images: List[UpdateStreamingOutShrinkRequestImages] = None,
        layout_specified_users_shrink: str = None,
        panes: List[UpdateStreamingOutShrinkRequestPanes] = None,
        region_color: UpdateStreamingOutShrinkRequestRegionColor = None,
        spec_mixed_user_list: List[str] = None,
        task_id: str = None,
        template_id: str = None,
        texts: List[UpdateStreamingOutShrinkRequestTexts] = None,
    ):
        # This parameter is required.
        self.app_id = app_id
        self.backgrounds = backgrounds
        self.bg_color = bg_color
        # This parameter is required.
        self.channel_id = channel_id
        self.clock_widgets = clock_widgets
        self.crop_mode = crop_mode
        self.images = images
        self.layout_specified_users_shrink = layout_specified_users_shrink
        self.panes = panes
        self.region_color = region_color
        self.spec_mixed_user_list = spec_mixed_user_list
        # This parameter is required.
        self.task_id = task_id
        # This parameter is required.
        self.template_id = template_id
        self.texts = texts

    def validate(self):
        if self.backgrounds:
            for k in self.backgrounds:
                if k:
                    k.validate()
        if self.bg_color:
            self.bg_color.validate()
        if self.clock_widgets:
            for k in self.clock_widgets:
                if k:
                    k.validate()
        if self.images:
            for k in self.images:
                if k:
                    k.validate()
        if self.panes:
            for k in self.panes:
                if k:
                    k.validate()
        if self.region_color:
            self.region_color.validate()
        if self.texts:
            for k in self.texts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        result['Backgrounds'] = []
        if self.backgrounds is not None:
            for k in self.backgrounds:
                result['Backgrounds'].append(k.to_map() if k else None)
        if self.bg_color is not None:
            result['BgColor'] = self.bg_color.to_map()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        result['ClockWidgets'] = []
        if self.clock_widgets is not None:
            for k in self.clock_widgets:
                result['ClockWidgets'].append(k.to_map() if k else None)
        if self.crop_mode is not None:
            result['CropMode'] = self.crop_mode
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.layout_specified_users_shrink is not None:
            result['LayoutSpecifiedUsers'] = self.layout_specified_users_shrink
        result['Panes'] = []
        if self.panes is not None:
            for k in self.panes:
                result['Panes'].append(k.to_map() if k else None)
        if self.region_color is not None:
            result['RegionColor'] = self.region_color.to_map()
        if self.spec_mixed_user_list is not None:
            result['SpecMixedUserList'] = self.spec_mixed_user_list
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        result['Texts'] = []
        if self.texts is not None:
            for k in self.texts:
                result['Texts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        self.backgrounds = []
        if m.get('Backgrounds') is not None:
            for k in m.get('Backgrounds'):
                temp_model = UpdateStreamingOutShrinkRequestBackgrounds()
                self.backgrounds.append(temp_model.from_map(k))
        if m.get('BgColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestBgColor()
            self.bg_color = temp_model.from_map(m['BgColor'])
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        self.clock_widgets = []
        if m.get('ClockWidgets') is not None:
            for k in m.get('ClockWidgets'):
                temp_model = UpdateStreamingOutShrinkRequestClockWidgets()
                self.clock_widgets.append(temp_model.from_map(k))
        if m.get('CropMode') is not None:
            self.crop_mode = m.get('CropMode')
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = UpdateStreamingOutShrinkRequestImages()
                self.images.append(temp_model.from_map(k))
        if m.get('LayoutSpecifiedUsers') is not None:
            self.layout_specified_users_shrink = m.get('LayoutSpecifiedUsers')
        self.panes = []
        if m.get('Panes') is not None:
            for k in m.get('Panes'):
                temp_model = UpdateStreamingOutShrinkRequestPanes()
                self.panes.append(temp_model.from_map(k))
        if m.get('RegionColor') is not None:
            temp_model = UpdateStreamingOutShrinkRequestRegionColor()
            self.region_color = temp_model.from_map(m['RegionColor'])
        if m.get('SpecMixedUserList') is not None:
            self.spec_mixed_user_list = m.get('SpecMixedUserList')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        self.texts = []
        if m.get('Texts') is not None:
            for k in m.get('Texts'):
                temp_model = UpdateStreamingOutShrinkRequestTexts()
                self.texts.append(temp_model.from_map(k))
        return self


class UpdateStreamingOutResponseBody(TeaModel):
    def __init__(
        self,
        request_id: str = None,
        task_id: str = None,
    ):
        self.request_id = request_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class UpdateStreamingOutResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateStreamingOutResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateStreamingOutResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


